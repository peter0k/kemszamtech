<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />
<title>cpp_bsc</title><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<style type="text/css">
    /*!
*
* Twitter Bootstrap
*
*/
/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */
html {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
}
body {
  margin: 0;
}
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}
audio,
canvas,
progress,
video {
  display: inline-block;
  vertical-align: baseline;
}
audio:not([controls]) {
  display: none;
  height: 0;
}
[hidden],
template {
  display: none;
}
a {
  background-color: transparent;
}
a:active,
a:hover {
  outline: 0;
}
abbr[title] {
  border-bottom: 1px dotted;
}
b,
strong {
  font-weight: bold;
}
dfn {
  font-style: italic;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
mark {
  background: #ff0;
  color: #000;
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sup {
  top: -0.5em;
}
sub {
  bottom: -0.25em;
}
img {
  border: 0;
}
svg:not(:root) {
  overflow: hidden;
}
figure {
  margin: 1em 40px;
}
hr {
  box-sizing: content-box;
  height: 0;
}
pre {
  overflow: auto;
}
code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}
button,
input,
optgroup,
select,
textarea {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
}
button,
select {
  text-transform: none;
}
button,
html input[type="button"],
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button;
  cursor: pointer;
}
button[disabled],
html input[disabled] {
  cursor: default;
}
button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
input {
  line-height: normal;
}
input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box;
  padding: 0;
}
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  height: auto;
}
input[type="search"] {
  -webkit-appearance: textfield;
  box-sizing: content-box;
}
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}
legend {
  border: 0;
  padding: 0;
}
textarea {
  overflow: auto;
}
optgroup {
  font-weight: bold;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
td,
th {
  padding: 0;
}
/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */
@media print {
  *,
  *:before,
  *:after {
    background: transparent !important;
    color: #000 !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }
  a,
  a:visited {
    text-decoration: underline;
  }
  a[href]:after {
    content: " (" attr(href) ")";
  }
  abbr[title]:after {
    content: " (" attr(title) ")";
  }
  a[href^="#"]:after,
  a[href^="javascript:"]:after {
    content: "";
  }
  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid;
  }
  thead {
    display: table-header-group;
  }
  tr,
  img {
    page-break-inside: avoid;
  }
  img {
    max-width: 100% !important;
  }
  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3;
  }
  h2,
  h3 {
    page-break-after: avoid;
  }
  .navbar {
    display: none;
  }
  .btn > .caret,
  .dropup > .btn > .caret {
    border-top-color: #000 !important;
  }
  .label {
    border: 1px solid #000;
  }
  .table {
    border-collapse: collapse !important;
  }
  .table td,
  .table th {
    background-color: #fff !important;
  }
  .table-bordered th,
  .table-bordered td {
    border: 1px solid #ddd !important;
  }
}
@font-face {
  font-family: 'Glyphicons Halflings';
  src: url('../components/bootstrap/fonts/glyphicons-halflings-regular.eot');
  src: url('../components/bootstrap/fonts/glyphicons-halflings-regular.eot?#iefix') format('embedded-opentype'), url('../components/bootstrap/fonts/glyphicons-halflings-regular.woff2') format('woff2'), url('../components/bootstrap/fonts/glyphicons-halflings-regular.woff') format('woff'), url('../components/bootstrap/fonts/glyphicons-halflings-regular.ttf') format('truetype'), url('../components/bootstrap/fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular') format('svg');
}
.glyphicon {
  position: relative;
  top: 1px;
  display: inline-block;
  font-family: 'Glyphicons Halflings';
  font-style: normal;
  font-weight: normal;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
.glyphicon-asterisk:before {
  content: "\002a";
}
.glyphicon-plus:before {
  content: "\002b";
}
.glyphicon-euro:before,
.glyphicon-eur:before {
  content: "\20ac";
}
.glyphicon-minus:before {
  content: "\2212";
}
.glyphicon-cloud:before {
  content: "\2601";
}
.glyphicon-envelope:before {
  content: "\2709";
}
.glyphicon-pencil:before {
  content: "\270f";
}
.glyphicon-glass:before {
  content: "\e001";
}
.glyphicon-music:before {
  content: "\e002";
}
.glyphicon-search:before {
  content: "\e003";
}
.glyphicon-heart:before {
  content: "\e005";
}
.glyphicon-star:before {
  content: "\e006";
}
.glyphicon-star-empty:before {
  content: "\e007";
}
.glyphicon-user:before {
  content: "\e008";
}
.glyphicon-film:before {
  content: "\e009";
}
.glyphicon-th-large:before {
  content: "\e010";
}
.glyphicon-th:before {
  content: "\e011";
}
.glyphicon-th-list:before {
  content: "\e012";
}
.glyphicon-ok:before {
  content: "\e013";
}
.glyphicon-remove:before {
  content: "\e014";
}
.glyphicon-zoom-in:before {
  content: "\e015";
}
.glyphicon-zoom-out:before {
  content: "\e016";
}
.glyphicon-off:before {
  content: "\e017";
}
.glyphicon-signal:before {
  content: "\e018";
}
.glyphicon-cog:before {
  content: "\e019";
}
.glyphicon-trash:before {
  content: "\e020";
}
.glyphicon-home:before {
  content: "\e021";
}
.glyphicon-file:before {
  content: "\e022";
}
.glyphicon-time:before {
  content: "\e023";
}
.glyphicon-road:before {
  content: "\e024";
}
.glyphicon-download-alt:before {
  content: "\e025";
}
.glyphicon-download:before {
  content: "\e026";
}
.glyphicon-upload:before {
  content: "\e027";
}
.glyphicon-inbox:before {
  content: "\e028";
}
.glyphicon-play-circle:before {
  content: "\e029";
}
.glyphicon-repeat:before {
  content: "\e030";
}
.glyphicon-refresh:before {
  content: "\e031";
}
.glyphicon-list-alt:before {
  content: "\e032";
}
.glyphicon-lock:before {
  content: "\e033";
}
.glyphicon-flag:before {
  content: "\e034";
}
.glyphicon-headphones:before {
  content: "\e035";
}
.glyphicon-volume-off:before {
  content: "\e036";
}
.glyphicon-volume-down:before {
  content: "\e037";
}
.glyphicon-volume-up:before {
  content: "\e038";
}
.glyphicon-qrcode:before {
  content: "\e039";
}
.glyphicon-barcode:before {
  content: "\e040";
}
.glyphicon-tag:before {
  content: "\e041";
}
.glyphicon-tags:before {
  content: "\e042";
}
.glyphicon-book:before {
  content: "\e043";
}
.glyphicon-bookmark:before {
  content: "\e044";
}
.glyphicon-print:before {
  content: "\e045";
}
.glyphicon-camera:before {
  content: "\e046";
}
.glyphicon-font:before {
  content: "\e047";
}
.glyphicon-bold:before {
  content: "\e048";
}
.glyphicon-italic:before {
  content: "\e049";
}
.glyphicon-text-height:before {
  content: "\e050";
}
.glyphicon-text-width:before {
  content: "\e051";
}
.glyphicon-align-left:before {
  content: "\e052";
}
.glyphicon-align-center:before {
  content: "\e053";
}
.glyphicon-align-right:before {
  content: "\e054";
}
.glyphicon-align-justify:before {
  content: "\e055";
}
.glyphicon-list:before {
  content: "\e056";
}
.glyphicon-indent-left:before {
  content: "\e057";
}
.glyphicon-indent-right:before {
  content: "\e058";
}
.glyphicon-facetime-video:before {
  content: "\e059";
}
.glyphicon-picture:before {
  content: "\e060";
}
.glyphicon-map-marker:before {
  content: "\e062";
}
.glyphicon-adjust:before {
  content: "\e063";
}
.glyphicon-tint:before {
  content: "\e064";
}
.glyphicon-edit:before {
  content: "\e065";
}
.glyphicon-share:before {
  content: "\e066";
}
.glyphicon-check:before {
  content: "\e067";
}
.glyphicon-move:before {
  content: "\e068";
}
.glyphicon-step-backward:before {
  content: "\e069";
}
.glyphicon-fast-backward:before {
  content: "\e070";
}
.glyphicon-backward:before {
  content: "\e071";
}
.glyphicon-play:before {
  content: "\e072";
}
.glyphicon-pause:before {
  content: "\e073";
}
.glyphicon-stop:before {
  content: "\e074";
}
.glyphicon-forward:before {
  content: "\e075";
}
.glyphicon-fast-forward:before {
  content: "\e076";
}
.glyphicon-step-forward:before {
  content: "\e077";
}
.glyphicon-eject:before {
  content: "\e078";
}
.glyphicon-chevron-left:before {
  content: "\e079";
}
.glyphicon-chevron-right:before {
  content: "\e080";
}
.glyphicon-plus-sign:before {
  content: "\e081";
}
.glyphicon-minus-sign:before {
  content: "\e082";
}
.glyphicon-remove-sign:before {
  content: "\e083";
}
.glyphicon-ok-sign:before {
  content: "\e084";
}
.glyphicon-question-sign:before {
  content: "\e085";
}
.glyphicon-info-sign:before {
  content: "\e086";
}
.glyphicon-screenshot:before {
  content: "\e087";
}
.glyphicon-remove-circle:before {
  content: "\e088";
}
.glyphicon-ok-circle:before {
  content: "\e089";
}
.glyphicon-ban-circle:before {
  content: "\e090";
}
.glyphicon-arrow-left:before {
  content: "\e091";
}
.glyphicon-arrow-right:before {
  content: "\e092";
}
.glyphicon-arrow-up:before {
  content: "\e093";
}
.glyphicon-arrow-down:before {
  content: "\e094";
}
.glyphicon-share-alt:before {
  content: "\e095";
}
.glyphicon-resize-full:before {
  content: "\e096";
}
.glyphicon-resize-small:before {
  content: "\e097";
}
.glyphicon-exclamation-sign:before {
  content: "\e101";
}
.glyphicon-gift:before {
  content: "\e102";
}
.glyphicon-leaf:before {
  content: "\e103";
}
.glyphicon-fire:before {
  content: "\e104";
}
.glyphicon-eye-open:before {
  content: "\e105";
}
.glyphicon-eye-close:before {
  content: "\e106";
}
.glyphicon-warning-sign:before {
  content: "\e107";
}
.glyphicon-plane:before {
  content: "\e108";
}
.glyphicon-calendar:before {
  content: "\e109";
}
.glyphicon-random:before {
  content: "\e110";
}
.glyphicon-comment:before {
  content: "\e111";
}
.glyphicon-magnet:before {
  content: "\e112";
}
.glyphicon-chevron-up:before {
  content: "\e113";
}
.glyphicon-chevron-down:before {
  content: "\e114";
}
.glyphicon-retweet:before {
  content: "\e115";
}
.glyphicon-shopping-cart:before {
  content: "\e116";
}
.glyphicon-folder-close:before {
  content: "\e117";
}
.glyphicon-folder-open:before {
  content: "\e118";
}
.glyphicon-resize-vertical:before {
  content: "\e119";
}
.glyphicon-resize-horizontal:before {
  content: "\e120";
}
.glyphicon-hdd:before {
  content: "\e121";
}
.glyphicon-bullhorn:before {
  content: "\e122";
}
.glyphicon-bell:before {
  content: "\e123";
}
.glyphicon-certificate:before {
  content: "\e124";
}
.glyphicon-thumbs-up:before {
  content: "\e125";
}
.glyphicon-thumbs-down:before {
  content: "\e126";
}
.glyphicon-hand-right:before {
  content: "\e127";
}
.glyphicon-hand-left:before {
  content: "\e128";
}
.glyphicon-hand-up:before {
  content: "\e129";
}
.glyphicon-hand-down:before {
  content: "\e130";
}
.glyphicon-circle-arrow-right:before {
  content: "\e131";
}
.glyphicon-circle-arrow-left:before {
  content: "\e132";
}
.glyphicon-circle-arrow-up:before {
  content: "\e133";
}
.glyphicon-circle-arrow-down:before {
  content: "\e134";
}
.glyphicon-globe:before {
  content: "\e135";
}
.glyphicon-wrench:before {
  content: "\e136";
}
.glyphicon-tasks:before {
  content: "\e137";
}
.glyphicon-filter:before {
  content: "\e138";
}
.glyphicon-briefcase:before {
  content: "\e139";
}
.glyphicon-fullscreen:before {
  content: "\e140";
}
.glyphicon-dashboard:before {
  content: "\e141";
}
.glyphicon-paperclip:before {
  content: "\e142";
}
.glyphicon-heart-empty:before {
  content: "\e143";
}
.glyphicon-link:before {
  content: "\e144";
}
.glyphicon-phone:before {
  content: "\e145";
}
.glyphicon-pushpin:before {
  content: "\e146";
}
.glyphicon-usd:before {
  content: "\e148";
}
.glyphicon-gbp:before {
  content: "\e149";
}
.glyphicon-sort:before {
  content: "\e150";
}
.glyphicon-sort-by-alphabet:before {
  content: "\e151";
}
.glyphicon-sort-by-alphabet-alt:before {
  content: "\e152";
}
.glyphicon-sort-by-order:before {
  content: "\e153";
}
.glyphicon-sort-by-order-alt:before {
  content: "\e154";
}
.glyphicon-sort-by-attributes:before {
  content: "\e155";
}
.glyphicon-sort-by-attributes-alt:before {
  content: "\e156";
}
.glyphicon-unchecked:before {
  content: "\e157";
}
.glyphicon-expand:before {
  content: "\e158";
}
.glyphicon-collapse-down:before {
  content: "\e159";
}
.glyphicon-collapse-up:before {
  content: "\e160";
}
.glyphicon-log-in:before {
  content: "\e161";
}
.glyphicon-flash:before {
  content: "\e162";
}
.glyphicon-log-out:before {
  content: "\e163";
}
.glyphicon-new-window:before {
  content: "\e164";
}
.glyphicon-record:before {
  content: "\e165";
}
.glyphicon-save:before {
  content: "\e166";
}
.glyphicon-open:before {
  content: "\e167";
}
.glyphicon-saved:before {
  content: "\e168";
}
.glyphicon-import:before {
  content: "\e169";
}
.glyphicon-export:before {
  content: "\e170";
}
.glyphicon-send:before {
  content: "\e171";
}
.glyphicon-floppy-disk:before {
  content: "\e172";
}
.glyphicon-floppy-saved:before {
  content: "\e173";
}
.glyphicon-floppy-remove:before {
  content: "\e174";
}
.glyphicon-floppy-save:before {
  content: "\e175";
}
.glyphicon-floppy-open:before {
  content: "\e176";
}
.glyphicon-credit-card:before {
  content: "\e177";
}
.glyphicon-transfer:before {
  content: "\e178";
}
.glyphicon-cutlery:before {
  content: "\e179";
}
.glyphicon-header:before {
  content: "\e180";
}
.glyphicon-compressed:before {
  content: "\e181";
}
.glyphicon-earphone:before {
  content: "\e182";
}
.glyphicon-phone-alt:before {
  content: "\e183";
}
.glyphicon-tower:before {
  content: "\e184";
}
.glyphicon-stats:before {
  content: "\e185";
}
.glyphicon-sd-video:before {
  content: "\e186";
}
.glyphicon-hd-video:before {
  content: "\e187";
}
.glyphicon-subtitles:before {
  content: "\e188";
}
.glyphicon-sound-stereo:before {
  content: "\e189";
}
.glyphicon-sound-dolby:before {
  content: "\e190";
}
.glyphicon-sound-5-1:before {
  content: "\e191";
}
.glyphicon-sound-6-1:before {
  content: "\e192";
}
.glyphicon-sound-7-1:before {
  content: "\e193";
}
.glyphicon-copyright-mark:before {
  content: "\e194";
}
.glyphicon-registration-mark:before {
  content: "\e195";
}
.glyphicon-cloud-download:before {
  content: "\e197";
}
.glyphicon-cloud-upload:before {
  content: "\e198";
}
.glyphicon-tree-conifer:before {
  content: "\e199";
}
.glyphicon-tree-deciduous:before {
  content: "\e200";
}
.glyphicon-cd:before {
  content: "\e201";
}
.glyphicon-save-file:before {
  content: "\e202";
}
.glyphicon-open-file:before {
  content: "\e203";
}
.glyphicon-level-up:before {
  content: "\e204";
}
.glyphicon-copy:before {
  content: "\e205";
}
.glyphicon-paste:before {
  content: "\e206";
}
.glyphicon-alert:before {
  content: "\e209";
}
.glyphicon-equalizer:before {
  content: "\e210";
}
.glyphicon-king:before {
  content: "\e211";
}
.glyphicon-queen:before {
  content: "\e212";
}
.glyphicon-pawn:before {
  content: "\e213";
}
.glyphicon-bishop:before {
  content: "\e214";
}
.glyphicon-knight:before {
  content: "\e215";
}
.glyphicon-baby-formula:before {
  content: "\e216";
}
.glyphicon-tent:before {
  content: "\26fa";
}
.glyphicon-blackboard:before {
  content: "\e218";
}
.glyphicon-bed:before {
  content: "\e219";
}
.glyphicon-apple:before {
  content: "\f8ff";
}
.glyphicon-erase:before {
  content: "\e221";
}
.glyphicon-hourglass:before {
  content: "\231b";
}
.glyphicon-lamp:before {
  content: "\e223";
}
.glyphicon-duplicate:before {
  content: "\e224";
}
.glyphicon-piggy-bank:before {
  content: "\e225";
}
.glyphicon-scissors:before {
  content: "\e226";
}
.glyphicon-bitcoin:before {
  content: "\e227";
}
.glyphicon-btc:before {
  content: "\e227";
}
.glyphicon-xbt:before {
  content: "\e227";
}
.glyphicon-yen:before {
  content: "\00a5";
}
.glyphicon-jpy:before {
  content: "\00a5";
}
.glyphicon-ruble:before {
  content: "\20bd";
}
.glyphicon-rub:before {
  content: "\20bd";
}
.glyphicon-scale:before {
  content: "\e230";
}
.glyphicon-ice-lolly:before {
  content: "\e231";
}
.glyphicon-ice-lolly-tasted:before {
  content: "\e232";
}
.glyphicon-education:before {
  content: "\e233";
}
.glyphicon-option-horizontal:before {
  content: "\e234";
}
.glyphicon-option-vertical:before {
  content: "\e235";
}
.glyphicon-menu-hamburger:before {
  content: "\e236";
}
.glyphicon-modal-window:before {
  content: "\e237";
}
.glyphicon-oil:before {
  content: "\e238";
}
.glyphicon-grain:before {
  content: "\e239";
}
.glyphicon-sunglasses:before {
  content: "\e240";
}
.glyphicon-text-size:before {
  content: "\e241";
}
.glyphicon-text-color:before {
  content: "\e242";
}
.glyphicon-text-background:before {
  content: "\e243";
}
.glyphicon-object-align-top:before {
  content: "\e244";
}
.glyphicon-object-align-bottom:before {
  content: "\e245";
}
.glyphicon-object-align-horizontal:before {
  content: "\e246";
}
.glyphicon-object-align-left:before {
  content: "\e247";
}
.glyphicon-object-align-vertical:before {
  content: "\e248";
}
.glyphicon-object-align-right:before {
  content: "\e249";
}
.glyphicon-triangle-right:before {
  content: "\e250";
}
.glyphicon-triangle-left:before {
  content: "\e251";
}
.glyphicon-triangle-bottom:before {
  content: "\e252";
}
.glyphicon-triangle-top:before {
  content: "\e253";
}
.glyphicon-console:before {
  content: "\e254";
}
.glyphicon-superscript:before {
  content: "\e255";
}
.glyphicon-subscript:before {
  content: "\e256";
}
.glyphicon-menu-left:before {
  content: "\e257";
}
.glyphicon-menu-right:before {
  content: "\e258";
}
.glyphicon-menu-down:before {
  content: "\e259";
}
.glyphicon-menu-up:before {
  content: "\e260";
}
* {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
*:before,
*:after {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
html {
  font-size: 10px;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 13px;
  line-height: 1.42857143;
  color: #000;
  background-color: #fff;
}
input,
button,
select,
textarea {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}
a {
  color: #337ab7;
  text-decoration: none;
}
a:hover,
a:focus {
  color: #23527c;
  text-decoration: underline;
}
a:focus {
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}
figure {
  margin: 0;
}
img {
  vertical-align: middle;
}
.img-responsive,
.thumbnail > img,
.thumbnail a > img,
.carousel-inner > .item > img,
.carousel-inner > .item > a > img {
  display: block;
  max-width: 100%;
  height: auto;
}
.img-rounded {
  border-radius: 3px;
}
.img-thumbnail {
  padding: 4px;
  line-height: 1.42857143;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 2px;
  -webkit-transition: all 0.2s ease-in-out;
  -o-transition: all 0.2s ease-in-out;
  transition: all 0.2s ease-in-out;
  display: inline-block;
  max-width: 100%;
  height: auto;
}
.img-circle {
  border-radius: 50%;
}
hr {
  margin-top: 18px;
  margin-bottom: 18px;
  border: 0;
  border-top: 1px solid #eeeeee;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}
.sr-only-focusable:active,
.sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  clip: auto;
}
[role="button"] {
  cursor: pointer;
}
h1,
h2,
h3,
h4,
h5,
h6,
.h1,
.h2,
.h3,
.h4,
.h5,
.h6 {
  font-family: inherit;
  font-weight: 500;
  line-height: 1.1;
  color: inherit;
}
h1 small,
h2 small,
h3 small,
h4 small,
h5 small,
h6 small,
.h1 small,
.h2 small,
.h3 small,
.h4 small,
.h5 small,
.h6 small,
h1 .small,
h2 .small,
h3 .small,
h4 .small,
h5 .small,
h6 .small,
.h1 .small,
.h2 .small,
.h3 .small,
.h4 .small,
.h5 .small,
.h6 .small {
  font-weight: normal;
  line-height: 1;
  color: #777777;
}
h1,
.h1,
h2,
.h2,
h3,
.h3 {
  margin-top: 18px;
  margin-bottom: 9px;
}
h1 small,
.h1 small,
h2 small,
.h2 small,
h3 small,
.h3 small,
h1 .small,
.h1 .small,
h2 .small,
.h2 .small,
h3 .small,
.h3 .small {
  font-size: 65%;
}
h4,
.h4,
h5,
.h5,
h6,
.h6 {
  margin-top: 9px;
  margin-bottom: 9px;
}
h4 small,
.h4 small,
h5 small,
.h5 small,
h6 small,
.h6 small,
h4 .small,
.h4 .small,
h5 .small,
.h5 .small,
h6 .small,
.h6 .small {
  font-size: 75%;
}
h1,
.h1 {
  font-size: 33px;
}
h2,
.h2 {
  font-size: 27px;
}
h3,
.h3 {
  font-size: 23px;
}
h4,
.h4 {
  font-size: 17px;
}
h5,
.h5 {
  font-size: 13px;
}
h6,
.h6 {
  font-size: 12px;
}
p {
  margin: 0 0 9px;
}
.lead {
  margin-bottom: 18px;
  font-size: 14px;
  font-weight: 300;
  line-height: 1.4;
}
@media (min-width: 768px) {
  .lead {
    font-size: 19.5px;
  }
}
small,
.small {
  font-size: 92%;
}
mark,
.mark {
  background-color: #fcf8e3;
  padding: .2em;
}
.text-left {
  text-align: left;
}
.text-right {
  text-align: right;
}
.text-center {
  text-align: center;
}
.text-justify {
  text-align: justify;
}
.text-nowrap {
  white-space: nowrap;
}
.text-lowercase {
  text-transform: lowercase;
}
.text-uppercase {
  text-transform: uppercase;
}
.text-capitalize {
  text-transform: capitalize;
}
.text-muted {
  color: #777777;
}
.text-primary {
  color: #337ab7;
}
a.text-primary:hover,
a.text-primary:focus {
  color: #286090;
}
.text-success {
  color: #3c763d;
}
a.text-success:hover,
a.text-success:focus {
  color: #2b542c;
}
.text-info {
  color: #31708f;
}
a.text-info:hover,
a.text-info:focus {
  color: #245269;
}
.text-warning {
  color: #8a6d3b;
}
a.text-warning:hover,
a.text-warning:focus {
  color: #66512c;
}
.text-danger {
  color: #a94442;
}
a.text-danger:hover,
a.text-danger:focus {
  color: #843534;
}
.bg-primary {
  color: #fff;
  background-color: #337ab7;
}
a.bg-primary:hover,
a.bg-primary:focus {
  background-color: #286090;
}
.bg-success {
  background-color: #dff0d8;
}
a.bg-success:hover,
a.bg-success:focus {
  background-color: #c1e2b3;
}
.bg-info {
  background-color: #d9edf7;
}
a.bg-info:hover,
a.bg-info:focus {
  background-color: #afd9ee;
}
.bg-warning {
  background-color: #fcf8e3;
}
a.bg-warning:hover,
a.bg-warning:focus {
  background-color: #f7ecb5;
}
.bg-danger {
  background-color: #f2dede;
}
a.bg-danger:hover,
a.bg-danger:focus {
  background-color: #e4b9b9;
}
.page-header {
  padding-bottom: 8px;
  margin: 36px 0 18px;
  border-bottom: 1px solid #eeeeee;
}
ul,
ol {
  margin-top: 0;
  margin-bottom: 9px;
}
ul ul,
ol ul,
ul ol,
ol ol {
  margin-bottom: 0;
}
.list-unstyled {
  padding-left: 0;
  list-style: none;
}
.list-inline {
  padding-left: 0;
  list-style: none;
  margin-left: -5px;
}
.list-inline > li {
  display: inline-block;
  padding-left: 5px;
  padding-right: 5px;
}
dl {
  margin-top: 0;
  margin-bottom: 18px;
}
dt,
dd {
  line-height: 1.42857143;
}
dt {
  font-weight: bold;
}
dd {
  margin-left: 0;
}
@media (min-width: 541px) {
  .dl-horizontal dt {
    float: left;
    width: 160px;
    clear: left;
    text-align: right;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .dl-horizontal dd {
    margin-left: 180px;
  }
}
abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #777777;
}
.initialism {
  font-size: 90%;
  text-transform: uppercase;
}
blockquote {
  padding: 9px 18px;
  margin: 0 0 18px;
  font-size: inherit;
  border-left: 5px solid #eeeeee;
}
blockquote p:last-child,
blockquote ul:last-child,
blockquote ol:last-child {
  margin-bottom: 0;
}
blockquote footer,
blockquote small,
blockquote .small {
  display: block;
  font-size: 80%;
  line-height: 1.42857143;
  color: #777777;
}
blockquote footer:before,
blockquote small:before,
blockquote .small:before {
  content: '\2014 \00A0';
}
.blockquote-reverse,
blockquote.pull-right {
  padding-right: 15px;
  padding-left: 0;
  border-right: 5px solid #eeeeee;
  border-left: 0;
  text-align: right;
}
.blockquote-reverse footer:before,
blockquote.pull-right footer:before,
.blockquote-reverse small:before,
blockquote.pull-right small:before,
.blockquote-reverse .small:before,
blockquote.pull-right .small:before {
  content: '';
}
.blockquote-reverse footer:after,
blockquote.pull-right footer:after,
.blockquote-reverse small:after,
blockquote.pull-right small:after,
.blockquote-reverse .small:after,
blockquote.pull-right .small:after {
  content: '\00A0 \2014';
}
address {
  margin-bottom: 18px;
  font-style: normal;
  line-height: 1.42857143;
}
code,
kbd,
pre,
samp {
  font-family: monospace;
}
code {
  padding: 2px 4px;
  font-size: 90%;
  color: #c7254e;
  background-color: #f9f2f4;
  border-radius: 2px;
}
kbd {
  padding: 2px 4px;
  font-size: 90%;
  color: #888;
  background-color: transparent;
  border-radius: 1px;
  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.25);
}
kbd kbd {
  padding: 0;
  font-size: 100%;
  font-weight: bold;
  box-shadow: none;
}
pre {
  display: block;
  padding: 8.5px;
  margin: 0 0 9px;
  font-size: 12px;
  line-height: 1.42857143;
  word-break: break-all;
  word-wrap: break-word;
  color: #333333;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 2px;
}
pre code {
  padding: 0;
  font-size: inherit;
  color: inherit;
  white-space: pre-wrap;
  background-color: transparent;
  border-radius: 0;
}
.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll;
}
.container {
  margin-right: auto;
  margin-left: auto;
  padding-left: 0px;
  padding-right: 0px;
}
@media (min-width: 768px) {
  .container {
    width: 768px;
  }
}
@media (min-width: 992px) {
  .container {
    width: 940px;
  }
}
@media (min-width: 1200px) {
  .container {
    width: 1140px;
  }
}
.container-fluid {
  margin-right: auto;
  margin-left: auto;
  padding-left: 0px;
  padding-right: 0px;
}
.row {
  margin-left: 0px;
  margin-right: 0px;
}
.col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12 {
  position: relative;
  min-height: 1px;
  padding-left: 0px;
  padding-right: 0px;
}
.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 {
  float: left;
}
.col-xs-12 {
  width: 100%;
}
.col-xs-11 {
  width: 91.66666667%;
}
.col-xs-10 {
  width: 83.33333333%;
}
.col-xs-9 {
  width: 75%;
}
.col-xs-8 {
  width: 66.66666667%;
}
.col-xs-7 {
  width: 58.33333333%;
}
.col-xs-6 {
  width: 50%;
}
.col-xs-5 {
  width: 41.66666667%;
}
.col-xs-4 {
  width: 33.33333333%;
}
.col-xs-3 {
  width: 25%;
}
.col-xs-2 {
  width: 16.66666667%;
}
.col-xs-1 {
  width: 8.33333333%;
}
.col-xs-pull-12 {
  right: 100%;
}
.col-xs-pull-11 {
  right: 91.66666667%;
}
.col-xs-pull-10 {
  right: 83.33333333%;
}
.col-xs-pull-9 {
  right: 75%;
}
.col-xs-pull-8 {
  right: 66.66666667%;
}
.col-xs-pull-7 {
  right: 58.33333333%;
}
.col-xs-pull-6 {
  right: 50%;
}
.col-xs-pull-5 {
  right: 41.66666667%;
}
.col-xs-pull-4 {
  right: 33.33333333%;
}
.col-xs-pull-3 {
  right: 25%;
}
.col-xs-pull-2 {
  right: 16.66666667%;
}
.col-xs-pull-1 {
  right: 8.33333333%;
}
.col-xs-pull-0 {
  right: auto;
}
.col-xs-push-12 {
  left: 100%;
}
.col-xs-push-11 {
  left: 91.66666667%;
}
.col-xs-push-10 {
  left: 83.33333333%;
}
.col-xs-push-9 {
  left: 75%;
}
.col-xs-push-8 {
  left: 66.66666667%;
}
.col-xs-push-7 {
  left: 58.33333333%;
}
.col-xs-push-6 {
  left: 50%;
}
.col-xs-push-5 {
  left: 41.66666667%;
}
.col-xs-push-4 {
  left: 33.33333333%;
}
.col-xs-push-3 {
  left: 25%;
}
.col-xs-push-2 {
  left: 16.66666667%;
}
.col-xs-push-1 {
  left: 8.33333333%;
}
.col-xs-push-0 {
  left: auto;
}
.col-xs-offset-12 {
  margin-left: 100%;
}
.col-xs-offset-11 {
  margin-left: 91.66666667%;
}
.col-xs-offset-10 {
  margin-left: 83.33333333%;
}
.col-xs-offset-9 {
  margin-left: 75%;
}
.col-xs-offset-8 {
  margin-left: 66.66666667%;
}
.col-xs-offset-7 {
  margin-left: 58.33333333%;
}
.col-xs-offset-6 {
  margin-left: 50%;
}
.col-xs-offset-5 {
  margin-left: 41.66666667%;
}
.col-xs-offset-4 {
  margin-left: 33.33333333%;
}
.col-xs-offset-3 {
  margin-left: 25%;
}
.col-xs-offset-2 {
  margin-left: 16.66666667%;
}
.col-xs-offset-1 {
  margin-left: 8.33333333%;
}
.col-xs-offset-0 {
  margin-left: 0%;
}
@media (min-width: 768px) {
  .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12 {
    float: left;
  }
  .col-sm-12 {
    width: 100%;
  }
  .col-sm-11 {
    width: 91.66666667%;
  }
  .col-sm-10 {
    width: 83.33333333%;
  }
  .col-sm-9 {
    width: 75%;
  }
  .col-sm-8 {
    width: 66.66666667%;
  }
  .col-sm-7 {
    width: 58.33333333%;
  }
  .col-sm-6 {
    width: 50%;
  }
  .col-sm-5 {
    width: 41.66666667%;
  }
  .col-sm-4 {
    width: 33.33333333%;
  }
  .col-sm-3 {
    width: 25%;
  }
  .col-sm-2 {
    width: 16.66666667%;
  }
  .col-sm-1 {
    width: 8.33333333%;
  }
  .col-sm-pull-12 {
    right: 100%;
  }
  .col-sm-pull-11 {
    right: 91.66666667%;
  }
  .col-sm-pull-10 {
    right: 83.33333333%;
  }
  .col-sm-pull-9 {
    right: 75%;
  }
  .col-sm-pull-8 {
    right: 66.66666667%;
  }
  .col-sm-pull-7 {
    right: 58.33333333%;
  }
  .col-sm-pull-6 {
    right: 50%;
  }
  .col-sm-pull-5 {
    right: 41.66666667%;
  }
  .col-sm-pull-4 {
    right: 33.33333333%;
  }
  .col-sm-pull-3 {
    right: 25%;
  }
  .col-sm-pull-2 {
    right: 16.66666667%;
  }
  .col-sm-pull-1 {
    right: 8.33333333%;
  }
  .col-sm-pull-0 {
    right: auto;
  }
  .col-sm-push-12 {
    left: 100%;
  }
  .col-sm-push-11 {
    left: 91.66666667%;
  }
  .col-sm-push-10 {
    left: 83.33333333%;
  }
  .col-sm-push-9 {
    left: 75%;
  }
  .col-sm-push-8 {
    left: 66.66666667%;
  }
  .col-sm-push-7 {
    left: 58.33333333%;
  }
  .col-sm-push-6 {
    left: 50%;
  }
  .col-sm-push-5 {
    left: 41.66666667%;
  }
  .col-sm-push-4 {
    left: 33.33333333%;
  }
  .col-sm-push-3 {
    left: 25%;
  }
  .col-sm-push-2 {
    left: 16.66666667%;
  }
  .col-sm-push-1 {
    left: 8.33333333%;
  }
  .col-sm-push-0 {
    left: auto;
  }
  .col-sm-offset-12 {
    margin-left: 100%;
  }
  .col-sm-offset-11 {
    margin-left: 91.66666667%;
  }
  .col-sm-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-sm-offset-9 {
    margin-left: 75%;
  }
  .col-sm-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-sm-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-sm-offset-6 {
    margin-left: 50%;
  }
  .col-sm-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-sm-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-sm-offset-3 {
    margin-left: 25%;
  }
  .col-sm-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-sm-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-sm-offset-0 {
    margin-left: 0%;
  }
}
@media (min-width: 992px) {
  .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12 {
    float: left;
  }
  .col-md-12 {
    width: 100%;
  }
  .col-md-11 {
    width: 91.66666667%;
  }
  .col-md-10 {
    width: 83.33333333%;
  }
  .col-md-9 {
    width: 75%;
  }
  .col-md-8 {
    width: 66.66666667%;
  }
  .col-md-7 {
    width: 58.33333333%;
  }
  .col-md-6 {
    width: 50%;
  }
  .col-md-5 {
    width: 41.66666667%;
  }
  .col-md-4 {
    width: 33.33333333%;
  }
  .col-md-3 {
    width: 25%;
  }
  .col-md-2 {
    width: 16.66666667%;
  }
  .col-md-1 {
    width: 8.33333333%;
  }
  .col-md-pull-12 {
    right: 100%;
  }
  .col-md-pull-11 {
    right: 91.66666667%;
  }
  .col-md-pull-10 {
    right: 83.33333333%;
  }
  .col-md-pull-9 {
    right: 75%;
  }
  .col-md-pull-8 {
    right: 66.66666667%;
  }
  .col-md-pull-7 {
    right: 58.33333333%;
  }
  .col-md-pull-6 {
    right: 50%;
  }
  .col-md-pull-5 {
    right: 41.66666667%;
  }
  .col-md-pull-4 {
    right: 33.33333333%;
  }
  .col-md-pull-3 {
    right: 25%;
  }
  .col-md-pull-2 {
    right: 16.66666667%;
  }
  .col-md-pull-1 {
    right: 8.33333333%;
  }
  .col-md-pull-0 {
    right: auto;
  }
  .col-md-push-12 {
    left: 100%;
  }
  .col-md-push-11 {
    left: 91.66666667%;
  }
  .col-md-push-10 {
    left: 83.33333333%;
  }
  .col-md-push-9 {
    left: 75%;
  }
  .col-md-push-8 {
    left: 66.66666667%;
  }
  .col-md-push-7 {
    left: 58.33333333%;
  }
  .col-md-push-6 {
    left: 50%;
  }
  .col-md-push-5 {
    left: 41.66666667%;
  }
  .col-md-push-4 {
    left: 33.33333333%;
  }
  .col-md-push-3 {
    left: 25%;
  }
  .col-md-push-2 {
    left: 16.66666667%;
  }
  .col-md-push-1 {
    left: 8.33333333%;
  }
  .col-md-push-0 {
    left: auto;
  }
  .col-md-offset-12 {
    margin-left: 100%;
  }
  .col-md-offset-11 {
    margin-left: 91.66666667%;
  }
  .col-md-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-md-offset-9 {
    margin-left: 75%;
  }
  .col-md-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-md-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-md-offset-6 {
    margin-left: 50%;
  }
  .col-md-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-md-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-md-offset-3 {
    margin-left: 25%;
  }
  .col-md-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-md-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-md-offset-0 {
    margin-left: 0%;
  }
}
@media (min-width: 1200px) {
  .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 {
    float: left;
  }
  .col-lg-12 {
    width: 100%;
  }
  .col-lg-11 {
    width: 91.66666667%;
  }
  .col-lg-10 {
    width: 83.33333333%;
  }
  .col-lg-9 {
    width: 75%;
  }
  .col-lg-8 {
    width: 66.66666667%;
  }
  .col-lg-7 {
    width: 58.33333333%;
  }
  .col-lg-6 {
    width: 50%;
  }
  .col-lg-5 {
    width: 41.66666667%;
  }
  .col-lg-4 {
    width: 33.33333333%;
  }
  .col-lg-3 {
    width: 25%;
  }
  .col-lg-2 {
    width: 16.66666667%;
  }
  .col-lg-1 {
    width: 8.33333333%;
  }
  .col-lg-pull-12 {
    right: 100%;
  }
  .col-lg-pull-11 {
    right: 91.66666667%;
  }
  .col-lg-pull-10 {
    right: 83.33333333%;
  }
  .col-lg-pull-9 {
    right: 75%;
  }
  .col-lg-pull-8 {
    right: 66.66666667%;
  }
  .col-lg-pull-7 {
    right: 58.33333333%;
  }
  .col-lg-pull-6 {
    right: 50%;
  }
  .col-lg-pull-5 {
    right: 41.66666667%;
  }
  .col-lg-pull-4 {
    right: 33.33333333%;
  }
  .col-lg-pull-3 {
    right: 25%;
  }
  .col-lg-pull-2 {
    right: 16.66666667%;
  }
  .col-lg-pull-1 {
    right: 8.33333333%;
  }
  .col-lg-pull-0 {
    right: auto;
  }
  .col-lg-push-12 {
    left: 100%;
  }
  .col-lg-push-11 {
    left: 91.66666667%;
  }
  .col-lg-push-10 {
    left: 83.33333333%;
  }
  .col-lg-push-9 {
    left: 75%;
  }
  .col-lg-push-8 {
    left: 66.66666667%;
  }
  .col-lg-push-7 {
    left: 58.33333333%;
  }
  .col-lg-push-6 {
    left: 50%;
  }
  .col-lg-push-5 {
    left: 41.66666667%;
  }
  .col-lg-push-4 {
    left: 33.33333333%;
  }
  .col-lg-push-3 {
    left: 25%;
  }
  .col-lg-push-2 {
    left: 16.66666667%;
  }
  .col-lg-push-1 {
    left: 8.33333333%;
  }
  .col-lg-push-0 {
    left: auto;
  }
  .col-lg-offset-12 {
    margin-left: 100%;
  }
  .col-lg-offset-11 {
    margin-left: 91.66666667%;
  }
  .col-lg-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-lg-offset-9 {
    margin-left: 75%;
  }
  .col-lg-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-lg-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-lg-offset-6 {
    margin-left: 50%;
  }
  .col-lg-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-lg-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-lg-offset-3 {
    margin-left: 25%;
  }
  .col-lg-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-lg-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-lg-offset-0 {
    margin-left: 0%;
  }
}
table {
  background-color: transparent;
}
caption {
  padding-top: 8px;
  padding-bottom: 8px;
  color: #777777;
  text-align: left;
}
th {
  text-align: left;
}
.table {
  width: 100%;
  max-width: 100%;
  margin-bottom: 18px;
}
.table > thead > tr > th,
.table > tbody > tr > th,
.table > tfoot > tr > th,
.table > thead > tr > td,
.table > tbody > tr > td,
.table > tfoot > tr > td {
  padding: 8px;
  line-height: 1.42857143;
  vertical-align: top;
  border-top: 1px solid #ddd;
}
.table > thead > tr > th {
  vertical-align: bottom;
  border-bottom: 2px solid #ddd;
}
.table > caption + thead > tr:first-child > th,
.table > colgroup + thead > tr:first-child > th,
.table > thead:first-child > tr:first-child > th,
.table > caption + thead > tr:first-child > td,
.table > colgroup + thead > tr:first-child > td,
.table > thead:first-child > tr:first-child > td {
  border-top: 0;
}
.table > tbody + tbody {
  border-top: 2px solid #ddd;
}
.table .table {
  background-color: #fff;
}
.table-condensed > thead > tr > th,
.table-condensed > tbody > tr > th,
.table-condensed > tfoot > tr > th,
.table-condensed > thead > tr > td,
.table-condensed > tbody > tr > td,
.table-condensed > tfoot > tr > td {
  padding: 5px;
}
.table-bordered {
  border: 1px solid #ddd;
}
.table-bordered > thead > tr > th,
.table-bordered > tbody > tr > th,
.table-bordered > tfoot > tr > th,
.table-bordered > thead > tr > td,
.table-bordered > tbody > tr > td,
.table-bordered > tfoot > tr > td {
  border: 1px solid #ddd;
}
.table-bordered > thead > tr > th,
.table-bordered > thead > tr > td {
  border-bottom-width: 2px;
}
.table-striped > tbody > tr:nth-of-type(odd) {
  background-color: #f9f9f9;
}
.table-hover > tbody > tr:hover {
  background-color: #f5f5f5;
}
table col[class*="col-"] {
  position: static;
  float: none;
  display: table-column;
}
table td[class*="col-"],
table th[class*="col-"] {
  position: static;
  float: none;
  display: table-cell;
}
.table > thead > tr > td.active,
.table > tbody > tr > td.active,
.table > tfoot > tr > td.active,
.table > thead > tr > th.active,
.table > tbody > tr > th.active,
.table > tfoot > tr > th.active,
.table > thead > tr.active > td,
.table > tbody > tr.active > td,
.table > tfoot > tr.active > td,
.table > thead > tr.active > th,
.table > tbody > tr.active > th,
.table > tfoot > tr.active > th {
  background-color: #f5f5f5;
}
.table-hover > tbody > tr > td.active:hover,
.table-hover > tbody > tr > th.active:hover,
.table-hover > tbody > tr.active:hover > td,
.table-hover > tbody > tr:hover > .active,
.table-hover > tbody > tr.active:hover > th {
  background-color: #e8e8e8;
}
.table > thead > tr > td.success,
.table > tbody > tr > td.success,
.table > tfoot > tr > td.success,
.table > thead > tr > th.success,
.table > tbody > tr > th.success,
.table > tfoot > tr > th.success,
.table > thead > tr.success > td,
.table > tbody > tr.success > td,
.table > tfoot > tr.success > td,
.table > thead > tr.success > th,
.table > tbody > tr.success > th,
.table > tfoot > tr.success > th {
  background-color: #dff0d8;
}
.table-hover > tbody > tr > td.success:hover,
.table-hover > tbody > tr > th.success:hover,
.table-hover > tbody > tr.success:hover > td,
.table-hover > tbody > tr:hover > .success,
.table-hover > tbody > tr.success:hover > th {
  background-color: #d0e9c6;
}
.table > thead > tr > td.info,
.table > tbody > tr > td.info,
.table > tfoot > tr > td.info,
.table > thead > tr > th.info,
.table > tbody > tr > th.info,
.table > tfoot > tr > th.info,
.table > thead > tr.info > td,
.table > tbody > tr.info > td,
.table > tfoot > tr.info > td,
.table > thead > tr.info > th,
.table > tbody > tr.info > th,
.table > tfoot > tr.info > th {
  background-color: #d9edf7;
}
.table-hover > tbody > tr > td.info:hover,
.table-hover > tbody > tr > th.info:hover,
.table-hover > tbody > tr.info:hover > td,
.table-hover > tbody > tr:hover > .info,
.table-hover > tbody > tr.info:hover > th {
  background-color: #c4e3f3;
}
.table > thead > tr > td.warning,
.table > tbody > tr > td.warning,
.table > tfoot > tr > td.warning,
.table > thead > tr > th.warning,
.table > tbody > tr > th.warning,
.table > tfoot > tr > th.warning,
.table > thead > tr.warning > td,
.table > tbody > tr.warning > td,
.table > tfoot > tr.warning > td,
.table > thead > tr.warning > th,
.table > tbody > tr.warning > th,
.table > tfoot > tr.warning > th {
  background-color: #fcf8e3;
}
.table-hover > tbody > tr > td.warning:hover,
.table-hover > tbody > tr > th.warning:hover,
.table-hover > tbody > tr.warning:hover > td,
.table-hover > tbody > tr:hover > .warning,
.table-hover > tbody > tr.warning:hover > th {
  background-color: #faf2cc;
}
.table > thead > tr > td.danger,
.table > tbody > tr > td.danger,
.table > tfoot > tr > td.danger,
.table > thead > tr > th.danger,
.table > tbody > tr > th.danger,
.table > tfoot > tr > th.danger,
.table > thead > tr.danger > td,
.table > tbody > tr.danger > td,
.table > tfoot > tr.danger > td,
.table > thead > tr.danger > th,
.table > tbody > tr.danger > th,
.table > tfoot > tr.danger > th {
  background-color: #f2dede;
}
.table-hover > tbody > tr > td.danger:hover,
.table-hover > tbody > tr > th.danger:hover,
.table-hover > tbody > tr.danger:hover > td,
.table-hover > tbody > tr:hover > .danger,
.table-hover > tbody > tr.danger:hover > th {
  background-color: #ebcccc;
}
.table-responsive {
  overflow-x: auto;
  min-height: 0.01%;
}
@media screen and (max-width: 767px) {
  .table-responsive {
    width: 100%;
    margin-bottom: 13.5px;
    overflow-y: hidden;
    -ms-overflow-style: -ms-autohiding-scrollbar;
    border: 1px solid #ddd;
  }
  .table-responsive > .table {
    margin-bottom: 0;
  }
  .table-responsive > .table > thead > tr > th,
  .table-responsive > .table > tbody > tr > th,
  .table-responsive > .table > tfoot > tr > th,
  .table-responsive > .table > thead > tr > td,
  .table-responsive > .table > tbody > tr > td,
  .table-responsive > .table > tfoot > tr > td {
    white-space: nowrap;
  }
  .table-responsive > .table-bordered {
    border: 0;
  }
  .table-responsive > .table-bordered > thead > tr > th:first-child,
  .table-responsive > .table-bordered > tbody > tr > th:first-child,
  .table-responsive > .table-bordered > tfoot > tr > th:first-child,
  .table-responsive > .table-bordered > thead > tr > td:first-child,
  .table-responsive > .table-bordered > tbody > tr > td:first-child,
  .table-responsive > .table-bordered > tfoot > tr > td:first-child {
    border-left: 0;
  }
  .table-responsive > .table-bordered > thead > tr > th:last-child,
  .table-responsive > .table-bordered > tbody > tr > th:last-child,
  .table-responsive > .table-bordered > tfoot > tr > th:last-child,
  .table-responsive > .table-bordered > thead > tr > td:last-child,
  .table-responsive > .table-bordered > tbody > tr > td:last-child,
  .table-responsive > .table-bordered > tfoot > tr > td:last-child {
    border-right: 0;
  }
  .table-responsive > .table-bordered > tbody > tr:last-child > th,
  .table-responsive > .table-bordered > tfoot > tr:last-child > th,
  .table-responsive > .table-bordered > tbody > tr:last-child > td,
  .table-responsive > .table-bordered > tfoot > tr:last-child > td {
    border-bottom: 0;
  }
}
fieldset {
  padding: 0;
  margin: 0;
  border: 0;
  min-width: 0;
}
legend {
  display: block;
  width: 100%;
  padding: 0;
  margin-bottom: 18px;
  font-size: 19.5px;
  line-height: inherit;
  color: #333333;
  border: 0;
  border-bottom: 1px solid #e5e5e5;
}
label {
  display: inline-block;
  max-width: 100%;
  margin-bottom: 5px;
  font-weight: bold;
}
input[type="search"] {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
input[type="radio"],
input[type="checkbox"] {
  margin: 4px 0 0;
  margin-top: 1px \9;
  line-height: normal;
}
input[type="file"] {
  display: block;
}
input[type="range"] {
  display: block;
  width: 100%;
}
select[multiple],
select[size] {
  height: auto;
}
input[type="file"]:focus,
input[type="radio"]:focus,
input[type="checkbox"]:focus {
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}
output {
  display: block;
  padding-top: 7px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #555555;
}
.form-control {
  display: block;
  width: 100%;
  height: 32px;
  padding: 6px 12px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #555555;
  background-color: #fff;
  background-image: none;
  border: 1px solid #ccc;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
}
.form-control:focus {
  border-color: #66afe9;
  outline: 0;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
}
.form-control::-moz-placeholder {
  color: #999;
  opacity: 1;
}
.form-control:-ms-input-placeholder {
  color: #999;
}
.form-control::-webkit-input-placeholder {
  color: #999;
}
.form-control::-ms-expand {
  border: 0;
  background-color: transparent;
}
.form-control[disabled],
.form-control[readonly],
fieldset[disabled] .form-control {
  background-color: #eeeeee;
  opacity: 1;
}
.form-control[disabled],
fieldset[disabled] .form-control {
  cursor: not-allowed;
}
textarea.form-control {
  height: auto;
}
input[type="search"] {
  -webkit-appearance: none;
}
@media screen and (-webkit-min-device-pixel-ratio: 0) {
  input[type="date"].form-control,
  input[type="time"].form-control,
  input[type="datetime-local"].form-control,
  input[type="month"].form-control {
    line-height: 32px;
  }
  input[type="date"].input-sm,
  input[type="time"].input-sm,
  input[type="datetime-local"].input-sm,
  input[type="month"].input-sm,
  .input-group-sm input[type="date"],
  .input-group-sm input[type="time"],
  .input-group-sm input[type="datetime-local"],
  .input-group-sm input[type="month"] {
    line-height: 30px;
  }
  input[type="date"].input-lg,
  input[type="time"].input-lg,
  input[type="datetime-local"].input-lg,
  input[type="month"].input-lg,
  .input-group-lg input[type="date"],
  .input-group-lg input[type="time"],
  .input-group-lg input[type="datetime-local"],
  .input-group-lg input[type="month"] {
    line-height: 45px;
  }
}
.form-group {
  margin-bottom: 15px;
}
.radio,
.checkbox {
  position: relative;
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
.radio label,
.checkbox label {
  min-height: 18px;
  padding-left: 20px;
  margin-bottom: 0;
  font-weight: normal;
  cursor: pointer;
}
.radio input[type="radio"],
.radio-inline input[type="radio"],
.checkbox input[type="checkbox"],
.checkbox-inline input[type="checkbox"] {
  position: absolute;
  margin-left: -20px;
  margin-top: 4px \9;
}
.radio + .radio,
.checkbox + .checkbox {
  margin-top: -5px;
}
.radio-inline,
.checkbox-inline {
  position: relative;
  display: inline-block;
  padding-left: 20px;
  margin-bottom: 0;
  vertical-align: middle;
  font-weight: normal;
  cursor: pointer;
}
.radio-inline + .radio-inline,
.checkbox-inline + .checkbox-inline {
  margin-top: 0;
  margin-left: 10px;
}
input[type="radio"][disabled],
input[type="checkbox"][disabled],
input[type="radio"].disabled,
input[type="checkbox"].disabled,
fieldset[disabled] input[type="radio"],
fieldset[disabled] input[type="checkbox"] {
  cursor: not-allowed;
}
.radio-inline.disabled,
.checkbox-inline.disabled,
fieldset[disabled] .radio-inline,
fieldset[disabled] .checkbox-inline {
  cursor: not-allowed;
}
.radio.disabled label,
.checkbox.disabled label,
fieldset[disabled] .radio label,
fieldset[disabled] .checkbox label {
  cursor: not-allowed;
}
.form-control-static {
  padding-top: 7px;
  padding-bottom: 7px;
  margin-bottom: 0;
  min-height: 31px;
}
.form-control-static.input-lg,
.form-control-static.input-sm {
  padding-left: 0;
  padding-right: 0;
}
.input-sm {
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
select.input-sm {
  height: 30px;
  line-height: 30px;
}
textarea.input-sm,
select[multiple].input-sm {
  height: auto;
}
.form-group-sm .form-control {
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
.form-group-sm select.form-control {
  height: 30px;
  line-height: 30px;
}
.form-group-sm textarea.form-control,
.form-group-sm select[multiple].form-control {
  height: auto;
}
.form-group-sm .form-control-static {
  height: 30px;
  min-height: 30px;
  padding: 6px 10px;
  font-size: 12px;
  line-height: 1.5;
}
.input-lg {
  height: 45px;
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
  border-radius: 3px;
}
select.input-lg {
  height: 45px;
  line-height: 45px;
}
textarea.input-lg,
select[multiple].input-lg {
  height: auto;
}
.form-group-lg .form-control {
  height: 45px;
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
  border-radius: 3px;
}
.form-group-lg select.form-control {
  height: 45px;
  line-height: 45px;
}
.form-group-lg textarea.form-control,
.form-group-lg select[multiple].form-control {
  height: auto;
}
.form-group-lg .form-control-static {
  height: 45px;
  min-height: 35px;
  padding: 11px 16px;
  font-size: 17px;
  line-height: 1.3333333;
}
.has-feedback {
  position: relative;
}
.has-feedback .form-control {
  padding-right: 40px;
}
.form-control-feedback {
  position: absolute;
  top: 0;
  right: 0;
  z-index: 2;
  display: block;
  width: 32px;
  height: 32px;
  line-height: 32px;
  text-align: center;
  pointer-events: none;
}
.input-lg + .form-control-feedback,
.input-group-lg + .form-control-feedback,
.form-group-lg .form-control + .form-control-feedback {
  width: 45px;
  height: 45px;
  line-height: 45px;
}
.input-sm + .form-control-feedback,
.input-group-sm + .form-control-feedback,
.form-group-sm .form-control + .form-control-feedback {
  width: 30px;
  height: 30px;
  line-height: 30px;
}
.has-success .help-block,
.has-success .control-label,
.has-success .radio,
.has-success .checkbox,
.has-success .radio-inline,
.has-success .checkbox-inline,
.has-success.radio label,
.has-success.checkbox label,
.has-success.radio-inline label,
.has-success.checkbox-inline label {
  color: #3c763d;
}
.has-success .form-control {
  border-color: #3c763d;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
}
.has-success .form-control:focus {
  border-color: #2b542c;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #67b168;
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #67b168;
}
.has-success .input-group-addon {
  color: #3c763d;
  border-color: #3c763d;
  background-color: #dff0d8;
}
.has-success .form-control-feedback {
  color: #3c763d;
}
.has-warning .help-block,
.has-warning .control-label,
.has-warning .radio,
.has-warning .checkbox,
.has-warning .radio-inline,
.has-warning .checkbox-inline,
.has-warning.radio label,
.has-warning.checkbox label,
.has-warning.radio-inline label,
.has-warning.checkbox-inline label {
  color: #8a6d3b;
}
.has-warning .form-control {
  border-color: #8a6d3b;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
}
.has-warning .form-control:focus {
  border-color: #66512c;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #c0a16b;
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #c0a16b;
}
.has-warning .input-group-addon {
  color: #8a6d3b;
  border-color: #8a6d3b;
  background-color: #fcf8e3;
}
.has-warning .form-control-feedback {
  color: #8a6d3b;
}
.has-error .help-block,
.has-error .control-label,
.has-error .radio,
.has-error .checkbox,
.has-error .radio-inline,
.has-error .checkbox-inline,
.has-error.radio label,
.has-error.checkbox label,
.has-error.radio-inline label,
.has-error.checkbox-inline label {
  color: #a94442;
}
.has-error .form-control {
  border-color: #a94442;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
}
.has-error .form-control:focus {
  border-color: #843534;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #ce8483;
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #ce8483;
}
.has-error .input-group-addon {
  color: #a94442;
  border-color: #a94442;
  background-color: #f2dede;
}
.has-error .form-control-feedback {
  color: #a94442;
}
.has-feedback label ~ .form-control-feedback {
  top: 23px;
}
.has-feedback label.sr-only ~ .form-control-feedback {
  top: 0;
}
.help-block {
  display: block;
  margin-top: 5px;
  margin-bottom: 10px;
  color: #404040;
}
@media (min-width: 768px) {
  .form-inline .form-group {
    display: inline-block;
    margin-bottom: 0;
    vertical-align: middle;
  }
  .form-inline .form-control {
    display: inline-block;
    width: auto;
    vertical-align: middle;
  }
  .form-inline .form-control-static {
    display: inline-block;
  }
  .form-inline .input-group {
    display: inline-table;
    vertical-align: middle;
  }
  .form-inline .input-group .input-group-addon,
  .form-inline .input-group .input-group-btn,
  .form-inline .input-group .form-control {
    width: auto;
  }
  .form-inline .input-group > .form-control {
    width: 100%;
  }
  .form-inline .control-label {
    margin-bottom: 0;
    vertical-align: middle;
  }
  .form-inline .radio,
  .form-inline .checkbox {
    display: inline-block;
    margin-top: 0;
    margin-bottom: 0;
    vertical-align: middle;
  }
  .form-inline .radio label,
  .form-inline .checkbox label {
    padding-left: 0;
  }
  .form-inline .radio input[type="radio"],
  .form-inline .checkbox input[type="checkbox"] {
    position: relative;
    margin-left: 0;
  }
  .form-inline .has-feedback .form-control-feedback {
    top: 0;
  }
}
.form-horizontal .radio,
.form-horizontal .checkbox,
.form-horizontal .radio-inline,
.form-horizontal .checkbox-inline {
  margin-top: 0;
  margin-bottom: 0;
  padding-top: 7px;
}
.form-horizontal .radio,
.form-horizontal .checkbox {
  min-height: 25px;
}
.form-horizontal .form-group {
  margin-left: 0px;
  margin-right: 0px;
}
@media (min-width: 768px) {
  .form-horizontal .control-label {
    text-align: right;
    margin-bottom: 0;
    padding-top: 7px;
  }
}
.form-horizontal .has-feedback .form-control-feedback {
  right: 0px;
}
@media (min-width: 768px) {
  .form-horizontal .form-group-lg .control-label {
    padding-top: 11px;
    font-size: 17px;
  }
}
@media (min-width: 768px) {
  .form-horizontal .form-group-sm .control-label {
    padding-top: 6px;
    font-size: 12px;
  }
}
.btn {
  display: inline-block;
  margin-bottom: 0;
  font-weight: normal;
  text-align: center;
  vertical-align: middle;
  touch-action: manipulation;
  cursor: pointer;
  background-image: none;
  border: 1px solid transparent;
  white-space: nowrap;
  padding: 6px 12px;
  font-size: 13px;
  line-height: 1.42857143;
  border-radius: 2px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.btn:focus,
.btn:active:focus,
.btn.active:focus,
.btn.focus,
.btn:active.focus,
.btn.active.focus {
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}
.btn:hover,
.btn:focus,
.btn.focus {
  color: #333;
  text-decoration: none;
}
.btn:active,
.btn.active {
  outline: 0;
  background-image: none;
  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn.disabled,
.btn[disabled],
fieldset[disabled] .btn {
  cursor: not-allowed;
  opacity: 0.65;
  filter: alpha(opacity=65);
  -webkit-box-shadow: none;
  box-shadow: none;
}
a.btn.disabled,
fieldset[disabled] a.btn {
  pointer-events: none;
}
.btn-default {
  color: #333;
  background-color: #fff;
  border-color: #ccc;
}
.btn-default:focus,
.btn-default.focus {
  color: #333;
  background-color: #e6e6e6;
  border-color: #8c8c8c;
}
.btn-default:hover {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
.btn-default:active,
.btn-default.active,
.open > .dropdown-toggle.btn-default {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
.btn-default:active:hover,
.btn-default.active:hover,
.open > .dropdown-toggle.btn-default:hover,
.btn-default:active:focus,
.btn-default.active:focus,
.open > .dropdown-toggle.btn-default:focus,
.btn-default:active.focus,
.btn-default.active.focus,
.open > .dropdown-toggle.btn-default.focus {
  color: #333;
  background-color: #d4d4d4;
  border-color: #8c8c8c;
}
.btn-default:active,
.btn-default.active,
.open > .dropdown-toggle.btn-default {
  background-image: none;
}
.btn-default.disabled:hover,
.btn-default[disabled]:hover,
fieldset[disabled] .btn-default:hover,
.btn-default.disabled:focus,
.btn-default[disabled]:focus,
fieldset[disabled] .btn-default:focus,
.btn-default.disabled.focus,
.btn-default[disabled].focus,
fieldset[disabled] .btn-default.focus {
  background-color: #fff;
  border-color: #ccc;
}
.btn-default .badge {
  color: #fff;
  background-color: #333;
}
.btn-primary {
  color: #fff;
  background-color: #337ab7;
  border-color: #2e6da4;
}
.btn-primary:focus,
.btn-primary.focus {
  color: #fff;
  background-color: #286090;
  border-color: #122b40;
}
.btn-primary:hover {
  color: #fff;
  background-color: #286090;
  border-color: #204d74;
}
.btn-primary:active,
.btn-primary.active,
.open > .dropdown-toggle.btn-primary {
  color: #fff;
  background-color: #286090;
  border-color: #204d74;
}
.btn-primary:active:hover,
.btn-primary.active:hover,
.open > .dropdown-toggle.btn-primary:hover,
.btn-primary:active:focus,
.btn-primary.active:focus,
.open > .dropdown-toggle.btn-primary:focus,
.btn-primary:active.focus,
.btn-primary.active.focus,
.open > .dropdown-toggle.btn-primary.focus {
  color: #fff;
  background-color: #204d74;
  border-color: #122b40;
}
.btn-primary:active,
.btn-primary.active,
.open > .dropdown-toggle.btn-primary {
  background-image: none;
}
.btn-primary.disabled:hover,
.btn-primary[disabled]:hover,
fieldset[disabled] .btn-primary:hover,
.btn-primary.disabled:focus,
.btn-primary[disabled]:focus,
fieldset[disabled] .btn-primary:focus,
.btn-primary.disabled.focus,
.btn-primary[disabled].focus,
fieldset[disabled] .btn-primary.focus {
  background-color: #337ab7;
  border-color: #2e6da4;
}
.btn-primary .badge {
  color: #337ab7;
  background-color: #fff;
}
.btn-success {
  color: #fff;
  background-color: #5cb85c;
  border-color: #4cae4c;
}
.btn-success:focus,
.btn-success.focus {
  color: #fff;
  background-color: #449d44;
  border-color: #255625;
}
.btn-success:hover {
  color: #fff;
  background-color: #449d44;
  border-color: #398439;
}
.btn-success:active,
.btn-success.active,
.open > .dropdown-toggle.btn-success {
  color: #fff;
  background-color: #449d44;
  border-color: #398439;
}
.btn-success:active:hover,
.btn-success.active:hover,
.open > .dropdown-toggle.btn-success:hover,
.btn-success:active:focus,
.btn-success.active:focus,
.open > .dropdown-toggle.btn-success:focus,
.btn-success:active.focus,
.btn-success.active.focus,
.open > .dropdown-toggle.btn-success.focus {
  color: #fff;
  background-color: #398439;
  border-color: #255625;
}
.btn-success:active,
.btn-success.active,
.open > .dropdown-toggle.btn-success {
  background-image: none;
}
.btn-success.disabled:hover,
.btn-success[disabled]:hover,
fieldset[disabled] .btn-success:hover,
.btn-success.disabled:focus,
.btn-success[disabled]:focus,
fieldset[disabled] .btn-success:focus,
.btn-success.disabled.focus,
.btn-success[disabled].focus,
fieldset[disabled] .btn-success.focus {
  background-color: #5cb85c;
  border-color: #4cae4c;
}
.btn-success .badge {
  color: #5cb85c;
  background-color: #fff;
}
.btn-info {
  color: #fff;
  background-color: #5bc0de;
  border-color: #46b8da;
}
.btn-info:focus,
.btn-info.focus {
  color: #fff;
  background-color: #31b0d5;
  border-color: #1b6d85;
}
.btn-info:hover {
  color: #fff;
  background-color: #31b0d5;
  border-color: #269abc;
}
.btn-info:active,
.btn-info.active,
.open > .dropdown-toggle.btn-info {
  color: #fff;
  background-color: #31b0d5;
  border-color: #269abc;
}
.btn-info:active:hover,
.btn-info.active:hover,
.open > .dropdown-toggle.btn-info:hover,
.btn-info:active:focus,
.btn-info.active:focus,
.open > .dropdown-toggle.btn-info:focus,
.btn-info:active.focus,
.btn-info.active.focus,
.open > .dropdown-toggle.btn-info.focus {
  color: #fff;
  background-color: #269abc;
  border-color: #1b6d85;
}
.btn-info:active,
.btn-info.active,
.open > .dropdown-toggle.btn-info {
  background-image: none;
}
.btn-info.disabled:hover,
.btn-info[disabled]:hover,
fieldset[disabled] .btn-info:hover,
.btn-info.disabled:focus,
.btn-info[disabled]:focus,
fieldset[disabled] .btn-info:focus,
.btn-info.disabled.focus,
.btn-info[disabled].focus,
fieldset[disabled] .btn-info.focus {
  background-color: #5bc0de;
  border-color: #46b8da;
}
.btn-info .badge {
  color: #5bc0de;
  background-color: #fff;
}
.btn-warning {
  color: #fff;
  background-color: #f0ad4e;
  border-color: #eea236;
}
.btn-warning:focus,
.btn-warning.focus {
  color: #fff;
  background-color: #ec971f;
  border-color: #985f0d;
}
.btn-warning:hover {
  color: #fff;
  background-color: #ec971f;
  border-color: #d58512;
}
.btn-warning:active,
.btn-warning.active,
.open > .dropdown-toggle.btn-warning {
  color: #fff;
  background-color: #ec971f;
  border-color: #d58512;
}
.btn-warning:active:hover,
.btn-warning.active:hover,
.open > .dropdown-toggle.btn-warning:hover,
.btn-warning:active:focus,
.btn-warning.active:focus,
.open > .dropdown-toggle.btn-warning:focus,
.btn-warning:active.focus,
.btn-warning.active.focus,
.open > .dropdown-toggle.btn-warning.focus {
  color: #fff;
  background-color: #d58512;
  border-color: #985f0d;
}
.btn-warning:active,
.btn-warning.active,
.open > .dropdown-toggle.btn-warning {
  background-image: none;
}
.btn-warning.disabled:hover,
.btn-warning[disabled]:hover,
fieldset[disabled] .btn-warning:hover,
.btn-warning.disabled:focus,
.btn-warning[disabled]:focus,
fieldset[disabled] .btn-warning:focus,
.btn-warning.disabled.focus,
.btn-warning[disabled].focus,
fieldset[disabled] .btn-warning.focus {
  background-color: #f0ad4e;
  border-color: #eea236;
}
.btn-warning .badge {
  color: #f0ad4e;
  background-color: #fff;
}
.btn-danger {
  color: #fff;
  background-color: #d9534f;
  border-color: #d43f3a;
}
.btn-danger:focus,
.btn-danger.focus {
  color: #fff;
  background-color: #c9302c;
  border-color: #761c19;
}
.btn-danger:hover {
  color: #fff;
  background-color: #c9302c;
  border-color: #ac2925;
}
.btn-danger:active,
.btn-danger.active,
.open > .dropdown-toggle.btn-danger {
  color: #fff;
  background-color: #c9302c;
  border-color: #ac2925;
}
.btn-danger:active:hover,
.btn-danger.active:hover,
.open > .dropdown-toggle.btn-danger:hover,
.btn-danger:active:focus,
.btn-danger.active:focus,
.open > .dropdown-toggle.btn-danger:focus,
.btn-danger:active.focus,
.btn-danger.active.focus,
.open > .dropdown-toggle.btn-danger.focus {
  color: #fff;
  background-color: #ac2925;
  border-color: #761c19;
}
.btn-danger:active,
.btn-danger.active,
.open > .dropdown-toggle.btn-danger {
  background-image: none;
}
.btn-danger.disabled:hover,
.btn-danger[disabled]:hover,
fieldset[disabled] .btn-danger:hover,
.btn-danger.disabled:focus,
.btn-danger[disabled]:focus,
fieldset[disabled] .btn-danger:focus,
.btn-danger.disabled.focus,
.btn-danger[disabled].focus,
fieldset[disabled] .btn-danger.focus {
  background-color: #d9534f;
  border-color: #d43f3a;
}
.btn-danger .badge {
  color: #d9534f;
  background-color: #fff;
}
.btn-link {
  color: #337ab7;
  font-weight: normal;
  border-radius: 0;
}
.btn-link,
.btn-link:active,
.btn-link.active,
.btn-link[disabled],
fieldset[disabled] .btn-link {
  background-color: transparent;
  -webkit-box-shadow: none;
  box-shadow: none;
}
.btn-link,
.btn-link:hover,
.btn-link:focus,
.btn-link:active {
  border-color: transparent;
}
.btn-link:hover,
.btn-link:focus {
  color: #23527c;
  text-decoration: underline;
  background-color: transparent;
}
.btn-link[disabled]:hover,
fieldset[disabled] .btn-link:hover,
.btn-link[disabled]:focus,
fieldset[disabled] .btn-link:focus {
  color: #777777;
  text-decoration: none;
}
.btn-lg,
.btn-group-lg > .btn {
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
  border-radius: 3px;
}
.btn-sm,
.btn-group-sm > .btn {
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
.btn-xs,
.btn-group-xs > .btn {
  padding: 1px 5px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
.btn-block {
  display: block;
  width: 100%;
}
.btn-block + .btn-block {
  margin-top: 5px;
}
input[type="submit"].btn-block,
input[type="reset"].btn-block,
input[type="button"].btn-block {
  width: 100%;
}
.fade {
  opacity: 0;
  -webkit-transition: opacity 0.15s linear;
  -o-transition: opacity 0.15s linear;
  transition: opacity 0.15s linear;
}
.fade.in {
  opacity: 1;
}
.collapse {
  display: none;
}
.collapse.in {
  display: block;
}
tr.collapse.in {
  display: table-row;
}
tbody.collapse.in {
  display: table-row-group;
}
.collapsing {
  position: relative;
  height: 0;
  overflow: hidden;
  -webkit-transition-property: height, visibility;
  transition-property: height, visibility;
  -webkit-transition-duration: 0.35s;
  transition-duration: 0.35s;
  -webkit-transition-timing-function: ease;
  transition-timing-function: ease;
}
.caret {
  display: inline-block;
  width: 0;
  height: 0;
  margin-left: 2px;
  vertical-align: middle;
  border-top: 4px dashed;
  border-top: 4px solid \9;
  border-right: 4px solid transparent;
  border-left: 4px solid transparent;
}
.dropup,
.dropdown {
  position: relative;
}
.dropdown-toggle:focus {
  outline: 0;
}
.dropdown-menu {
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 1000;
  display: none;
  float: left;
  min-width: 160px;
  padding: 5px 0;
  margin: 2px 0 0;
  list-style: none;
  font-size: 13px;
  text-align: left;
  background-color: #fff;
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 2px;
  -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);
  background-clip: padding-box;
}
.dropdown-menu.pull-right {
  right: 0;
  left: auto;
}
.dropdown-menu .divider {
  height: 1px;
  margin: 8px 0;
  overflow: hidden;
  background-color: #e5e5e5;
}
.dropdown-menu > li > a {
  display: block;
  padding: 3px 20px;
  clear: both;
  font-weight: normal;
  line-height: 1.42857143;
  color: #333333;
  white-space: nowrap;
}
.dropdown-menu > li > a:hover,
.dropdown-menu > li > a:focus {
  text-decoration: none;
  color: #262626;
  background-color: #f5f5f5;
}
.dropdown-menu > .active > a,
.dropdown-menu > .active > a:hover,
.dropdown-menu > .active > a:focus {
  color: #fff;
  text-decoration: none;
  outline: 0;
  background-color: #337ab7;
}
.dropdown-menu > .disabled > a,
.dropdown-menu > .disabled > a:hover,
.dropdown-menu > .disabled > a:focus {
  color: #777777;
}
.dropdown-menu > .disabled > a:hover,
.dropdown-menu > .disabled > a:focus {
  text-decoration: none;
  background-color: transparent;
  background-image: none;
  filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
  cursor: not-allowed;
}
.open > .dropdown-menu {
  display: block;
}
.open > a {
  outline: 0;
}
.dropdown-menu-right {
  left: auto;
  right: 0;
}
.dropdown-menu-left {
  left: 0;
  right: auto;
}
.dropdown-header {
  display: block;
  padding: 3px 20px;
  font-size: 12px;
  line-height: 1.42857143;
  color: #777777;
  white-space: nowrap;
}
.dropdown-backdrop {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  z-index: 990;
}
.pull-right > .dropdown-menu {
  right: 0;
  left: auto;
}
.dropup .caret,
.navbar-fixed-bottom .dropdown .caret {
  border-top: 0;
  border-bottom: 4px dashed;
  border-bottom: 4px solid \9;
  content: "";
}
.dropup .dropdown-menu,
.navbar-fixed-bottom .dropdown .dropdown-menu {
  top: auto;
  bottom: 100%;
  margin-bottom: 2px;
}
@media (min-width: 541px) {
  .navbar-right .dropdown-menu {
    left: auto;
    right: 0;
  }
  .navbar-right .dropdown-menu-left {
    left: 0;
    right: auto;
  }
}
.btn-group,
.btn-group-vertical {
  position: relative;
  display: inline-block;
  vertical-align: middle;
}
.btn-group > .btn,
.btn-group-vertical > .btn {
  position: relative;
  float: left;
}
.btn-group > .btn:hover,
.btn-group-vertical > .btn:hover,
.btn-group > .btn:focus,
.btn-group-vertical > .btn:focus,
.btn-group > .btn:active,
.btn-group-vertical > .btn:active,
.btn-group > .btn.active,
.btn-group-vertical > .btn.active {
  z-index: 2;
}
.btn-group .btn + .btn,
.btn-group .btn + .btn-group,
.btn-group .btn-group + .btn,
.btn-group .btn-group + .btn-group {
  margin-left: -1px;
}
.btn-toolbar {
  margin-left: -5px;
}
.btn-toolbar .btn,
.btn-toolbar .btn-group,
.btn-toolbar .input-group {
  float: left;
}
.btn-toolbar > .btn,
.btn-toolbar > .btn-group,
.btn-toolbar > .input-group {
  margin-left: 5px;
}
.btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {
  border-radius: 0;
}
.btn-group > .btn:first-child {
  margin-left: 0;
}
.btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) {
  border-bottom-right-radius: 0;
  border-top-right-radius: 0;
}
.btn-group > .btn:last-child:not(:first-child),
.btn-group > .dropdown-toggle:not(:first-child) {
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
}
.btn-group > .btn-group {
  float: left;
}
.btn-group > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}
.btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-bottom-right-radius: 0;
  border-top-right-radius: 0;
}
.btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
}
.btn-group .dropdown-toggle:active,
.btn-group.open .dropdown-toggle {
  outline: 0;
}
.btn-group > .btn + .dropdown-toggle {
  padding-left: 8px;
  padding-right: 8px;
}
.btn-group > .btn-lg + .dropdown-toggle {
  padding-left: 12px;
  padding-right: 12px;
}
.btn-group.open .dropdown-toggle {
  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn-group.open .dropdown-toggle.btn-link {
  -webkit-box-shadow: none;
  box-shadow: none;
}
.btn .caret {
  margin-left: 0;
}
.btn-lg .caret {
  border-width: 5px 5px 0;
  border-bottom-width: 0;
}
.dropup .btn-lg .caret {
  border-width: 0 5px 5px;
}
.btn-group-vertical > .btn,
.btn-group-vertical > .btn-group,
.btn-group-vertical > .btn-group > .btn {
  display: block;
  float: none;
  width: 100%;
  max-width: 100%;
}
.btn-group-vertical > .btn-group > .btn {
  float: none;
}
.btn-group-vertical > .btn + .btn,
.btn-group-vertical > .btn + .btn-group,
.btn-group-vertical > .btn-group + .btn,
.btn-group-vertical > .btn-group + .btn-group {
  margin-top: -1px;
  margin-left: 0;
}
.btn-group-vertical > .btn:not(:first-child):not(:last-child) {
  border-radius: 0;
}
.btn-group-vertical > .btn:first-child:not(:last-child) {
  border-top-right-radius: 2px;
  border-top-left-radius: 2px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group-vertical > .btn:last-child:not(:first-child) {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  border-bottom-right-radius: 2px;
  border-bottom-left-radius: 2px;
}
.btn-group-vertical > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}
.btn-group-vertical > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group-vertical > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group-vertical > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.btn-group-justified {
  display: table;
  width: 100%;
  table-layout: fixed;
  border-collapse: separate;
}
.btn-group-justified > .btn,
.btn-group-justified > .btn-group {
  float: none;
  display: table-cell;
  width: 1%;
}
.btn-group-justified > .btn-group .btn {
  width: 100%;
}
.btn-group-justified > .btn-group .dropdown-menu {
  left: auto;
}
[data-toggle="buttons"] > .btn input[type="radio"],
[data-toggle="buttons"] > .btn-group > .btn input[type="radio"],
[data-toggle="buttons"] > .btn input[type="checkbox"],
[data-toggle="buttons"] > .btn-group > .btn input[type="checkbox"] {
  position: absolute;
  clip: rect(0, 0, 0, 0);
  pointer-events: none;
}
.input-group {
  position: relative;
  display: table;
  border-collapse: separate;
}
.input-group[class*="col-"] {
  float: none;
  padding-left: 0;
  padding-right: 0;
}
.input-group .form-control {
  position: relative;
  z-index: 2;
  float: left;
  width: 100%;
  margin-bottom: 0;
}
.input-group .form-control:focus {
  z-index: 3;
}
.input-group-lg > .form-control,
.input-group-lg > .input-group-addon,
.input-group-lg > .input-group-btn > .btn {
  height: 45px;
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
  border-radius: 3px;
}
select.input-group-lg > .form-control,
select.input-group-lg > .input-group-addon,
select.input-group-lg > .input-group-btn > .btn {
  height: 45px;
  line-height: 45px;
}
textarea.input-group-lg > .form-control,
textarea.input-group-lg > .input-group-addon,
textarea.input-group-lg > .input-group-btn > .btn,
select[multiple].input-group-lg > .form-control,
select[multiple].input-group-lg > .input-group-addon,
select[multiple].input-group-lg > .input-group-btn > .btn {
  height: auto;
}
.input-group-sm > .form-control,
.input-group-sm > .input-group-addon,
.input-group-sm > .input-group-btn > .btn {
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
select.input-group-sm > .form-control,
select.input-group-sm > .input-group-addon,
select.input-group-sm > .input-group-btn > .btn {
  height: 30px;
  line-height: 30px;
}
textarea.input-group-sm > .form-control,
textarea.input-group-sm > .input-group-addon,
textarea.input-group-sm > .input-group-btn > .btn,
select[multiple].input-group-sm > .form-control,
select[multiple].input-group-sm > .input-group-addon,
select[multiple].input-group-sm > .input-group-btn > .btn {
  height: auto;
}
.input-group-addon,
.input-group-btn,
.input-group .form-control {
  display: table-cell;
}
.input-group-addon:not(:first-child):not(:last-child),
.input-group-btn:not(:first-child):not(:last-child),
.input-group .form-control:not(:first-child):not(:last-child) {
  border-radius: 0;
}
.input-group-addon,
.input-group-btn {
  width: 1%;
  white-space: nowrap;
  vertical-align: middle;
}
.input-group-addon {
  padding: 6px 12px;
  font-size: 13px;
  font-weight: normal;
  line-height: 1;
  color: #555555;
  text-align: center;
  background-color: #eeeeee;
  border: 1px solid #ccc;
  border-radius: 2px;
}
.input-group-addon.input-sm {
  padding: 5px 10px;
  font-size: 12px;
  border-radius: 1px;
}
.input-group-addon.input-lg {
  padding: 10px 16px;
  font-size: 17px;
  border-radius: 3px;
}
.input-group-addon input[type="radio"],
.input-group-addon input[type="checkbox"] {
  margin-top: 0;
}
.input-group .form-control:first-child,
.input-group-addon:first-child,
.input-group-btn:first-child > .btn,
.input-group-btn:first-child > .btn-group > .btn,
.input-group-btn:first-child > .dropdown-toggle,
.input-group-btn:last-child > .btn:not(:last-child):not(.dropdown-toggle),
.input-group-btn:last-child > .btn-group:not(:last-child) > .btn {
  border-bottom-right-radius: 0;
  border-top-right-radius: 0;
}
.input-group-addon:first-child {
  border-right: 0;
}
.input-group .form-control:last-child,
.input-group-addon:last-child,
.input-group-btn:last-child > .btn,
.input-group-btn:last-child > .btn-group > .btn,
.input-group-btn:last-child > .dropdown-toggle,
.input-group-btn:first-child > .btn:not(:first-child),
.input-group-btn:first-child > .btn-group:not(:first-child) > .btn {
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
}
.input-group-addon:last-child {
  border-left: 0;
}
.input-group-btn {
  position: relative;
  font-size: 0;
  white-space: nowrap;
}
.input-group-btn > .btn {
  position: relative;
}
.input-group-btn > .btn + .btn {
  margin-left: -1px;
}
.input-group-btn > .btn:hover,
.input-group-btn > .btn:focus,
.input-group-btn > .btn:active {
  z-index: 2;
}
.input-group-btn:first-child > .btn,
.input-group-btn:first-child > .btn-group {
  margin-right: -1px;
}
.input-group-btn:last-child > .btn,
.input-group-btn:last-child > .btn-group {
  z-index: 2;
  margin-left: -1px;
}
.nav {
  margin-bottom: 0;
  padding-left: 0;
  list-style: none;
}
.nav > li {
  position: relative;
  display: block;
}
.nav > li > a {
  position: relative;
  display: block;
  padding: 10px 15px;
}
.nav > li > a:hover,
.nav > li > a:focus {
  text-decoration: none;
  background-color: #eeeeee;
}
.nav > li.disabled > a {
  color: #777777;
}
.nav > li.disabled > a:hover,
.nav > li.disabled > a:focus {
  color: #777777;
  text-decoration: none;
  background-color: transparent;
  cursor: not-allowed;
}
.nav .open > a,
.nav .open > a:hover,
.nav .open > a:focus {
  background-color: #eeeeee;
  border-color: #337ab7;
}
.nav .nav-divider {
  height: 1px;
  margin: 8px 0;
  overflow: hidden;
  background-color: #e5e5e5;
}
.nav > li > a > img {
  max-width: none;
}
.nav-tabs {
  border-bottom: 1px solid #ddd;
}
.nav-tabs > li {
  float: left;
  margin-bottom: -1px;
}
.nav-tabs > li > a {
  margin-right: 2px;
  line-height: 1.42857143;
  border: 1px solid transparent;
  border-radius: 2px 2px 0 0;
}
.nav-tabs > li > a:hover {
  border-color: #eeeeee #eeeeee #ddd;
}
.nav-tabs > li.active > a,
.nav-tabs > li.active > a:hover,
.nav-tabs > li.active > a:focus {
  color: #555555;
  background-color: #fff;
  border: 1px solid #ddd;
  border-bottom-color: transparent;
  cursor: default;
}
.nav-tabs.nav-justified {
  width: 100%;
  border-bottom: 0;
}
.nav-tabs.nav-justified > li {
  float: none;
}
.nav-tabs.nav-justified > li > a {
  text-align: center;
  margin-bottom: 5px;
}
.nav-tabs.nav-justified > .dropdown .dropdown-menu {
  top: auto;
  left: auto;
}
@media (min-width: 768px) {
  .nav-tabs.nav-justified > li {
    display: table-cell;
    width: 1%;
  }
  .nav-tabs.nav-justified > li > a {
    margin-bottom: 0;
  }
}
.nav-tabs.nav-justified > li > a {
  margin-right: 0;
  border-radius: 2px;
}
.nav-tabs.nav-justified > .active > a,
.nav-tabs.nav-justified > .active > a:hover,
.nav-tabs.nav-justified > .active > a:focus {
  border: 1px solid #ddd;
}
@media (min-width: 768px) {
  .nav-tabs.nav-justified > li > a {
    border-bottom: 1px solid #ddd;
    border-radius: 2px 2px 0 0;
  }
  .nav-tabs.nav-justified > .active > a,
  .nav-tabs.nav-justified > .active > a:hover,
  .nav-tabs.nav-justified > .active > a:focus {
    border-bottom-color: #fff;
  }
}
.nav-pills > li {
  float: left;
}
.nav-pills > li > a {
  border-radius: 2px;
}
.nav-pills > li + li {
  margin-left: 2px;
}
.nav-pills > li.active > a,
.nav-pills > li.active > a:hover,
.nav-pills > li.active > a:focus {
  color: #fff;
  background-color: #337ab7;
}
.nav-stacked > li {
  float: none;
}
.nav-stacked > li + li {
  margin-top: 2px;
  margin-left: 0;
}
.nav-justified {
  width: 100%;
}
.nav-justified > li {
  float: none;
}
.nav-justified > li > a {
  text-align: center;
  margin-bottom: 5px;
}
.nav-justified > .dropdown .dropdown-menu {
  top: auto;
  left: auto;
}
@media (min-width: 768px) {
  .nav-justified > li {
    display: table-cell;
    width: 1%;
  }
  .nav-justified > li > a {
    margin-bottom: 0;
  }
}
.nav-tabs-justified {
  border-bottom: 0;
}
.nav-tabs-justified > li > a {
  margin-right: 0;
  border-radius: 2px;
}
.nav-tabs-justified > .active > a,
.nav-tabs-justified > .active > a:hover,
.nav-tabs-justified > .active > a:focus {
  border: 1px solid #ddd;
}
@media (min-width: 768px) {
  .nav-tabs-justified > li > a {
    border-bottom: 1px solid #ddd;
    border-radius: 2px 2px 0 0;
  }
  .nav-tabs-justified > .active > a,
  .nav-tabs-justified > .active > a:hover,
  .nav-tabs-justified > .active > a:focus {
    border-bottom-color: #fff;
  }
}
.tab-content > .tab-pane {
  display: none;
}
.tab-content > .active {
  display: block;
}
.nav-tabs .dropdown-menu {
  margin-top: -1px;
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.navbar {
  position: relative;
  min-height: 30px;
  margin-bottom: 18px;
  border: 1px solid transparent;
}
@media (min-width: 541px) {
  .navbar {
    border-radius: 2px;
  }
}
@media (min-width: 541px) {
  .navbar-header {
    float: left;
  }
}
.navbar-collapse {
  overflow-x: visible;
  padding-right: 0px;
  padding-left: 0px;
  border-top: 1px solid transparent;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
  -webkit-overflow-scrolling: touch;
}
.navbar-collapse.in {
  overflow-y: auto;
}
@media (min-width: 541px) {
  .navbar-collapse {
    width: auto;
    border-top: 0;
    box-shadow: none;
  }
  .navbar-collapse.collapse {
    display: block !important;
    height: auto !important;
    padding-bottom: 0;
    overflow: visible !important;
  }
  .navbar-collapse.in {
    overflow-y: visible;
  }
  .navbar-fixed-top .navbar-collapse,
  .navbar-static-top .navbar-collapse,
  .navbar-fixed-bottom .navbar-collapse {
    padding-left: 0;
    padding-right: 0;
  }
}
.navbar-fixed-top .navbar-collapse,
.navbar-fixed-bottom .navbar-collapse {
  max-height: 340px;
}
@media (max-device-width: 540px) and (orientation: landscape) {
  .navbar-fixed-top .navbar-collapse,
  .navbar-fixed-bottom .navbar-collapse {
    max-height: 200px;
  }
}
.container > .navbar-header,
.container-fluid > .navbar-header,
.container > .navbar-collapse,
.container-fluid > .navbar-collapse {
  margin-right: 0px;
  margin-left: 0px;
}
@media (min-width: 541px) {
  .container > .navbar-header,
  .container-fluid > .navbar-header,
  .container > .navbar-collapse,
  .container-fluid > .navbar-collapse {
    margin-right: 0;
    margin-left: 0;
  }
}
.navbar-static-top {
  z-index: 1000;
  border-width: 0 0 1px;
}
@media (min-width: 541px) {
  .navbar-static-top {
    border-radius: 0;
  }
}
.navbar-fixed-top,
.navbar-fixed-bottom {
  position: fixed;
  right: 0;
  left: 0;
  z-index: 1030;
}
@media (min-width: 541px) {
  .navbar-fixed-top,
  .navbar-fixed-bottom {
    border-radius: 0;
  }
}
.navbar-fixed-top {
  top: 0;
  border-width: 0 0 1px;
}
.navbar-fixed-bottom {
  bottom: 0;
  margin-bottom: 0;
  border-width: 1px 0 0;
}
.navbar-brand {
  float: left;
  padding: 6px 0px;
  font-size: 17px;
  line-height: 18px;
  height: 30px;
}
.navbar-brand:hover,
.navbar-brand:focus {
  text-decoration: none;
}
.navbar-brand > img {
  display: block;
}
@media (min-width: 541px) {
  .navbar > .container .navbar-brand,
  .navbar > .container-fluid .navbar-brand {
    margin-left: 0px;
  }
}
.navbar-toggle {
  position: relative;
  float: right;
  margin-right: 0px;
  padding: 9px 10px;
  margin-top: -2px;
  margin-bottom: -2px;
  background-color: transparent;
  background-image: none;
  border: 1px solid transparent;
  border-radius: 2px;
}
.navbar-toggle:focus {
  outline: 0;
}
.navbar-toggle .icon-bar {
  display: block;
  width: 22px;
  height: 2px;
  border-radius: 1px;
}
.navbar-toggle .icon-bar + .icon-bar {
  margin-top: 4px;
}
@media (min-width: 541px) {
  .navbar-toggle {
    display: none;
  }
}
.navbar-nav {
  margin: 3px 0px;
}
.navbar-nav > li > a {
  padding-top: 10px;
  padding-bottom: 10px;
  line-height: 18px;
}
@media (max-width: 540px) {
  .navbar-nav .open .dropdown-menu {
    position: static;
    float: none;
    width: auto;
    margin-top: 0;
    background-color: transparent;
    border: 0;
    box-shadow: none;
  }
  .navbar-nav .open .dropdown-menu > li > a,
  .navbar-nav .open .dropdown-menu .dropdown-header {
    padding: 5px 15px 5px 25px;
  }
  .navbar-nav .open .dropdown-menu > li > a {
    line-height: 18px;
  }
  .navbar-nav .open .dropdown-menu > li > a:hover,
  .navbar-nav .open .dropdown-menu > li > a:focus {
    background-image: none;
  }
}
@media (min-width: 541px) {
  .navbar-nav {
    float: left;
    margin: 0;
  }
  .navbar-nav > li {
    float: left;
  }
  .navbar-nav > li > a {
    padding-top: 6px;
    padding-bottom: 6px;
  }
}
.navbar-form {
  margin-left: 0px;
  margin-right: 0px;
  padding: 10px 0px;
  border-top: 1px solid transparent;
  border-bottom: 1px solid transparent;
  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 1px 0 rgba(255, 255, 255, 0.1);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 1px 0 rgba(255, 255, 255, 0.1);
  margin-top: -1px;
  margin-bottom: -1px;
}
@media (min-width: 768px) {
  .navbar-form .form-group {
    display: inline-block;
    margin-bottom: 0;
    vertical-align: middle;
  }
  .navbar-form .form-control {
    display: inline-block;
    width: auto;
    vertical-align: middle;
  }
  .navbar-form .form-control-static {
    display: inline-block;
  }
  .navbar-form .input-group {
    display: inline-table;
    vertical-align: middle;
  }
  .navbar-form .input-group .input-group-addon,
  .navbar-form .input-group .input-group-btn,
  .navbar-form .input-group .form-control {
    width: auto;
  }
  .navbar-form .input-group > .form-control {
    width: 100%;
  }
  .navbar-form .control-label {
    margin-bottom: 0;
    vertical-align: middle;
  }
  .navbar-form .radio,
  .navbar-form .checkbox {
    display: inline-block;
    margin-top: 0;
    margin-bottom: 0;
    vertical-align: middle;
  }
  .navbar-form .radio label,
  .navbar-form .checkbox label {
    padding-left: 0;
  }
  .navbar-form .radio input[type="radio"],
  .navbar-form .checkbox input[type="checkbox"] {
    position: relative;
    margin-left: 0;
  }
  .navbar-form .has-feedback .form-control-feedback {
    top: 0;
  }
}
@media (max-width: 540px) {
  .navbar-form .form-group {
    margin-bottom: 5px;
  }
  .navbar-form .form-group:last-child {
    margin-bottom: 0;
  }
}
@media (min-width: 541px) {
  .navbar-form {
    width: auto;
    border: 0;
    margin-left: 0;
    margin-right: 0;
    padding-top: 0;
    padding-bottom: 0;
    -webkit-box-shadow: none;
    box-shadow: none;
  }
}
.navbar-nav > li > .dropdown-menu {
  margin-top: 0;
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.navbar-fixed-bottom .navbar-nav > li > .dropdown-menu {
  margin-bottom: 0;
  border-top-right-radius: 2px;
  border-top-left-radius: 2px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.navbar-btn {
  margin-top: -1px;
  margin-bottom: -1px;
}
.navbar-btn.btn-sm {
  margin-top: 0px;
  margin-bottom: 0px;
}
.navbar-btn.btn-xs {
  margin-top: 4px;
  margin-bottom: 4px;
}
.navbar-text {
  margin-top: 6px;
  margin-bottom: 6px;
}
@media (min-width: 541px) {
  .navbar-text {
    float: left;
    margin-left: 0px;
    margin-right: 0px;
  }
}
@media (min-width: 541px) {
  .navbar-left {
    float: left !important;
    float: left;
  }
  .navbar-right {
    float: right !important;
    float: right;
    margin-right: 0px;
  }
  .navbar-right ~ .navbar-right {
    margin-right: 0;
  }
}
.navbar-default {
  background-color: #f8f8f8;
  border-color: #e7e7e7;
}
.navbar-default .navbar-brand {
  color: #777;
}
.navbar-default .navbar-brand:hover,
.navbar-default .navbar-brand:focus {
  color: #5e5e5e;
  background-color: transparent;
}
.navbar-default .navbar-text {
  color: #777;
}
.navbar-default .navbar-nav > li > a {
  color: #777;
}
.navbar-default .navbar-nav > li > a:hover,
.navbar-default .navbar-nav > li > a:focus {
  color: #333;
  background-color: transparent;
}
.navbar-default .navbar-nav > .active > a,
.navbar-default .navbar-nav > .active > a:hover,
.navbar-default .navbar-nav > .active > a:focus {
  color: #555;
  background-color: #e7e7e7;
}
.navbar-default .navbar-nav > .disabled > a,
.navbar-default .navbar-nav > .disabled > a:hover,
.navbar-default .navbar-nav > .disabled > a:focus {
  color: #ccc;
  background-color: transparent;
}
.navbar-default .navbar-toggle {
  border-color: #ddd;
}
.navbar-default .navbar-toggle:hover,
.navbar-default .navbar-toggle:focus {
  background-color: #ddd;
}
.navbar-default .navbar-toggle .icon-bar {
  background-color: #888;
}
.navbar-default .navbar-collapse,
.navbar-default .navbar-form {
  border-color: #e7e7e7;
}
.navbar-default .navbar-nav > .open > a,
.navbar-default .navbar-nav > .open > a:hover,
.navbar-default .navbar-nav > .open > a:focus {
  background-color: #e7e7e7;
  color: #555;
}
@media (max-width: 540px) {
  .navbar-default .navbar-nav .open .dropdown-menu > li > a {
    color: #777;
  }
  .navbar-default .navbar-nav .open .dropdown-menu > li > a:hover,
  .navbar-default .navbar-nav .open .dropdown-menu > li > a:focus {
    color: #333;
    background-color: transparent;
  }
  .navbar-default .navbar-nav .open .dropdown-menu > .active > a,
  .navbar-default .navbar-nav .open .dropdown-menu > .active > a:hover,
  .navbar-default .navbar-nav .open .dropdown-menu > .active > a:focus {
    color: #555;
    background-color: #e7e7e7;
  }
  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a,
  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:hover,
  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:focus {
    color: #ccc;
    background-color: transparent;
  }
}
.navbar-default .navbar-link {
  color: #777;
}
.navbar-default .navbar-link:hover {
  color: #333;
}
.navbar-default .btn-link {
  color: #777;
}
.navbar-default .btn-link:hover,
.navbar-default .btn-link:focus {
  color: #333;
}
.navbar-default .btn-link[disabled]:hover,
fieldset[disabled] .navbar-default .btn-link:hover,
.navbar-default .btn-link[disabled]:focus,
fieldset[disabled] .navbar-default .btn-link:focus {
  color: #ccc;
}
.navbar-inverse {
  background-color: #222;
  border-color: #080808;
}
.navbar-inverse .navbar-brand {
  color: #9d9d9d;
}
.navbar-inverse .navbar-brand:hover,
.navbar-inverse .navbar-brand:focus {
  color: #fff;
  background-color: transparent;
}
.navbar-inverse .navbar-text {
  color: #9d9d9d;
}
.navbar-inverse .navbar-nav > li > a {
  color: #9d9d9d;
}
.navbar-inverse .navbar-nav > li > a:hover,
.navbar-inverse .navbar-nav > li > a:focus {
  color: #fff;
  background-color: transparent;
}
.navbar-inverse .navbar-nav > .active > a,
.navbar-inverse .navbar-nav > .active > a:hover,
.navbar-inverse .navbar-nav > .active > a:focus {
  color: #fff;
  background-color: #080808;
}
.navbar-inverse .navbar-nav > .disabled > a,
.navbar-inverse .navbar-nav > .disabled > a:hover,
.navbar-inverse .navbar-nav > .disabled > a:focus {
  color: #444;
  background-color: transparent;
}
.navbar-inverse .navbar-toggle {
  border-color: #333;
}
.navbar-inverse .navbar-toggle:hover,
.navbar-inverse .navbar-toggle:focus {
  background-color: #333;
}
.navbar-inverse .navbar-toggle .icon-bar {
  background-color: #fff;
}
.navbar-inverse .navbar-collapse,
.navbar-inverse .navbar-form {
  border-color: #101010;
}
.navbar-inverse .navbar-nav > .open > a,
.navbar-inverse .navbar-nav > .open > a:hover,
.navbar-inverse .navbar-nav > .open > a:focus {
  background-color: #080808;
  color: #fff;
}
@media (max-width: 540px) {
  .navbar-inverse .navbar-nav .open .dropdown-menu > .dropdown-header {
    border-color: #080808;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu .divider {
    background-color: #080808;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a {
    color: #9d9d9d;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:hover,
  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:focus {
    color: #fff;
    background-color: transparent;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a,
  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:hover,
  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:focus {
    color: #fff;
    background-color: #080808;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a,
  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:hover,
  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:focus {
    color: #444;
    background-color: transparent;
  }
}
.navbar-inverse .navbar-link {
  color: #9d9d9d;
}
.navbar-inverse .navbar-link:hover {
  color: #fff;
}
.navbar-inverse .btn-link {
  color: #9d9d9d;
}
.navbar-inverse .btn-link:hover,
.navbar-inverse .btn-link:focus {
  color: #fff;
}
.navbar-inverse .btn-link[disabled]:hover,
fieldset[disabled] .navbar-inverse .btn-link:hover,
.navbar-inverse .btn-link[disabled]:focus,
fieldset[disabled] .navbar-inverse .btn-link:focus {
  color: #444;
}
.breadcrumb {
  padding: 8px 15px;
  margin-bottom: 18px;
  list-style: none;
  background-color: #f5f5f5;
  border-radius: 2px;
}
.breadcrumb > li {
  display: inline-block;
}
.breadcrumb > li + li:before {
  content: "/\00a0";
  padding: 0 5px;
  color: #5e5e5e;
}
.breadcrumb > .active {
  color: #777777;
}
.pagination {
  display: inline-block;
  padding-left: 0;
  margin: 18px 0;
  border-radius: 2px;
}
.pagination > li {
  display: inline;
}
.pagination > li > a,
.pagination > li > span {
  position: relative;
  float: left;
  padding: 6px 12px;
  line-height: 1.42857143;
  text-decoration: none;
  color: #337ab7;
  background-color: #fff;
  border: 1px solid #ddd;
  margin-left: -1px;
}
.pagination > li:first-child > a,
.pagination > li:first-child > span {
  margin-left: 0;
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.pagination > li:last-child > a,
.pagination > li:last-child > span {
  border-bottom-right-radius: 2px;
  border-top-right-radius: 2px;
}
.pagination > li > a:hover,
.pagination > li > span:hover,
.pagination > li > a:focus,
.pagination > li > span:focus {
  z-index: 2;
  color: #23527c;
  background-color: #eeeeee;
  border-color: #ddd;
}
.pagination > .active > a,
.pagination > .active > span,
.pagination > .active > a:hover,
.pagination > .active > span:hover,
.pagination > .active > a:focus,
.pagination > .active > span:focus {
  z-index: 3;
  color: #fff;
  background-color: #337ab7;
  border-color: #337ab7;
  cursor: default;
}
.pagination > .disabled > span,
.pagination > .disabled > span:hover,
.pagination > .disabled > span:focus,
.pagination > .disabled > a,
.pagination > .disabled > a:hover,
.pagination > .disabled > a:focus {
  color: #777777;
  background-color: #fff;
  border-color: #ddd;
  cursor: not-allowed;
}
.pagination-lg > li > a,
.pagination-lg > li > span {
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
}
.pagination-lg > li:first-child > a,
.pagination-lg > li:first-child > span {
  border-bottom-left-radius: 3px;
  border-top-left-radius: 3px;
}
.pagination-lg > li:last-child > a,
.pagination-lg > li:last-child > span {
  border-bottom-right-radius: 3px;
  border-top-right-radius: 3px;
}
.pagination-sm > li > a,
.pagination-sm > li > span {
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
}
.pagination-sm > li:first-child > a,
.pagination-sm > li:first-child > span {
  border-bottom-left-radius: 1px;
  border-top-left-radius: 1px;
}
.pagination-sm > li:last-child > a,
.pagination-sm > li:last-child > span {
  border-bottom-right-radius: 1px;
  border-top-right-radius: 1px;
}
.pager {
  padding-left: 0;
  margin: 18px 0;
  list-style: none;
  text-align: center;
}
.pager li {
  display: inline;
}
.pager li > a,
.pager li > span {
  display: inline-block;
  padding: 5px 14px;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 15px;
}
.pager li > a:hover,
.pager li > a:focus {
  text-decoration: none;
  background-color: #eeeeee;
}
.pager .next > a,
.pager .next > span {
  float: right;
}
.pager .previous > a,
.pager .previous > span {
  float: left;
}
.pager .disabled > a,
.pager .disabled > a:hover,
.pager .disabled > a:focus,
.pager .disabled > span {
  color: #777777;
  background-color: #fff;
  cursor: not-allowed;
}
.label {
  display: inline;
  padding: .2em .6em .3em;
  font-size: 75%;
  font-weight: bold;
  line-height: 1;
  color: #fff;
  text-align: center;
  white-space: nowrap;
  vertical-align: baseline;
  border-radius: .25em;
}
a.label:hover,
a.label:focus {
  color: #fff;
  text-decoration: none;
  cursor: pointer;
}
.label:empty {
  display: none;
}
.btn .label {
  position: relative;
  top: -1px;
}
.label-default {
  background-color: #777777;
}
.label-default[href]:hover,
.label-default[href]:focus {
  background-color: #5e5e5e;
}
.label-primary {
  background-color: #337ab7;
}
.label-primary[href]:hover,
.label-primary[href]:focus {
  background-color: #286090;
}
.label-success {
  background-color: #5cb85c;
}
.label-success[href]:hover,
.label-success[href]:focus {
  background-color: #449d44;
}
.label-info {
  background-color: #5bc0de;
}
.label-info[href]:hover,
.label-info[href]:focus {
  background-color: #31b0d5;
}
.label-warning {
  background-color: #f0ad4e;
}
.label-warning[href]:hover,
.label-warning[href]:focus {
  background-color: #ec971f;
}
.label-danger {
  background-color: #d9534f;
}
.label-danger[href]:hover,
.label-danger[href]:focus {
  background-color: #c9302c;
}
.badge {
  display: inline-block;
  min-width: 10px;
  padding: 3px 7px;
  font-size: 12px;
  font-weight: bold;
  color: #fff;
  line-height: 1;
  vertical-align: middle;
  white-space: nowrap;
  text-align: center;
  background-color: #777777;
  border-radius: 10px;
}
.badge:empty {
  display: none;
}
.btn .badge {
  position: relative;
  top: -1px;
}
.btn-xs .badge,
.btn-group-xs > .btn .badge {
  top: 0;
  padding: 1px 5px;
}
a.badge:hover,
a.badge:focus {
  color: #fff;
  text-decoration: none;
  cursor: pointer;
}
.list-group-item.active > .badge,
.nav-pills > .active > a > .badge {
  color: #337ab7;
  background-color: #fff;
}
.list-group-item > .badge {
  float: right;
}
.list-group-item > .badge + .badge {
  margin-right: 5px;
}
.nav-pills > li > a > .badge {
  margin-left: 3px;
}
.jumbotron {
  padding-top: 30px;
  padding-bottom: 30px;
  margin-bottom: 30px;
  color: inherit;
  background-color: #eeeeee;
}
.jumbotron h1,
.jumbotron .h1 {
  color: inherit;
}
.jumbotron p {
  margin-bottom: 15px;
  font-size: 20px;
  font-weight: 200;
}
.jumbotron > hr {
  border-top-color: #d5d5d5;
}
.container .jumbotron,
.container-fluid .jumbotron {
  border-radius: 3px;
  padding-left: 0px;
  padding-right: 0px;
}
.jumbotron .container {
  max-width: 100%;
}
@media screen and (min-width: 768px) {
  .jumbotron {
    padding-top: 48px;
    padding-bottom: 48px;
  }
  .container .jumbotron,
  .container-fluid .jumbotron {
    padding-left: 60px;
    padding-right: 60px;
  }
  .jumbotron h1,
  .jumbotron .h1 {
    font-size: 59px;
  }
}
.thumbnail {
  display: block;
  padding: 4px;
  margin-bottom: 18px;
  line-height: 1.42857143;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 2px;
  -webkit-transition: border 0.2s ease-in-out;
  -o-transition: border 0.2s ease-in-out;
  transition: border 0.2s ease-in-out;
}
.thumbnail > img,
.thumbnail a > img {
  margin-left: auto;
  margin-right: auto;
}
a.thumbnail:hover,
a.thumbnail:focus,
a.thumbnail.active {
  border-color: #337ab7;
}
.thumbnail .caption {
  padding: 9px;
  color: #000;
}
.alert {
  padding: 15px;
  margin-bottom: 18px;
  border: 1px solid transparent;
  border-radius: 2px;
}
.alert h4 {
  margin-top: 0;
  color: inherit;
}
.alert .alert-link {
  font-weight: bold;
}
.alert > p,
.alert > ul {
  margin-bottom: 0;
}
.alert > p + p {
  margin-top: 5px;
}
.alert-dismissable,
.alert-dismissible {
  padding-right: 35px;
}
.alert-dismissable .close,
.alert-dismissible .close {
  position: relative;
  top: -2px;
  right: -21px;
  color: inherit;
}
.alert-success {
  background-color: #dff0d8;
  border-color: #d6e9c6;
  color: #3c763d;
}
.alert-success hr {
  border-top-color: #c9e2b3;
}
.alert-success .alert-link {
  color: #2b542c;
}
.alert-info {
  background-color: #d9edf7;
  border-color: #bce8f1;
  color: #31708f;
}
.alert-info hr {
  border-top-color: #a6e1ec;
}
.alert-info .alert-link {
  color: #245269;
}
.alert-warning {
  background-color: #fcf8e3;
  border-color: #faebcc;
  color: #8a6d3b;
}
.alert-warning hr {
  border-top-color: #f7e1b5;
}
.alert-warning .alert-link {
  color: #66512c;
}
.alert-danger {
  background-color: #f2dede;
  border-color: #ebccd1;
  color: #a94442;
}
.alert-danger hr {
  border-top-color: #e4b9c0;
}
.alert-danger .alert-link {
  color: #843534;
}
@-webkit-keyframes progress-bar-stripes {
  from {
    background-position: 40px 0;
  }
  to {
    background-position: 0 0;
  }
}
@keyframes progress-bar-stripes {
  from {
    background-position: 40px 0;
  }
  to {
    background-position: 0 0;
  }
}
.progress {
  overflow: hidden;
  height: 18px;
  margin-bottom: 18px;
  background-color: #f5f5f5;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
}
.progress-bar {
  float: left;
  width: 0%;
  height: 100%;
  font-size: 12px;
  line-height: 18px;
  color: #fff;
  text-align: center;
  background-color: #337ab7;
  -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);
  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);
  -webkit-transition: width 0.6s ease;
  -o-transition: width 0.6s ease;
  transition: width 0.6s ease;
}
.progress-striped .progress-bar,
.progress-bar-striped {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-size: 40px 40px;
}
.progress.active .progress-bar,
.progress-bar.active {
  -webkit-animation: progress-bar-stripes 2s linear infinite;
  -o-animation: progress-bar-stripes 2s linear infinite;
  animation: progress-bar-stripes 2s linear infinite;
}
.progress-bar-success {
  background-color: #5cb85c;
}
.progress-striped .progress-bar-success {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-info {
  background-color: #5bc0de;
}
.progress-striped .progress-bar-info {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-warning {
  background-color: #f0ad4e;
}
.progress-striped .progress-bar-warning {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-danger {
  background-color: #d9534f;
}
.progress-striped .progress-bar-danger {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.media {
  margin-top: 15px;
}
.media:first-child {
  margin-top: 0;
}
.media,
.media-body {
  zoom: 1;
  overflow: hidden;
}
.media-body {
  width: 10000px;
}
.media-object {
  display: block;
}
.media-object.img-thumbnail {
  max-width: none;
}
.media-right,
.media > .pull-right {
  padding-left: 10px;
}
.media-left,
.media > .pull-left {
  padding-right: 10px;
}
.media-left,
.media-right,
.media-body {
  display: table-cell;
  vertical-align: top;
}
.media-middle {
  vertical-align: middle;
}
.media-bottom {
  vertical-align: bottom;
}
.media-heading {
  margin-top: 0;
  margin-bottom: 5px;
}
.media-list {
  padding-left: 0;
  list-style: none;
}
.list-group {
  margin-bottom: 20px;
  padding-left: 0;
}
.list-group-item {
  position: relative;
  display: block;
  padding: 10px 15px;
  margin-bottom: -1px;
  background-color: #fff;
  border: 1px solid #ddd;
}
.list-group-item:first-child {
  border-top-right-radius: 2px;
  border-top-left-radius: 2px;
}
.list-group-item:last-child {
  margin-bottom: 0;
  border-bottom-right-radius: 2px;
  border-bottom-left-radius: 2px;
}
a.list-group-item,
button.list-group-item {
  color: #555;
}
a.list-group-item .list-group-item-heading,
button.list-group-item .list-group-item-heading {
  color: #333;
}
a.list-group-item:hover,
button.list-group-item:hover,
a.list-group-item:focus,
button.list-group-item:focus {
  text-decoration: none;
  color: #555;
  background-color: #f5f5f5;
}
button.list-group-item {
  width: 100%;
  text-align: left;
}
.list-group-item.disabled,
.list-group-item.disabled:hover,
.list-group-item.disabled:focus {
  background-color: #eeeeee;
  color: #777777;
  cursor: not-allowed;
}
.list-group-item.disabled .list-group-item-heading,
.list-group-item.disabled:hover .list-group-item-heading,
.list-group-item.disabled:focus .list-group-item-heading {
  color: inherit;
}
.list-group-item.disabled .list-group-item-text,
.list-group-item.disabled:hover .list-group-item-text,
.list-group-item.disabled:focus .list-group-item-text {
  color: #777777;
}
.list-group-item.active,
.list-group-item.active:hover,
.list-group-item.active:focus {
  z-index: 2;
  color: #fff;
  background-color: #337ab7;
  border-color: #337ab7;
}
.list-group-item.active .list-group-item-heading,
.list-group-item.active:hover .list-group-item-heading,
.list-group-item.active:focus .list-group-item-heading,
.list-group-item.active .list-group-item-heading > small,
.list-group-item.active:hover .list-group-item-heading > small,
.list-group-item.active:focus .list-group-item-heading > small,
.list-group-item.active .list-group-item-heading > .small,
.list-group-item.active:hover .list-group-item-heading > .small,
.list-group-item.active:focus .list-group-item-heading > .small {
  color: inherit;
}
.list-group-item.active .list-group-item-text,
.list-group-item.active:hover .list-group-item-text,
.list-group-item.active:focus .list-group-item-text {
  color: #c7ddef;
}
.list-group-item-success {
  color: #3c763d;
  background-color: #dff0d8;
}
a.list-group-item-success,
button.list-group-item-success {
  color: #3c763d;
}
a.list-group-item-success .list-group-item-heading,
button.list-group-item-success .list-group-item-heading {
  color: inherit;
}
a.list-group-item-success:hover,
button.list-group-item-success:hover,
a.list-group-item-success:focus,
button.list-group-item-success:focus {
  color: #3c763d;
  background-color: #d0e9c6;
}
a.list-group-item-success.active,
button.list-group-item-success.active,
a.list-group-item-success.active:hover,
button.list-group-item-success.active:hover,
a.list-group-item-success.active:focus,
button.list-group-item-success.active:focus {
  color: #fff;
  background-color: #3c763d;
  border-color: #3c763d;
}
.list-group-item-info {
  color: #31708f;
  background-color: #d9edf7;
}
a.list-group-item-info,
button.list-group-item-info {
  color: #31708f;
}
a.list-group-item-info .list-group-item-heading,
button.list-group-item-info .list-group-item-heading {
  color: inherit;
}
a.list-group-item-info:hover,
button.list-group-item-info:hover,
a.list-group-item-info:focus,
button.list-group-item-info:focus {
  color: #31708f;
  background-color: #c4e3f3;
}
a.list-group-item-info.active,
button.list-group-item-info.active,
a.list-group-item-info.active:hover,
button.list-group-item-info.active:hover,
a.list-group-item-info.active:focus,
button.list-group-item-info.active:focus {
  color: #fff;
  background-color: #31708f;
  border-color: #31708f;
}
.list-group-item-warning {
  color: #8a6d3b;
  background-color: #fcf8e3;
}
a.list-group-item-warning,
button.list-group-item-warning {
  color: #8a6d3b;
}
a.list-group-item-warning .list-group-item-heading,
button.list-group-item-warning .list-group-item-heading {
  color: inherit;
}
a.list-group-item-warning:hover,
button.list-group-item-warning:hover,
a.list-group-item-warning:focus,
button.list-group-item-warning:focus {
  color: #8a6d3b;
  background-color: #faf2cc;
}
a.list-group-item-warning.active,
button.list-group-item-warning.active,
a.list-group-item-warning.active:hover,
button.list-group-item-warning.active:hover,
a.list-group-item-warning.active:focus,
button.list-group-item-warning.active:focus {
  color: #fff;
  background-color: #8a6d3b;
  border-color: #8a6d3b;
}
.list-group-item-danger {
  color: #a94442;
  background-color: #f2dede;
}
a.list-group-item-danger,
button.list-group-item-danger {
  color: #a94442;
}
a.list-group-item-danger .list-group-item-heading,
button.list-group-item-danger .list-group-item-heading {
  color: inherit;
}
a.list-group-item-danger:hover,
button.list-group-item-danger:hover,
a.list-group-item-danger:focus,
button.list-group-item-danger:focus {
  color: #a94442;
  background-color: #ebcccc;
}
a.list-group-item-danger.active,
button.list-group-item-danger.active,
a.list-group-item-danger.active:hover,
button.list-group-item-danger.active:hover,
a.list-group-item-danger.active:focus,
button.list-group-item-danger.active:focus {
  color: #fff;
  background-color: #a94442;
  border-color: #a94442;
}
.list-group-item-heading {
  margin-top: 0;
  margin-bottom: 5px;
}
.list-group-item-text {
  margin-bottom: 0;
  line-height: 1.3;
}
.panel {
  margin-bottom: 18px;
  background-color: #fff;
  border: 1px solid transparent;
  border-radius: 2px;
  -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
}
.panel-body {
  padding: 15px;
}
.panel-heading {
  padding: 10px 15px;
  border-bottom: 1px solid transparent;
  border-top-right-radius: 1px;
  border-top-left-radius: 1px;
}
.panel-heading > .dropdown .dropdown-toggle {
  color: inherit;
}
.panel-title {
  margin-top: 0;
  margin-bottom: 0;
  font-size: 15px;
  color: inherit;
}
.panel-title > a,
.panel-title > small,
.panel-title > .small,
.panel-title > small > a,
.panel-title > .small > a {
  color: inherit;
}
.panel-footer {
  padding: 10px 15px;
  background-color: #f5f5f5;
  border-top: 1px solid #ddd;
  border-bottom-right-radius: 1px;
  border-bottom-left-radius: 1px;
}
.panel > .list-group,
.panel > .panel-collapse > .list-group {
  margin-bottom: 0;
}
.panel > .list-group .list-group-item,
.panel > .panel-collapse > .list-group .list-group-item {
  border-width: 1px 0;
  border-radius: 0;
}
.panel > .list-group:first-child .list-group-item:first-child,
.panel > .panel-collapse > .list-group:first-child .list-group-item:first-child {
  border-top: 0;
  border-top-right-radius: 1px;
  border-top-left-radius: 1px;
}
.panel > .list-group:last-child .list-group-item:last-child,
.panel > .panel-collapse > .list-group:last-child .list-group-item:last-child {
  border-bottom: 0;
  border-bottom-right-radius: 1px;
  border-bottom-left-radius: 1px;
}
.panel > .panel-heading + .panel-collapse > .list-group .list-group-item:first-child {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.panel-heading + .list-group .list-group-item:first-child {
  border-top-width: 0;
}
.list-group + .panel-footer {
  border-top-width: 0;
}
.panel > .table,
.panel > .table-responsive > .table,
.panel > .panel-collapse > .table {
  margin-bottom: 0;
}
.panel > .table caption,
.panel > .table-responsive > .table caption,
.panel > .panel-collapse > .table caption {
  padding-left: 15px;
  padding-right: 15px;
}
.panel > .table:first-child,
.panel > .table-responsive:first-child > .table:first-child {
  border-top-right-radius: 1px;
  border-top-left-radius: 1px;
}
.panel > .table:first-child > thead:first-child > tr:first-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child,
.panel > .table:first-child > tbody:first-child > tr:first-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child {
  border-top-left-radius: 1px;
  border-top-right-radius: 1px;
}
.panel > .table:first-child > thead:first-child > tr:first-child td:first-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:first-child,
.panel > .table:first-child > tbody:first-child > tr:first-child td:first-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:first-child,
.panel > .table:first-child > thead:first-child > tr:first-child th:first-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:first-child,
.panel > .table:first-child > tbody:first-child > tr:first-child th:first-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:first-child {
  border-top-left-radius: 1px;
}
.panel > .table:first-child > thead:first-child > tr:first-child td:last-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:last-child,
.panel > .table:first-child > tbody:first-child > tr:first-child td:last-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:last-child,
.panel > .table:first-child > thead:first-child > tr:first-child th:last-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:last-child,
.panel > .table:first-child > tbody:first-child > tr:first-child th:last-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:last-child {
  border-top-right-radius: 1px;
}
.panel > .table:last-child,
.panel > .table-responsive:last-child > .table:last-child {
  border-bottom-right-radius: 1px;
  border-bottom-left-radius: 1px;
}
.panel > .table:last-child > tbody:last-child > tr:last-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child {
  border-bottom-left-radius: 1px;
  border-bottom-right-radius: 1px;
}
.panel > .table:last-child > tbody:last-child > tr:last-child td:first-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:first-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child td:first-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:first-child,
.panel > .table:last-child > tbody:last-child > tr:last-child th:first-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:first-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child th:first-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:first-child {
  border-bottom-left-radius: 1px;
}
.panel > .table:last-child > tbody:last-child > tr:last-child td:last-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:last-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child td:last-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:last-child,
.panel > .table:last-child > tbody:last-child > tr:last-child th:last-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:last-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child th:last-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:last-child {
  border-bottom-right-radius: 1px;
}
.panel > .panel-body + .table,
.panel > .panel-body + .table-responsive,
.panel > .table + .panel-body,
.panel > .table-responsive + .panel-body {
  border-top: 1px solid #ddd;
}
.panel > .table > tbody:first-child > tr:first-child th,
.panel > .table > tbody:first-child > tr:first-child td {
  border-top: 0;
}
.panel > .table-bordered,
.panel > .table-responsive > .table-bordered {
  border: 0;
}
.panel > .table-bordered > thead > tr > th:first-child,
.panel > .table-responsive > .table-bordered > thead > tr > th:first-child,
.panel > .table-bordered > tbody > tr > th:first-child,
.panel > .table-responsive > .table-bordered > tbody > tr > th:first-child,
.panel > .table-bordered > tfoot > tr > th:first-child,
.panel > .table-responsive > .table-bordered > tfoot > tr > th:first-child,
.panel > .table-bordered > thead > tr > td:first-child,
.panel > .table-responsive > .table-bordered > thead > tr > td:first-child,
.panel > .table-bordered > tbody > tr > td:first-child,
.panel > .table-responsive > .table-bordered > tbody > tr > td:first-child,
.panel > .table-bordered > tfoot > tr > td:first-child,
.panel > .table-responsive > .table-bordered > tfoot > tr > td:first-child {
  border-left: 0;
}
.panel > .table-bordered > thead > tr > th:last-child,
.panel > .table-responsive > .table-bordered > thead > tr > th:last-child,
.panel > .table-bordered > tbody > tr > th:last-child,
.panel > .table-responsive > .table-bordered > tbody > tr > th:last-child,
.panel > .table-bordered > tfoot > tr > th:last-child,
.panel > .table-responsive > .table-bordered > tfoot > tr > th:last-child,
.panel > .table-bordered > thead > tr > td:last-child,
.panel > .table-responsive > .table-bordered > thead > tr > td:last-child,
.panel > .table-bordered > tbody > tr > td:last-child,
.panel > .table-responsive > .table-bordered > tbody > tr > td:last-child,
.panel > .table-bordered > tfoot > tr > td:last-child,
.panel > .table-responsive > .table-bordered > tfoot > tr > td:last-child {
  border-right: 0;
}
.panel > .table-bordered > thead > tr:first-child > td,
.panel > .table-responsive > .table-bordered > thead > tr:first-child > td,
.panel > .table-bordered > tbody > tr:first-child > td,
.panel > .table-responsive > .table-bordered > tbody > tr:first-child > td,
.panel > .table-bordered > thead > tr:first-child > th,
.panel > .table-responsive > .table-bordered > thead > tr:first-child > th,
.panel > .table-bordered > tbody > tr:first-child > th,
.panel > .table-responsive > .table-bordered > tbody > tr:first-child > th {
  border-bottom: 0;
}
.panel > .table-bordered > tbody > tr:last-child > td,
.panel > .table-responsive > .table-bordered > tbody > tr:last-child > td,
.panel > .table-bordered > tfoot > tr:last-child > td,
.panel > .table-responsive > .table-bordered > tfoot > tr:last-child > td,
.panel > .table-bordered > tbody > tr:last-child > th,
.panel > .table-responsive > .table-bordered > tbody > tr:last-child > th,
.panel > .table-bordered > tfoot > tr:last-child > th,
.panel > .table-responsive > .table-bordered > tfoot > tr:last-child > th {
  border-bottom: 0;
}
.panel > .table-responsive {
  border: 0;
  margin-bottom: 0;
}
.panel-group {
  margin-bottom: 18px;
}
.panel-group .panel {
  margin-bottom: 0;
  border-radius: 2px;
}
.panel-group .panel + .panel {
  margin-top: 5px;
}
.panel-group .panel-heading {
  border-bottom: 0;
}
.panel-group .panel-heading + .panel-collapse > .panel-body,
.panel-group .panel-heading + .panel-collapse > .list-group {
  border-top: 1px solid #ddd;
}
.panel-group .panel-footer {
  border-top: 0;
}
.panel-group .panel-footer + .panel-collapse .panel-body {
  border-bottom: 1px solid #ddd;
}
.panel-default {
  border-color: #ddd;
}
.panel-default > .panel-heading {
  color: #333333;
  background-color: #f5f5f5;
  border-color: #ddd;
}
.panel-default > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #ddd;
}
.panel-default > .panel-heading .badge {
  color: #f5f5f5;
  background-color: #333333;
}
.panel-default > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #ddd;
}
.panel-primary {
  border-color: #337ab7;
}
.panel-primary > .panel-heading {
  color: #fff;
  background-color: #337ab7;
  border-color: #337ab7;
}
.panel-primary > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #337ab7;
}
.panel-primary > .panel-heading .badge {
  color: #337ab7;
  background-color: #fff;
}
.panel-primary > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #337ab7;
}
.panel-success {
  border-color: #d6e9c6;
}
.panel-success > .panel-heading {
  color: #3c763d;
  background-color: #dff0d8;
  border-color: #d6e9c6;
}
.panel-success > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #d6e9c6;
}
.panel-success > .panel-heading .badge {
  color: #dff0d8;
  background-color: #3c763d;
}
.panel-success > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #d6e9c6;
}
.panel-info {
  border-color: #bce8f1;
}
.panel-info > .panel-heading {
  color: #31708f;
  background-color: #d9edf7;
  border-color: #bce8f1;
}
.panel-info > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #bce8f1;
}
.panel-info > .panel-heading .badge {
  color: #d9edf7;
  background-color: #31708f;
}
.panel-info > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #bce8f1;
}
.panel-warning {
  border-color: #faebcc;
}
.panel-warning > .panel-heading {
  color: #8a6d3b;
  background-color: #fcf8e3;
  border-color: #faebcc;
}
.panel-warning > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #faebcc;
}
.panel-warning > .panel-heading .badge {
  color: #fcf8e3;
  background-color: #8a6d3b;
}
.panel-warning > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #faebcc;
}
.panel-danger {
  border-color: #ebccd1;
}
.panel-danger > .panel-heading {
  color: #a94442;
  background-color: #f2dede;
  border-color: #ebccd1;
}
.panel-danger > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #ebccd1;
}
.panel-danger > .panel-heading .badge {
  color: #f2dede;
  background-color: #a94442;
}
.panel-danger > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #ebccd1;
}
.embed-responsive {
  position: relative;
  display: block;
  height: 0;
  padding: 0;
  overflow: hidden;
}
.embed-responsive .embed-responsive-item,
.embed-responsive iframe,
.embed-responsive embed,
.embed-responsive object,
.embed-responsive video {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  height: 100%;
  width: 100%;
  border: 0;
}
.embed-responsive-16by9 {
  padding-bottom: 56.25%;
}
.embed-responsive-4by3 {
  padding-bottom: 75%;
}
.well {
  min-height: 20px;
  padding: 19px;
  margin-bottom: 20px;
  background-color: #f5f5f5;
  border: 1px solid #e3e3e3;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.05);
}
.well blockquote {
  border-color: #ddd;
  border-color: rgba(0, 0, 0, 0.15);
}
.well-lg {
  padding: 24px;
  border-radius: 3px;
}
.well-sm {
  padding: 9px;
  border-radius: 1px;
}
.close {
  float: right;
  font-size: 19.5px;
  font-weight: bold;
  line-height: 1;
  color: #000;
  text-shadow: 0 1px 0 #fff;
  opacity: 0.2;
  filter: alpha(opacity=20);
}
.close:hover,
.close:focus {
  color: #000;
  text-decoration: none;
  cursor: pointer;
  opacity: 0.5;
  filter: alpha(opacity=50);
}
button.close {
  padding: 0;
  cursor: pointer;
  background: transparent;
  border: 0;
  -webkit-appearance: none;
}
.modal-open {
  overflow: hidden;
}
.modal {
  display: none;
  overflow: hidden;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1050;
  -webkit-overflow-scrolling: touch;
  outline: 0;
}
.modal.fade .modal-dialog {
  -webkit-transform: translate(0, -25%);
  -ms-transform: translate(0, -25%);
  -o-transform: translate(0, -25%);
  transform: translate(0, -25%);
  -webkit-transition: -webkit-transform 0.3s ease-out;
  -moz-transition: -moz-transform 0.3s ease-out;
  -o-transition: -o-transform 0.3s ease-out;
  transition: transform 0.3s ease-out;
}
.modal.in .modal-dialog {
  -webkit-transform: translate(0, 0);
  -ms-transform: translate(0, 0);
  -o-transform: translate(0, 0);
  transform: translate(0, 0);
}
.modal-open .modal {
  overflow-x: hidden;
  overflow-y: auto;
}
.modal-dialog {
  position: relative;
  width: auto;
  margin: 10px;
}
.modal-content {
  position: relative;
  background-color: #fff;
  border: 1px solid #999;
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 3px;
  -webkit-box-shadow: 0 3px 9px rgba(0, 0, 0, 0.5);
  box-shadow: 0 3px 9px rgba(0, 0, 0, 0.5);
  background-clip: padding-box;
  outline: 0;
}
.modal-backdrop {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1040;
  background-color: #000;
}
.modal-backdrop.fade {
  opacity: 0;
  filter: alpha(opacity=0);
}
.modal-backdrop.in {
  opacity: 0.5;
  filter: alpha(opacity=50);
}
.modal-header {
  padding: 15px;
  border-bottom: 1px solid #e5e5e5;
}
.modal-header .close {
  margin-top: -2px;
}
.modal-title {
  margin: 0;
  line-height: 1.42857143;
}
.modal-body {
  position: relative;
  padding: 15px;
}
.modal-footer {
  padding: 15px;
  text-align: right;
  border-top: 1px solid #e5e5e5;
}
.modal-footer .btn + .btn {
  margin-left: 5px;
  margin-bottom: 0;
}
.modal-footer .btn-group .btn + .btn {
  margin-left: -1px;
}
.modal-footer .btn-block + .btn-block {
  margin-left: 0;
}
.modal-scrollbar-measure {
  position: absolute;
  top: -9999px;
  width: 50px;
  height: 50px;
  overflow: scroll;
}
@media (min-width: 768px) {
  .modal-dialog {
    width: 600px;
    margin: 30px auto;
  }
  .modal-content {
    -webkit-box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  }
  .modal-sm {
    width: 300px;
  }
}
@media (min-width: 992px) {
  .modal-lg {
    width: 900px;
  }
}
.tooltip {
  position: absolute;
  z-index: 1070;
  display: block;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-style: normal;
  font-weight: normal;
  letter-spacing: normal;
  line-break: auto;
  line-height: 1.42857143;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  white-space: normal;
  word-break: normal;
  word-spacing: normal;
  word-wrap: normal;
  font-size: 12px;
  opacity: 0;
  filter: alpha(opacity=0);
}
.tooltip.in {
  opacity: 0.9;
  filter: alpha(opacity=90);
}
.tooltip.top {
  margin-top: -3px;
  padding: 5px 0;
}
.tooltip.right {
  margin-left: 3px;
  padding: 0 5px;
}
.tooltip.bottom {
  margin-top: 3px;
  padding: 5px 0;
}
.tooltip.left {
  margin-left: -3px;
  padding: 0 5px;
}
.tooltip-inner {
  max-width: 200px;
  padding: 3px 8px;
  color: #fff;
  text-align: center;
  background-color: #000;
  border-radius: 2px;
}
.tooltip-arrow {
  position: absolute;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
}
.tooltip.top .tooltip-arrow {
  bottom: 0;
  left: 50%;
  margin-left: -5px;
  border-width: 5px 5px 0;
  border-top-color: #000;
}
.tooltip.top-left .tooltip-arrow {
  bottom: 0;
  right: 5px;
  margin-bottom: -5px;
  border-width: 5px 5px 0;
  border-top-color: #000;
}
.tooltip.top-right .tooltip-arrow {
  bottom: 0;
  left: 5px;
  margin-bottom: -5px;
  border-width: 5px 5px 0;
  border-top-color: #000;
}
.tooltip.right .tooltip-arrow {
  top: 50%;
  left: 0;
  margin-top: -5px;
  border-width: 5px 5px 5px 0;
  border-right-color: #000;
}
.tooltip.left .tooltip-arrow {
  top: 50%;
  right: 0;
  margin-top: -5px;
  border-width: 5px 0 5px 5px;
  border-left-color: #000;
}
.tooltip.bottom .tooltip-arrow {
  top: 0;
  left: 50%;
  margin-left: -5px;
  border-width: 0 5px 5px;
  border-bottom-color: #000;
}
.tooltip.bottom-left .tooltip-arrow {
  top: 0;
  right: 5px;
  margin-top: -5px;
  border-width: 0 5px 5px;
  border-bottom-color: #000;
}
.tooltip.bottom-right .tooltip-arrow {
  top: 0;
  left: 5px;
  margin-top: -5px;
  border-width: 0 5px 5px;
  border-bottom-color: #000;
}
.popover {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1060;
  display: none;
  max-width: 276px;
  padding: 1px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-style: normal;
  font-weight: normal;
  letter-spacing: normal;
  line-break: auto;
  line-height: 1.42857143;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  white-space: normal;
  word-break: normal;
  word-spacing: normal;
  word-wrap: normal;
  font-size: 13px;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 3px;
  -webkit-box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
}
.popover.top {
  margin-top: -10px;
}
.popover.right {
  margin-left: 10px;
}
.popover.bottom {
  margin-top: 10px;
}
.popover.left {
  margin-left: -10px;
}
.popover-title {
  margin: 0;
  padding: 8px 14px;
  font-size: 13px;
  background-color: #f7f7f7;
  border-bottom: 1px solid #ebebeb;
  border-radius: 2px 2px 0 0;
}
.popover-content {
  padding: 9px 14px;
}
.popover > .arrow,
.popover > .arrow:after {
  position: absolute;
  display: block;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
}
.popover > .arrow {
  border-width: 11px;
}
.popover > .arrow:after {
  border-width: 10px;
  content: "";
}
.popover.top > .arrow {
  left: 50%;
  margin-left: -11px;
  border-bottom-width: 0;
  border-top-color: #999999;
  border-top-color: rgba(0, 0, 0, 0.25);
  bottom: -11px;
}
.popover.top > .arrow:after {
  content: " ";
  bottom: 1px;
  margin-left: -10px;
  border-bottom-width: 0;
  border-top-color: #fff;
}
.popover.right > .arrow {
  top: 50%;
  left: -11px;
  margin-top: -11px;
  border-left-width: 0;
  border-right-color: #999999;
  border-right-color: rgba(0, 0, 0, 0.25);
}
.popover.right > .arrow:after {
  content: " ";
  left: 1px;
  bottom: -10px;
  border-left-width: 0;
  border-right-color: #fff;
}
.popover.bottom > .arrow {
  left: 50%;
  margin-left: -11px;
  border-top-width: 0;
  border-bottom-color: #999999;
  border-bottom-color: rgba(0, 0, 0, 0.25);
  top: -11px;
}
.popover.bottom > .arrow:after {
  content: " ";
  top: 1px;
  margin-left: -10px;
  border-top-width: 0;
  border-bottom-color: #fff;
}
.popover.left > .arrow {
  top: 50%;
  right: -11px;
  margin-top: -11px;
  border-right-width: 0;
  border-left-color: #999999;
  border-left-color: rgba(0, 0, 0, 0.25);
}
.popover.left > .arrow:after {
  content: " ";
  right: 1px;
  border-right-width: 0;
  border-left-color: #fff;
  bottom: -10px;
}
.carousel {
  position: relative;
}
.carousel-inner {
  position: relative;
  overflow: hidden;
  width: 100%;
}
.carousel-inner > .item {
  display: none;
  position: relative;
  -webkit-transition: 0.6s ease-in-out left;
  -o-transition: 0.6s ease-in-out left;
  transition: 0.6s ease-in-out left;
}
.carousel-inner > .item > img,
.carousel-inner > .item > a > img {
  line-height: 1;
}
@media all and (transform-3d), (-webkit-transform-3d) {
  .carousel-inner > .item {
    -webkit-transition: -webkit-transform 0.6s ease-in-out;
    -moz-transition: -moz-transform 0.6s ease-in-out;
    -o-transition: -o-transform 0.6s ease-in-out;
    transition: transform 0.6s ease-in-out;
    -webkit-backface-visibility: hidden;
    -moz-backface-visibility: hidden;
    backface-visibility: hidden;
    -webkit-perspective: 1000px;
    -moz-perspective: 1000px;
    perspective: 1000px;
  }
  .carousel-inner > .item.next,
  .carousel-inner > .item.active.right {
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
    left: 0;
  }
  .carousel-inner > .item.prev,
  .carousel-inner > .item.active.left {
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
    left: 0;
  }
  .carousel-inner > .item.next.left,
  .carousel-inner > .item.prev.right,
  .carousel-inner > .item.active {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    left: 0;
  }
}
.carousel-inner > .active,
.carousel-inner > .next,
.carousel-inner > .prev {
  display: block;
}
.carousel-inner > .active {
  left: 0;
}
.carousel-inner > .next,
.carousel-inner > .prev {
  position: absolute;
  top: 0;
  width: 100%;
}
.carousel-inner > .next {
  left: 100%;
}
.carousel-inner > .prev {
  left: -100%;
}
.carousel-inner > .next.left,
.carousel-inner > .prev.right {
  left: 0;
}
.carousel-inner > .active.left {
  left: -100%;
}
.carousel-inner > .active.right {
  left: 100%;
}
.carousel-control {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  width: 15%;
  opacity: 0.5;
  filter: alpha(opacity=50);
  font-size: 20px;
  color: #fff;
  text-align: center;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
  background-color: rgba(0, 0, 0, 0);
}
.carousel-control.left {
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-repeat: repeat-x;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);
}
.carousel-control.right {
  left: auto;
  right: 0;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-repeat: repeat-x;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);
}
.carousel-control:hover,
.carousel-control:focus {
  outline: 0;
  color: #fff;
  text-decoration: none;
  opacity: 0.9;
  filter: alpha(opacity=90);
}
.carousel-control .icon-prev,
.carousel-control .icon-next,
.carousel-control .glyphicon-chevron-left,
.carousel-control .glyphicon-chevron-right {
  position: absolute;
  top: 50%;
  margin-top: -10px;
  z-index: 5;
  display: inline-block;
}
.carousel-control .icon-prev,
.carousel-control .glyphicon-chevron-left {
  left: 50%;
  margin-left: -10px;
}
.carousel-control .icon-next,
.carousel-control .glyphicon-chevron-right {
  right: 50%;
  margin-right: -10px;
}
.carousel-control .icon-prev,
.carousel-control .icon-next {
  width: 20px;
  height: 20px;
  line-height: 1;
  font-family: serif;
}
.carousel-control .icon-prev:before {
  content: '\2039';
}
.carousel-control .icon-next:before {
  content: '\203a';
}
.carousel-indicators {
  position: absolute;
  bottom: 10px;
  left: 50%;
  z-index: 15;
  width: 60%;
  margin-left: -30%;
  padding-left: 0;
  list-style: none;
  text-align: center;
}
.carousel-indicators li {
  display: inline-block;
  width: 10px;
  height: 10px;
  margin: 1px;
  text-indent: -999px;
  border: 1px solid #fff;
  border-radius: 10px;
  cursor: pointer;
  background-color: #000 \9;
  background-color: rgba(0, 0, 0, 0);
}
.carousel-indicators .active {
  margin: 0;
  width: 12px;
  height: 12px;
  background-color: #fff;
}
.carousel-caption {
  position: absolute;
  left: 15%;
  right: 15%;
  bottom: 20px;
  z-index: 10;
  padding-top: 20px;
  padding-bottom: 20px;
  color: #fff;
  text-align: center;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
}
.carousel-caption .btn {
  text-shadow: none;
}
@media screen and (min-width: 768px) {
  .carousel-control .glyphicon-chevron-left,
  .carousel-control .glyphicon-chevron-right,
  .carousel-control .icon-prev,
  .carousel-control .icon-next {
    width: 30px;
    height: 30px;
    margin-top: -10px;
    font-size: 30px;
  }
  .carousel-control .glyphicon-chevron-left,
  .carousel-control .icon-prev {
    margin-left: -10px;
  }
  .carousel-control .glyphicon-chevron-right,
  .carousel-control .icon-next {
    margin-right: -10px;
  }
  .carousel-caption {
    left: 20%;
    right: 20%;
    padding-bottom: 30px;
  }
  .carousel-indicators {
    bottom: 20px;
  }
}
.clearfix:before,
.clearfix:after,
.dl-horizontal dd:before,
.dl-horizontal dd:after,
.container:before,
.container:after,
.container-fluid:before,
.container-fluid:after,
.row:before,
.row:after,
.form-horizontal .form-group:before,
.form-horizontal .form-group:after,
.btn-toolbar:before,
.btn-toolbar:after,
.btn-group-vertical > .btn-group:before,
.btn-group-vertical > .btn-group:after,
.nav:before,
.nav:after,
.navbar:before,
.navbar:after,
.navbar-header:before,
.navbar-header:after,
.navbar-collapse:before,
.navbar-collapse:after,
.pager:before,
.pager:after,
.panel-body:before,
.panel-body:after,
.modal-header:before,
.modal-header:after,
.modal-footer:before,
.modal-footer:after,
.item_buttons:before,
.item_buttons:after {
  content: " ";
  display: table;
}
.clearfix:after,
.dl-horizontal dd:after,
.container:after,
.container-fluid:after,
.row:after,
.form-horizontal .form-group:after,
.btn-toolbar:after,
.btn-group-vertical > .btn-group:after,
.nav:after,
.navbar:after,
.navbar-header:after,
.navbar-collapse:after,
.pager:after,
.panel-body:after,
.modal-header:after,
.modal-footer:after,
.item_buttons:after {
  clear: both;
}
.center-block {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.pull-right {
  float: right !important;
}
.pull-left {
  float: left !important;
}
.hide {
  display: none !important;
}
.show {
  display: block !important;
}
.invisible {
  visibility: hidden;
}
.text-hide {
  font: 0/0 a;
  color: transparent;
  text-shadow: none;
  background-color: transparent;
  border: 0;
}
.hidden {
  display: none !important;
}
.affix {
  position: fixed;
}
@-ms-viewport {
  width: device-width;
}
.visible-xs,
.visible-sm,
.visible-md,
.visible-lg {
  display: none !important;
}
.visible-xs-block,
.visible-xs-inline,
.visible-xs-inline-block,
.visible-sm-block,
.visible-sm-inline,
.visible-sm-inline-block,
.visible-md-block,
.visible-md-inline,
.visible-md-inline-block,
.visible-lg-block,
.visible-lg-inline,
.visible-lg-inline-block {
  display: none !important;
}
@media (max-width: 767px) {
  .visible-xs {
    display: block !important;
  }
  table.visible-xs {
    display: table !important;
  }
  tr.visible-xs {
    display: table-row !important;
  }
  th.visible-xs,
  td.visible-xs {
    display: table-cell !important;
  }
}
@media (max-width: 767px) {
  .visible-xs-block {
    display: block !important;
  }
}
@media (max-width: 767px) {
  .visible-xs-inline {
    display: inline !important;
  }
}
@media (max-width: 767px) {
  .visible-xs-inline-block {
    display: inline-block !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .visible-sm {
    display: block !important;
  }
  table.visible-sm {
    display: table !important;
  }
  tr.visible-sm {
    display: table-row !important;
  }
  th.visible-sm,
  td.visible-sm {
    display: table-cell !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .visible-sm-block {
    display: block !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .visible-sm-inline {
    display: inline !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .visible-sm-inline-block {
    display: inline-block !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .visible-md {
    display: block !important;
  }
  table.visible-md {
    display: table !important;
  }
  tr.visible-md {
    display: table-row !important;
  }
  th.visible-md,
  td.visible-md {
    display: table-cell !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .visible-md-block {
    display: block !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .visible-md-inline {
    display: inline !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .visible-md-inline-block {
    display: inline-block !important;
  }
}
@media (min-width: 1200px) {
  .visible-lg {
    display: block !important;
  }
  table.visible-lg {
    display: table !important;
  }
  tr.visible-lg {
    display: table-row !important;
  }
  th.visible-lg,
  td.visible-lg {
    display: table-cell !important;
  }
}
@media (min-width: 1200px) {
  .visible-lg-block {
    display: block !important;
  }
}
@media (min-width: 1200px) {
  .visible-lg-inline {
    display: inline !important;
  }
}
@media (min-width: 1200px) {
  .visible-lg-inline-block {
    display: inline-block !important;
  }
}
@media (max-width: 767px) {
  .hidden-xs {
    display: none !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .hidden-sm {
    display: none !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .hidden-md {
    display: none !important;
  }
}
@media (min-width: 1200px) {
  .hidden-lg {
    display: none !important;
  }
}
.visible-print {
  display: none !important;
}
@media print {
  .visible-print {
    display: block !important;
  }
  table.visible-print {
    display: table !important;
  }
  tr.visible-print {
    display: table-row !important;
  }
  th.visible-print,
  td.visible-print {
    display: table-cell !important;
  }
}
.visible-print-block {
  display: none !important;
}
@media print {
  .visible-print-block {
    display: block !important;
  }
}
.visible-print-inline {
  display: none !important;
}
@media print {
  .visible-print-inline {
    display: inline !important;
  }
}
.visible-print-inline-block {
  display: none !important;
}
@media print {
  .visible-print-inline-block {
    display: inline-block !important;
  }
}
@media print {
  .hidden-print {
    display: none !important;
  }
}
/*!
*
* Font Awesome
*
*/
/*!
 *  Font Awesome 4.2.0 by @davegandy - http://fontawesome.io - @fontawesome
 *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)
 */
/* FONT PATH
 * -------------------------- */
@font-face {
  font-family: 'FontAwesome';
  src: url('../components/font-awesome/fonts/fontawesome-webfont.eot?v=4.2.0');
  src: url('../components/font-awesome/fonts/fontawesome-webfont.eot?#iefix&v=4.2.0') format('embedded-opentype'), url('../components/font-awesome/fonts/fontawesome-webfont.woff?v=4.2.0') format('woff'), url('../components/font-awesome/fonts/fontawesome-webfont.ttf?v=4.2.0') format('truetype'), url('../components/font-awesome/fonts/fontawesome-webfont.svg?v=4.2.0#fontawesomeregular') format('svg');
  font-weight: normal;
  font-style: normal;
}
.fa {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-fw {
  width: 1.28571429em;
  text-align: center;
}
.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}
.fa-li.fa-lg {
  left: -1.85714286em;
}
.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eee;
  border-radius: .1em;
}
.pull-right {
  float: right;
}
.pull-left {
  float: left;
}
.fa.pull-left {
  margin-right: .3em;
}
.fa.pull-right {
  margin-left: .3em;
}
.fa-spin {
  -webkit-animation: fa-spin 2s infinite linear;
  animation: fa-spin 2s infinite linear;
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
.fa-rotate-90 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
  -webkit-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  transform: rotate(90deg);
}
.fa-rotate-180 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2);
  -webkit-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  transform: rotate(180deg);
}
.fa-rotate-270 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
  -webkit-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);
  -webkit-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);
  -webkit-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  transform: scale(1, -1);
}
:root .fa-rotate-90,
:root .fa-rotate-180,
:root .fa-rotate-270,
:root .fa-flip-horizontal,
:root .fa-flip-vertical {
  filter: none;
}
.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #fff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
  content: "\f000";
}
.fa-music:before {
  content: "\f001";
}
.fa-search:before {
  content: "\f002";
}
.fa-envelope-o:before {
  content: "\f003";
}
.fa-heart:before {
  content: "\f004";
}
.fa-star:before {
  content: "\f005";
}
.fa-star-o:before {
  content: "\f006";
}
.fa-user:before {
  content: "\f007";
}
.fa-film:before {
  content: "\f008";
}
.fa-th-large:before {
  content: "\f009";
}
.fa-th:before {
  content: "\f00a";
}
.fa-th-list:before {
  content: "\f00b";
}
.fa-check:before {
  content: "\f00c";
}
.fa-remove:before,
.fa-close:before,
.fa-times:before {
  content: "\f00d";
}
.fa-search-plus:before {
  content: "\f00e";
}
.fa-search-minus:before {
  content: "\f010";
}
.fa-power-off:before {
  content: "\f011";
}
.fa-signal:before {
  content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
  content: "\f013";
}
.fa-trash-o:before {
  content: "\f014";
}
.fa-home:before {
  content: "\f015";
}
.fa-file-o:before {
  content: "\f016";
}
.fa-clock-o:before {
  content: "\f017";
}
.fa-road:before {
  content: "\f018";
}
.fa-download:before {
  content: "\f019";
}
.fa-arrow-circle-o-down:before {
  content: "\f01a";
}
.fa-arrow-circle-o-up:before {
  content: "\f01b";
}
.fa-inbox:before {
  content: "\f01c";
}
.fa-play-circle-o:before {
  content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
  content: "\f01e";
}
.fa-refresh:before {
  content: "\f021";
}
.fa-list-alt:before {
  content: "\f022";
}
.fa-lock:before {
  content: "\f023";
}
.fa-flag:before {
  content: "\f024";
}
.fa-headphones:before {
  content: "\f025";
}
.fa-volume-off:before {
  content: "\f026";
}
.fa-volume-down:before {
  content: "\f027";
}
.fa-volume-up:before {
  content: "\f028";
}
.fa-qrcode:before {
  content: "\f029";
}
.fa-barcode:before {
  content: "\f02a";
}
.fa-tag:before {
  content: "\f02b";
}
.fa-tags:before {
  content: "\f02c";
}
.fa-book:before {
  content: "\f02d";
}
.fa-bookmark:before {
  content: "\f02e";
}
.fa-print:before {
  content: "\f02f";
}
.fa-camera:before {
  content: "\f030";
}
.fa-font:before {
  content: "\f031";
}
.fa-bold:before {
  content: "\f032";
}
.fa-italic:before {
  content: "\f033";
}
.fa-text-height:before {
  content: "\f034";
}
.fa-text-width:before {
  content: "\f035";
}
.fa-align-left:before {
  content: "\f036";
}
.fa-align-center:before {
  content: "\f037";
}
.fa-align-right:before {
  content: "\f038";
}
.fa-align-justify:before {
  content: "\f039";
}
.fa-list:before {
  content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
  content: "\f03b";
}
.fa-indent:before {
  content: "\f03c";
}
.fa-video-camera:before {
  content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\f03e";
}
.fa-pencil:before {
  content: "\f040";
}
.fa-map-marker:before {
  content: "\f041";
}
.fa-adjust:before {
  content: "\f042";
}
.fa-tint:before {
  content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\f044";
}
.fa-share-square-o:before {
  content: "\f045";
}
.fa-check-square-o:before {
  content: "\f046";
}
.fa-arrows:before {
  content: "\f047";
}
.fa-step-backward:before {
  content: "\f048";
}
.fa-fast-backward:before {
  content: "\f049";
}
.fa-backward:before {
  content: "\f04a";
}
.fa-play:before {
  content: "\f04b";
}
.fa-pause:before {
  content: "\f04c";
}
.fa-stop:before {
  content: "\f04d";
}
.fa-forward:before {
  content: "\f04e";
}
.fa-fast-forward:before {
  content: "\f050";
}
.fa-step-forward:before {
  content: "\f051";
}
.fa-eject:before {
  content: "\f052";
}
.fa-chevron-left:before {
  content: "\f053";
}
.fa-chevron-right:before {
  content: "\f054";
}
.fa-plus-circle:before {
  content: "\f055";
}
.fa-minus-circle:before {
  content: "\f056";
}
.fa-times-circle:before {
  content: "\f057";
}
.fa-check-circle:before {
  content: "\f058";
}
.fa-question-circle:before {
  content: "\f059";
}
.fa-info-circle:before {
  content: "\f05a";
}
.fa-crosshairs:before {
  content: "\f05b";
}
.fa-times-circle-o:before {
  content: "\f05c";
}
.fa-check-circle-o:before {
  content: "\f05d";
}
.fa-ban:before {
  content: "\f05e";
}
.fa-arrow-left:before {
  content: "\f060";
}
.fa-arrow-right:before {
  content: "\f061";
}
.fa-arrow-up:before {
  content: "\f062";
}
.fa-arrow-down:before {
  content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
  content: "\f064";
}
.fa-expand:before {
  content: "\f065";
}
.fa-compress:before {
  content: "\f066";
}
.fa-plus:before {
  content: "\f067";
}
.fa-minus:before {
  content: "\f068";
}
.fa-asterisk:before {
  content: "\f069";
}
.fa-exclamation-circle:before {
  content: "\f06a";
}
.fa-gift:before {
  content: "\f06b";
}
.fa-leaf:before {
  content: "\f06c";
}
.fa-fire:before {
  content: "\f06d";
}
.fa-eye:before {
  content: "\f06e";
}
.fa-eye-slash:before {
  content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\f071";
}
.fa-plane:before {
  content: "\f072";
}
.fa-calendar:before {
  content: "\f073";
}
.fa-random:before {
  content: "\f074";
}
.fa-comment:before {
  content: "\f075";
}
.fa-magnet:before {
  content: "\f076";
}
.fa-chevron-up:before {
  content: "\f077";
}
.fa-chevron-down:before {
  content: "\f078";
}
.fa-retweet:before {
  content: "\f079";
}
.fa-shopping-cart:before {
  content: "\f07a";
}
.fa-folder:before {
  content: "\f07b";
}
.fa-folder-open:before {
  content: "\f07c";
}
.fa-arrows-v:before {
  content: "\f07d";
}
.fa-arrows-h:before {
  content: "\f07e";
}
.fa-bar-chart-o:before,
.fa-bar-chart:before {
  content: "\f080";
}
.fa-twitter-square:before {
  content: "\f081";
}
.fa-facebook-square:before {
  content: "\f082";
}
.fa-camera-retro:before {
  content: "\f083";
}
.fa-key:before {
  content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
  content: "\f085";
}
.fa-comments:before {
  content: "\f086";
}
.fa-thumbs-o-up:before {
  content: "\f087";
}
.fa-thumbs-o-down:before {
  content: "\f088";
}
.fa-star-half:before {
  content: "\f089";
}
.fa-heart-o:before {
  content: "\f08a";
}
.fa-sign-out:before {
  content: "\f08b";
}
.fa-linkedin-square:before {
  content: "\f08c";
}
.fa-thumb-tack:before {
  content: "\f08d";
}
.fa-external-link:before {
  content: "\f08e";
}
.fa-sign-in:before {
  content: "\f090";
}
.fa-trophy:before {
  content: "\f091";
}
.fa-github-square:before {
  content: "\f092";
}
.fa-upload:before {
  content: "\f093";
}
.fa-lemon-o:before {
  content: "\f094";
}
.fa-phone:before {
  content: "\f095";
}
.fa-square-o:before {
  content: "\f096";
}
.fa-bookmark-o:before {
  content: "\f097";
}
.fa-phone-square:before {
  content: "\f098";
}
.fa-twitter:before {
  content: "\f099";
}
.fa-facebook:before {
  content: "\f09a";
}
.fa-github:before {
  content: "\f09b";
}
.fa-unlock:before {
  content: "\f09c";
}
.fa-credit-card:before {
  content: "\f09d";
}
.fa-rss:before {
  content: "\f09e";
}
.fa-hdd-o:before {
  content: "\f0a0";
}
.fa-bullhorn:before {
  content: "\f0a1";
}
.fa-bell:before {
  content: "\f0f3";
}
.fa-certificate:before {
  content: "\f0a3";
}
.fa-hand-o-right:before {
  content: "\f0a4";
}
.fa-hand-o-left:before {
  content: "\f0a5";
}
.fa-hand-o-up:before {
  content: "\f0a6";
}
.fa-hand-o-down:before {
  content: "\f0a7";
}
.fa-arrow-circle-left:before {
  content: "\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\f0aa";
}
.fa-arrow-circle-down:before {
  content: "\f0ab";
}
.fa-globe:before {
  content: "\f0ac";
}
.fa-wrench:before {
  content: "\f0ad";
}
.fa-tasks:before {
  content: "\f0ae";
}
.fa-filter:before {
  content: "\f0b0";
}
.fa-briefcase:before {
  content: "\f0b1";
}
.fa-arrows-alt:before {
  content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
  content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
  content: "\f0c1";
}
.fa-cloud:before {
  content: "\f0c2";
}
.fa-flask:before {
  content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
  content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
  content: "\f0c5";
}
.fa-paperclip:before {
  content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
  content: "\f0c7";
}
.fa-square:before {
  content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\f0c9";
}
.fa-list-ul:before {
  content: "\f0ca";
}
.fa-list-ol:before {
  content: "\f0cb";
}
.fa-strikethrough:before {
  content: "\f0cc";
}
.fa-underline:before {
  content: "\f0cd";
}
.fa-table:before {
  content: "\f0ce";
}
.fa-magic:before {
  content: "\f0d0";
}
.fa-truck:before {
  content: "\f0d1";
}
.fa-pinterest:before {
  content: "\f0d2";
}
.fa-pinterest-square:before {
  content: "\f0d3";
}
.fa-google-plus-square:before {
  content: "\f0d4";
}
.fa-google-plus:before {
  content: "\f0d5";
}
.fa-money:before {
  content: "\f0d6";
}
.fa-caret-down:before {
  content: "\f0d7";
}
.fa-caret-up:before {
  content: "\f0d8";
}
.fa-caret-left:before {
  content: "\f0d9";
}
.fa-caret-right:before {
  content: "\f0da";
}
.fa-columns:before {
  content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
  content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\f0de";
}
.fa-envelope:before {
  content: "\f0e0";
}
.fa-linkedin:before {
  content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
  content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
  content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
  content: "\f0e4";
}
.fa-comment-o:before {
  content: "\f0e5";
}
.fa-comments-o:before {
  content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
  content: "\f0e7";
}
.fa-sitemap:before {
  content: "\f0e8";
}
.fa-umbrella:before {
  content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
  content: "\f0ea";
}
.fa-lightbulb-o:before {
  content: "\f0eb";
}
.fa-exchange:before {
  content: "\f0ec";
}
.fa-cloud-download:before {
  content: "\f0ed";
}
.fa-cloud-upload:before {
  content: "\f0ee";
}
.fa-user-md:before {
  content: "\f0f0";
}
.fa-stethoscope:before {
  content: "\f0f1";
}
.fa-suitcase:before {
  content: "\f0f2";
}
.fa-bell-o:before {
  content: "\f0a2";
}
.fa-coffee:before {
  content: "\f0f4";
}
.fa-cutlery:before {
  content: "\f0f5";
}
.fa-file-text-o:before {
  content: "\f0f6";
}
.fa-building-o:before {
  content: "\f0f7";
}
.fa-hospital-o:before {
  content: "\f0f8";
}
.fa-ambulance:before {
  content: "\f0f9";
}
.fa-medkit:before {
  content: "\f0fa";
}
.fa-fighter-jet:before {
  content: "\f0fb";
}
.fa-beer:before {
  content: "\f0fc";
}
.fa-h-square:before {
  content: "\f0fd";
}
.fa-plus-square:before {
  content: "\f0fe";
}
.fa-angle-double-left:before {
  content: "\f100";
}
.fa-angle-double-right:before {
  content: "\f101";
}
.fa-angle-double-up:before {
  content: "\f102";
}
.fa-angle-double-down:before {
  content: "\f103";
}
.fa-angle-left:before {
  content: "\f104";
}
.fa-angle-right:before {
  content: "\f105";
}
.fa-angle-up:before {
  content: "\f106";
}
.fa-angle-down:before {
  content: "\f107";
}
.fa-desktop:before {
  content: "\f108";
}
.fa-laptop:before {
  content: "\f109";
}
.fa-tablet:before {
  content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\f10b";
}
.fa-circle-o:before {
  content: "\f10c";
}
.fa-quote-left:before {
  content: "\f10d";
}
.fa-quote-right:before {
  content: "\f10e";
}
.fa-spinner:before {
  content: "\f110";
}
.fa-circle:before {
  content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
  content: "\f112";
}
.fa-github-alt:before {
  content: "\f113";
}
.fa-folder-o:before {
  content: "\f114";
}
.fa-folder-open-o:before {
  content: "\f115";
}
.fa-smile-o:before {
  content: "\f118";
}
.fa-frown-o:before {
  content: "\f119";
}
.fa-meh-o:before {
  content: "\f11a";
}
.fa-gamepad:before {
  content: "\f11b";
}
.fa-keyboard-o:before {
  content: "\f11c";
}
.fa-flag-o:before {
  content: "\f11d";
}
.fa-flag-checkered:before {
  content: "\f11e";
}
.fa-terminal:before {
  content: "\f120";
}
.fa-code:before {
  content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\f123";
}
.fa-location-arrow:before {
  content: "\f124";
}
.fa-crop:before {
  content: "\f125";
}
.fa-code-fork:before {
  content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
  content: "\f127";
}
.fa-question:before {
  content: "\f128";
}
.fa-info:before {
  content: "\f129";
}
.fa-exclamation:before {
  content: "\f12a";
}
.fa-superscript:before {
  content: "\f12b";
}
.fa-subscript:before {
  content: "\f12c";
}
.fa-eraser:before {
  content: "\f12d";
}
.fa-puzzle-piece:before {
  content: "\f12e";
}
.fa-microphone:before {
  content: "\f130";
}
.fa-microphone-slash:before {
  content: "\f131";
}
.fa-shield:before {
  content: "\f132";
}
.fa-calendar-o:before {
  content: "\f133";
}
.fa-fire-extinguisher:before {
  content: "\f134";
}
.fa-rocket:before {
  content: "\f135";
}
.fa-maxcdn:before {
  content: "\f136";
}
.fa-chevron-circle-left:before {
  content: "\f137";
}
.fa-chevron-circle-right:before {
  content: "\f138";
}
.fa-chevron-circle-up:before {
  content: "\f139";
}
.fa-chevron-circle-down:before {
  content: "\f13a";
}
.fa-html5:before {
  content: "\f13b";
}
.fa-css3:before {
  content: "\f13c";
}
.fa-anchor:before {
  content: "\f13d";
}
.fa-unlock-alt:before {
  content: "\f13e";
}
.fa-bullseye:before {
  content: "\f140";
}
.fa-ellipsis-h:before {
  content: "\f141";
}
.fa-ellipsis-v:before {
  content: "\f142";
}
.fa-rss-square:before {
  content: "\f143";
}
.fa-play-circle:before {
  content: "\f144";
}
.fa-ticket:before {
  content: "\f145";
}
.fa-minus-square:before {
  content: "\f146";
}
.fa-minus-square-o:before {
  content: "\f147";
}
.fa-level-up:before {
  content: "\f148";
}
.fa-level-down:before {
  content: "\f149";
}
.fa-check-square:before {
  content: "\f14a";
}
.fa-pencil-square:before {
  content: "\f14b";
}
.fa-external-link-square:before {
  content: "\f14c";
}
.fa-share-square:before {
  content: "\f14d";
}
.fa-compass:before {
  content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
  content: "\f153";
}
.fa-gbp:before {
  content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
  content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
  content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\f158";
}
.fa-won:before,
.fa-krw:before {
  content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
  content: "\f15a";
}
.fa-file:before {
  content: "\f15b";
}
.fa-file-text:before {
  content: "\f15c";
}
.fa-sort-alpha-asc:before {
  content: "\f15d";
}
.fa-sort-alpha-desc:before {
  content: "\f15e";
}
.fa-sort-amount-asc:before {
  content: "\f160";
}
.fa-sort-amount-desc:before {
  content: "\f161";
}
.fa-sort-numeric-asc:before {
  content: "\f162";
}
.fa-sort-numeric-desc:before {
  content: "\f163";
}
.fa-thumbs-up:before {
  content: "\f164";
}
.fa-thumbs-down:before {
  content: "\f165";
}
.fa-youtube-square:before {
  content: "\f166";
}
.fa-youtube:before {
  content: "\f167";
}
.fa-xing:before {
  content: "\f168";
}
.fa-xing-square:before {
  content: "\f169";
}
.fa-youtube-play:before {
  content: "\f16a";
}
.fa-dropbox:before {
  content: "\f16b";
}
.fa-stack-overflow:before {
  content: "\f16c";
}
.fa-instagram:before {
  content: "\f16d";
}
.fa-flickr:before {
  content: "\f16e";
}
.fa-adn:before {
  content: "\f170";
}
.fa-bitbucket:before {
  content: "\f171";
}
.fa-bitbucket-square:before {
  content: "\f172";
}
.fa-tumblr:before {
  content: "\f173";
}
.fa-tumblr-square:before {
  content: "\f174";
}
.fa-long-arrow-down:before {
  content: "\f175";
}
.fa-long-arrow-up:before {
  content: "\f176";
}
.fa-long-arrow-left:before {
  content: "\f177";
}
.fa-long-arrow-right:before {
  content: "\f178";
}
.fa-apple:before {
  content: "\f179";
}
.fa-windows:before {
  content: "\f17a";
}
.fa-android:before {
  content: "\f17b";
}
.fa-linux:before {
  content: "\f17c";
}
.fa-dribbble:before {
  content: "\f17d";
}
.fa-skype:before {
  content: "\f17e";
}
.fa-foursquare:before {
  content: "\f180";
}
.fa-trello:before {
  content: "\f181";
}
.fa-female:before {
  content: "\f182";
}
.fa-male:before {
  content: "\f183";
}
.fa-gittip:before {
  content: "\f184";
}
.fa-sun-o:before {
  content: "\f185";
}
.fa-moon-o:before {
  content: "\f186";
}
.fa-archive:before {
  content: "\f187";
}
.fa-bug:before {
  content: "\f188";
}
.fa-vk:before {
  content: "\f189";
}
.fa-weibo:before {
  content: "\f18a";
}
.fa-renren:before {
  content: "\f18b";
}
.fa-pagelines:before {
  content: "\f18c";
}
.fa-stack-exchange:before {
  content: "\f18d";
}
.fa-arrow-circle-o-right:before {
  content: "\f18e";
}
.fa-arrow-circle-o-left:before {
  content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\f191";
}
.fa-dot-circle-o:before {
  content: "\f192";
}
.fa-wheelchair:before {
  content: "\f193";
}
.fa-vimeo-square:before {
  content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
  content: "\f195";
}
.fa-plus-square-o:before {
  content: "\f196";
}
.fa-space-shuttle:before {
  content: "\f197";
}
.fa-slack:before {
  content: "\f198";
}
.fa-envelope-square:before {
  content: "\f199";
}
.fa-wordpress:before {
  content: "\f19a";
}
.fa-openid:before {
  content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\f19d";
}
.fa-yahoo:before {
  content: "\f19e";
}
.fa-google:before {
  content: "\f1a0";
}
.fa-reddit:before {
  content: "\f1a1";
}
.fa-reddit-square:before {
  content: "\f1a2";
}
.fa-stumbleupon-circle:before {
  content: "\f1a3";
}
.fa-stumbleupon:before {
  content: "\f1a4";
}
.fa-delicious:before {
  content: "\f1a5";
}
.fa-digg:before {
  content: "\f1a6";
}
.fa-pied-piper:before {
  content: "\f1a7";
}
.fa-pied-piper-alt:before {
  content: "\f1a8";
}
.fa-drupal:before {
  content: "\f1a9";
}
.fa-joomla:before {
  content: "\f1aa";
}
.fa-language:before {
  content: "\f1ab";
}
.fa-fax:before {
  content: "\f1ac";
}
.fa-building:before {
  content: "\f1ad";
}
.fa-child:before {
  content: "\f1ae";
}
.fa-paw:before {
  content: "\f1b0";
}
.fa-spoon:before {
  content: "\f1b1";
}
.fa-cube:before {
  content: "\f1b2";
}
.fa-cubes:before {
  content: "\f1b3";
}
.fa-behance:before {
  content: "\f1b4";
}
.fa-behance-square:before {
  content: "\f1b5";
}
.fa-steam:before {
  content: "\f1b6";
}
.fa-steam-square:before {
  content: "\f1b7";
}
.fa-recycle:before {
  content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
  content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
  content: "\f1ba";
}
.fa-tree:before {
  content: "\f1bb";
}
.fa-spotify:before {
  content: "\f1bc";
}
.fa-deviantart:before {
  content: "\f1bd";
}
.fa-soundcloud:before {
  content: "\f1be";
}
.fa-database:before {
  content: "\f1c0";
}
.fa-file-pdf-o:before {
  content: "\f1c1";
}
.fa-file-word-o:before {
  content: "\f1c2";
}
.fa-file-excel-o:before {
  content: "\f1c3";
}
.fa-file-powerpoint-o:before {
  content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\f1c8";
}
.fa-file-code-o:before {
  content: "\f1c9";
}
.fa-vine:before {
  content: "\f1ca";
}
.fa-codepen:before {
  content: "\f1cb";
}
.fa-jsfiddle:before {
  content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-buoy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\f1cd";
}
.fa-circle-o-notch:before {
  content: "\f1ce";
}
.fa-ra:before,
.fa-rebel:before {
  content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
  content: "\f1d1";
}
.fa-git-square:before {
  content: "\f1d2";
}
.fa-git:before {
  content: "\f1d3";
}
.fa-hacker-news:before {
  content: "\f1d4";
}
.fa-tencent-weibo:before {
  content: "\f1d5";
}
.fa-qq:before {
  content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
  content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
  content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\f1d9";
}
.fa-history:before {
  content: "\f1da";
}
.fa-circle-thin:before {
  content: "\f1db";
}
.fa-header:before {
  content: "\f1dc";
}
.fa-paragraph:before {
  content: "\f1dd";
}
.fa-sliders:before {
  content: "\f1de";
}
.fa-share-alt:before {
  content: "\f1e0";
}
.fa-share-alt-square:before {
  content: "\f1e1";
}
.fa-bomb:before {
  content: "\f1e2";
}
.fa-soccer-ball-o:before,
.fa-futbol-o:before {
  content: "\f1e3";
}
.fa-tty:before {
  content: "\f1e4";
}
.fa-binoculars:before {
  content: "\f1e5";
}
.fa-plug:before {
  content: "\f1e6";
}
.fa-slideshare:before {
  content: "\f1e7";
}
.fa-twitch:before {
  content: "\f1e8";
}
.fa-yelp:before {
  content: "\f1e9";
}
.fa-newspaper-o:before {
  content: "\f1ea";
}
.fa-wifi:before {
  content: "\f1eb";
}
.fa-calculator:before {
  content: "\f1ec";
}
.fa-paypal:before {
  content: "\f1ed";
}
.fa-google-wallet:before {
  content: "\f1ee";
}
.fa-cc-visa:before {
  content: "\f1f0";
}
.fa-cc-mastercard:before {
  content: "\f1f1";
}
.fa-cc-discover:before {
  content: "\f1f2";
}
.fa-cc-amex:before {
  content: "\f1f3";
}
.fa-cc-paypal:before {
  content: "\f1f4";
}
.fa-cc-stripe:before {
  content: "\f1f5";
}
.fa-bell-slash:before {
  content: "\f1f6";
}
.fa-bell-slash-o:before {
  content: "\f1f7";
}
.fa-trash:before {
  content: "\f1f8";
}
.fa-copyright:before {
  content: "\f1f9";
}
.fa-at:before {
  content: "\f1fa";
}
.fa-eyedropper:before {
  content: "\f1fb";
}
.fa-paint-brush:before {
  content: "\f1fc";
}
.fa-birthday-cake:before {
  content: "\f1fd";
}
.fa-area-chart:before {
  content: "\f1fe";
}
.fa-pie-chart:before {
  content: "\f200";
}
.fa-line-chart:before {
  content: "\f201";
}
.fa-lastfm:before {
  content: "\f202";
}
.fa-lastfm-square:before {
  content: "\f203";
}
.fa-toggle-off:before {
  content: "\f204";
}
.fa-toggle-on:before {
  content: "\f205";
}
.fa-bicycle:before {
  content: "\f206";
}
.fa-bus:before {
  content: "\f207";
}
.fa-ioxhost:before {
  content: "\f208";
}
.fa-angellist:before {
  content: "\f209";
}
.fa-cc:before {
  content: "\f20a";
}
.fa-shekel:before,
.fa-sheqel:before,
.fa-ils:before {
  content: "\f20b";
}
.fa-meanpath:before {
  content: "\f20c";
}
/*!
*
* IPython base
*
*/
.modal.fade .modal-dialog {
  -webkit-transform: translate(0, 0);
  -ms-transform: translate(0, 0);
  -o-transform: translate(0, 0);
  transform: translate(0, 0);
}
code {
  color: #000;
}
pre {
  font-size: inherit;
  line-height: inherit;
}
label {
  font-weight: normal;
}
/* Make the page background atleast 100% the height of the view port */
/* Make the page itself atleast 70% the height of the view port */
.border-box-sizing {
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
.corner-all {
  border-radius: 2px;
}
.no-padding {
  padding: 0px;
}
/* Flexible box model classes */
/* Taken from Alex Russell http://infrequently.org/2009/08/css-3-progress/ */
/* This file is a compatability layer.  It allows the usage of flexible box 
model layouts accross multiple browsers, including older browsers.  The newest,
universal implementation of the flexible box model is used when available (see
`Modern browsers` comments below).  Browsers that are known to implement this 
new spec completely include:

    Firefox 28.0+
    Chrome 29.0+
    Internet Explorer 11+ 
    Opera 17.0+

Browsers not listed, including Safari, are supported via the styling under the
`Old browsers` comments below.
*/
.hbox {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
.hbox > * {
  /* Old browsers */
  -webkit-box-flex: 0;
  -moz-box-flex: 0;
  box-flex: 0;
  /* Modern browsers */
  flex: none;
}
.vbox {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
.vbox > * {
  /* Old browsers */
  -webkit-box-flex: 0;
  -moz-box-flex: 0;
  box-flex: 0;
  /* Modern browsers */
  flex: none;
}
.hbox.reverse,
.vbox.reverse,
.reverse {
  /* Old browsers */
  -webkit-box-direction: reverse;
  -moz-box-direction: reverse;
  box-direction: reverse;
  /* Modern browsers */
  flex-direction: row-reverse;
}
.hbox.box-flex0,
.vbox.box-flex0,
.box-flex0 {
  /* Old browsers */
  -webkit-box-flex: 0;
  -moz-box-flex: 0;
  box-flex: 0;
  /* Modern browsers */
  flex: none;
  width: auto;
}
.hbox.box-flex1,
.vbox.box-flex1,
.box-flex1 {
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
.hbox.box-flex,
.vbox.box-flex,
.box-flex {
  /* Old browsers */
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
.hbox.box-flex2,
.vbox.box-flex2,
.box-flex2 {
  /* Old browsers */
  -webkit-box-flex: 2;
  -moz-box-flex: 2;
  box-flex: 2;
  /* Modern browsers */
  flex: 2;
}
.box-group1 {
  /*  Deprecated */
  -webkit-box-flex-group: 1;
  -moz-box-flex-group: 1;
  box-flex-group: 1;
}
.box-group2 {
  /* Deprecated */
  -webkit-box-flex-group: 2;
  -moz-box-flex-group: 2;
  box-flex-group: 2;
}
.hbox.start,
.vbox.start,
.start {
  /* Old browsers */
  -webkit-box-pack: start;
  -moz-box-pack: start;
  box-pack: start;
  /* Modern browsers */
  justify-content: flex-start;
}
.hbox.end,
.vbox.end,
.end {
  /* Old browsers */
  -webkit-box-pack: end;
  -moz-box-pack: end;
  box-pack: end;
  /* Modern browsers */
  justify-content: flex-end;
}
.hbox.center,
.vbox.center,
.center {
  /* Old browsers */
  -webkit-box-pack: center;
  -moz-box-pack: center;
  box-pack: center;
  /* Modern browsers */
  justify-content: center;
}
.hbox.baseline,
.vbox.baseline,
.baseline {
  /* Old browsers */
  -webkit-box-pack: baseline;
  -moz-box-pack: baseline;
  box-pack: baseline;
  /* Modern browsers */
  justify-content: baseline;
}
.hbox.stretch,
.vbox.stretch,
.stretch {
  /* Old browsers */
  -webkit-box-pack: stretch;
  -moz-box-pack: stretch;
  box-pack: stretch;
  /* Modern browsers */
  justify-content: stretch;
}
.hbox.align-start,
.vbox.align-start,
.align-start {
  /* Old browsers */
  -webkit-box-align: start;
  -moz-box-align: start;
  box-align: start;
  /* Modern browsers */
  align-items: flex-start;
}
.hbox.align-end,
.vbox.align-end,
.align-end {
  /* Old browsers */
  -webkit-box-align: end;
  -moz-box-align: end;
  box-align: end;
  /* Modern browsers */
  align-items: flex-end;
}
.hbox.align-center,
.vbox.align-center,
.align-center {
  /* Old browsers */
  -webkit-box-align: center;
  -moz-box-align: center;
  box-align: center;
  /* Modern browsers */
  align-items: center;
}
.hbox.align-baseline,
.vbox.align-baseline,
.align-baseline {
  /* Old browsers */
  -webkit-box-align: baseline;
  -moz-box-align: baseline;
  box-align: baseline;
  /* Modern browsers */
  align-items: baseline;
}
.hbox.align-stretch,
.vbox.align-stretch,
.align-stretch {
  /* Old browsers */
  -webkit-box-align: stretch;
  -moz-box-align: stretch;
  box-align: stretch;
  /* Modern browsers */
  align-items: stretch;
}
div.error {
  margin: 2em;
  text-align: center;
}
div.error > h1 {
  font-size: 500%;
  line-height: normal;
}
div.error > p {
  font-size: 200%;
  line-height: normal;
}
div.traceback-wrapper {
  text-align: left;
  max-width: 800px;
  margin: auto;
}
/**
 * Primary styles
 *
 * Author: Jupyter Development Team
 */
body {
  background-color: #fff;
  /* This makes sure that the body covers the entire window and needs to
       be in a different element than the display: box in wrapper below */
  position: absolute;
  left: 0px;
  right: 0px;
  top: 0px;
  bottom: 0px;
  overflow: visible;
}
body > #header {
  /* Initially hidden to prevent FLOUC */
  display: none;
  background-color: #fff;
  /* Display over codemirror */
  position: relative;
  z-index: 100;
}
body > #header #header-container {
  padding-bottom: 5px;
  padding-top: 5px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
body > #header .header-bar {
  width: 100%;
  height: 1px;
  background: #e7e7e7;
  margin-bottom: -1px;
}
@media print {
  body > #header {
    display: none !important;
  }
}
#header-spacer {
  width: 100%;
  visibility: hidden;
}
@media print {
  #header-spacer {
    display: none;
  }
}
#ipython_notebook {
  padding-left: 0px;
  padding-top: 1px;
  padding-bottom: 1px;
}
@media (max-width: 991px) {
  #ipython_notebook {
    margin-left: 10px;
  }
}
[dir="rtl"] #ipython_notebook {
  float: right !important;
}
#noscript {
  width: auto;
  padding-top: 16px;
  padding-bottom: 16px;
  text-align: center;
  font-size: 22px;
  color: red;
  font-weight: bold;
}
#ipython_notebook img {
  height: 28px;
}
#site {
  width: 100%;
  display: none;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  overflow: auto;
}
@media print {
  #site {
    height: auto !important;
  }
}
/* Smaller buttons */
.ui-button .ui-button-text {
  padding: 0.2em 0.8em;
  font-size: 77%;
}
input.ui-button {
  padding: 0.3em 0.9em;
}
span#login_widget {
  float: right;
}
span#login_widget > .button,
#logout {
  color: #333;
  background-color: #fff;
  border-color: #ccc;
}
span#login_widget > .button:focus,
#logout:focus,
span#login_widget > .button.focus,
#logout.focus {
  color: #333;
  background-color: #e6e6e6;
  border-color: #8c8c8c;
}
span#login_widget > .button:hover,
#logout:hover {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
span#login_widget > .button:active,
#logout:active,
span#login_widget > .button.active,
#logout.active,
.open > .dropdown-togglespan#login_widget > .button,
.open > .dropdown-toggle#logout {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
span#login_widget > .button:active:hover,
#logout:active:hover,
span#login_widget > .button.active:hover,
#logout.active:hover,
.open > .dropdown-togglespan#login_widget > .button:hover,
.open > .dropdown-toggle#logout:hover,
span#login_widget > .button:active:focus,
#logout:active:focus,
span#login_widget > .button.active:focus,
#logout.active:focus,
.open > .dropdown-togglespan#login_widget > .button:focus,
.open > .dropdown-toggle#logout:focus,
span#login_widget > .button:active.focus,
#logout:active.focus,
span#login_widget > .button.active.focus,
#logout.active.focus,
.open > .dropdown-togglespan#login_widget > .button.focus,
.open > .dropdown-toggle#logout.focus {
  color: #333;
  background-color: #d4d4d4;
  border-color: #8c8c8c;
}
span#login_widget > .button:active,
#logout:active,
span#login_widget > .button.active,
#logout.active,
.open > .dropdown-togglespan#login_widget > .button,
.open > .dropdown-toggle#logout {
  background-image: none;
}
span#login_widget > .button.disabled:hover,
#logout.disabled:hover,
span#login_widget > .button[disabled]:hover,
#logout[disabled]:hover,
fieldset[disabled] span#login_widget > .button:hover,
fieldset[disabled] #logout:hover,
span#login_widget > .button.disabled:focus,
#logout.disabled:focus,
span#login_widget > .button[disabled]:focus,
#logout[disabled]:focus,
fieldset[disabled] span#login_widget > .button:focus,
fieldset[disabled] #logout:focus,
span#login_widget > .button.disabled.focus,
#logout.disabled.focus,
span#login_widget > .button[disabled].focus,
#logout[disabled].focus,
fieldset[disabled] span#login_widget > .button.focus,
fieldset[disabled] #logout.focus {
  background-color: #fff;
  border-color: #ccc;
}
span#login_widget > .button .badge,
#logout .badge {
  color: #fff;
  background-color: #333;
}
.nav-header {
  text-transform: none;
}
#header > span {
  margin-top: 10px;
}
.modal_stretch .modal-dialog {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  min-height: 80vh;
}
.modal_stretch .modal-dialog .modal-body {
  max-height: calc(100vh - 200px);
  overflow: auto;
  flex: 1;
}
@media (min-width: 768px) {
  .modal .modal-dialog {
    width: 700px;
  }
}
@media (min-width: 768px) {
  select.form-control {
    margin-left: 12px;
    margin-right: 12px;
  }
}
/*!
*
* IPython auth
*
*/
.center-nav {
  display: inline-block;
  margin-bottom: -4px;
}
/*!
*
* IPython tree view
*
*/
/* We need an invisible input field on top of the sentense*/
/* "Drag file onto the list ..." */
.alternate_upload {
  background-color: none;
  display: inline;
}
.alternate_upload.form {
  padding: 0;
  margin: 0;
}
.alternate_upload input.fileinput {
  text-align: center;
  vertical-align: middle;
  display: inline;
  opacity: 0;
  z-index: 2;
  width: 12ex;
  margin-right: -12ex;
}
.alternate_upload .btn-upload {
  height: 22px;
}
/**
 * Primary styles
 *
 * Author: Jupyter Development Team
 */
[dir="rtl"] #tabs li {
  float: right;
}
ul#tabs {
  margin-bottom: 4px;
}
[dir="rtl"] ul#tabs {
  margin-right: 0px;
}
ul#tabs a {
  padding-top: 6px;
  padding-bottom: 4px;
}
ul.breadcrumb a:focus,
ul.breadcrumb a:hover {
  text-decoration: none;
}
ul.breadcrumb i.icon-home {
  font-size: 16px;
  margin-right: 4px;
}
ul.breadcrumb span {
  color: #5e5e5e;
}
.list_toolbar {
  padding: 4px 0 4px 0;
  vertical-align: middle;
}
.list_toolbar .tree-buttons {
  padding-top: 1px;
}
[dir="rtl"] .list_toolbar .tree-buttons {
  float: left !important;
}
[dir="rtl"] .list_toolbar .pull-right {
  padding-top: 1px;
  float: left !important;
}
[dir="rtl"] .list_toolbar .pull-left {
  float: right !important;
}
.dynamic-buttons {
  padding-top: 3px;
  display: inline-block;
}
.list_toolbar [class*="span"] {
  min-height: 24px;
}
.list_header {
  font-weight: bold;
  background-color: #EEE;
}
.list_placeholder {
  font-weight: bold;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 7px;
  padding-right: 7px;
}
.list_container {
  margin-top: 4px;
  margin-bottom: 20px;
  border: 1px solid #ddd;
  border-radius: 2px;
}
.list_container > div {
  border-bottom: 1px solid #ddd;
}
.list_container > div:hover .list-item {
  background-color: red;
}
.list_container > div:last-child {
  border: none;
}
.list_item:hover .list_item {
  background-color: #ddd;
}
.list_item a {
  text-decoration: none;
}
.list_item:hover {
  background-color: #fafafa;
}
.list_header > div,
.list_item > div {
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 7px;
  padding-right: 7px;
  line-height: 22px;
}
.list_header > div input,
.list_item > div input {
  margin-right: 7px;
  margin-left: 14px;
  vertical-align: baseline;
  line-height: 22px;
  position: relative;
  top: -1px;
}
.list_header > div .item_link,
.list_item > div .item_link {
  margin-left: -1px;
  vertical-align: baseline;
  line-height: 22px;
}
.new-file input[type=checkbox] {
  visibility: hidden;
}
.item_name {
  line-height: 22px;
  height: 24px;
}
.item_icon {
  font-size: 14px;
  color: #5e5e5e;
  margin-right: 7px;
  margin-left: 7px;
  line-height: 22px;
  vertical-align: baseline;
}
.item_buttons {
  line-height: 1em;
  margin-left: -5px;
}
.item_buttons .btn,
.item_buttons .btn-group,
.item_buttons .input-group {
  float: left;
}
.item_buttons > .btn,
.item_buttons > .btn-group,
.item_buttons > .input-group {
  margin-left: 5px;
}
.item_buttons .btn {
  min-width: 13ex;
}
.item_buttons .running-indicator {
  padding-top: 4px;
  color: #5cb85c;
}
.item_buttons .kernel-name {
  padding-top: 4px;
  color: #5bc0de;
  margin-right: 7px;
  float: left;
}
.toolbar_info {
  height: 24px;
  line-height: 24px;
}
.list_item input:not([type=checkbox]) {
  padding-top: 3px;
  padding-bottom: 3px;
  height: 22px;
  line-height: 14px;
  margin: 0px;
}
.highlight_text {
  color: blue;
}
#project_name {
  display: inline-block;
  padding-left: 7px;
  margin-left: -2px;
}
#project_name > .breadcrumb {
  padding: 0px;
  margin-bottom: 0px;
  background-color: transparent;
  font-weight: bold;
}
#tree-selector {
  padding-right: 0px;
}
[dir="rtl"] #tree-selector a {
  float: right;
}
#button-select-all {
  min-width: 50px;
}
#select-all {
  margin-left: 7px;
  margin-right: 2px;
}
.menu_icon {
  margin-right: 2px;
}
.tab-content .row {
  margin-left: 0px;
  margin-right: 0px;
}
.folder_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f114";
}
.folder_icon:before.pull-left {
  margin-right: .3em;
}
.folder_icon:before.pull-right {
  margin-left: .3em;
}
.notebook_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f02d";
  position: relative;
  top: -1px;
}
.notebook_icon:before.pull-left {
  margin-right: .3em;
}
.notebook_icon:before.pull-right {
  margin-left: .3em;
}
.running_notebook_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f02d";
  position: relative;
  top: -1px;
  color: #5cb85c;
}
.running_notebook_icon:before.pull-left {
  margin-right: .3em;
}
.running_notebook_icon:before.pull-right {
  margin-left: .3em;
}
.file_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f016";
  position: relative;
  top: -2px;
}
.file_icon:before.pull-left {
  margin-right: .3em;
}
.file_icon:before.pull-right {
  margin-left: .3em;
}
#notebook_toolbar .pull-right {
  padding-top: 0px;
  margin-right: -1px;
}
ul#new-menu {
  left: auto;
  right: 0;
}
[dir="rtl"] #new-menu {
  text-align: right;
}
.kernel-menu-icon {
  padding-right: 12px;
  width: 24px;
  content: "\f096";
}
.kernel-menu-icon:before {
  content: "\f096";
}
.kernel-menu-icon-current:before {
  content: "\f00c";
}
#tab_content {
  padding-top: 20px;
}
#running .panel-group .panel {
  margin-top: 3px;
  margin-bottom: 1em;
}
#running .panel-group .panel .panel-heading {
  background-color: #EEE;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 7px;
  padding-right: 7px;
  line-height: 22px;
}
#running .panel-group .panel .panel-heading a:focus,
#running .panel-group .panel .panel-heading a:hover {
  text-decoration: none;
}
#running .panel-group .panel .panel-body {
  padding: 0px;
}
#running .panel-group .panel .panel-body .list_container {
  margin-top: 0px;
  margin-bottom: 0px;
  border: 0px;
  border-radius: 0px;
}
#running .panel-group .panel .panel-body .list_container .list_item {
  border-bottom: 1px solid #ddd;
}
#running .panel-group .panel .panel-body .list_container .list_item:last-child {
  border-bottom: 0px;
}
[dir="rtl"] #running .col-sm-8 {
  float: right !important;
}
.delete-button {
  display: none;
}
.duplicate-button {
  display: none;
}
.rename-button {
  display: none;
}
.shutdown-button {
  display: none;
}
.dynamic-instructions {
  display: inline-block;
  padding-top: 4px;
}
/*!
*
* IPython text editor webapp
*
*/
.selected-keymap i.fa {
  padding: 0px 5px;
}
.selected-keymap i.fa:before {
  content: "\f00c";
}
#mode-menu {
  overflow: auto;
  max-height: 20em;
}
.edit_app #header {
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
}
.edit_app #menubar .navbar {
  /* Use a negative 1 bottom margin, so the border overlaps the border of the
    header */
  margin-bottom: -1px;
}
.dirty-indicator {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  width: 20px;
}
.dirty-indicator.pull-left {
  margin-right: .3em;
}
.dirty-indicator.pull-right {
  margin-left: .3em;
}
.dirty-indicator-dirty {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  width: 20px;
}
.dirty-indicator-dirty.pull-left {
  margin-right: .3em;
}
.dirty-indicator-dirty.pull-right {
  margin-left: .3em;
}
.dirty-indicator-clean {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  width: 20px;
}
.dirty-indicator-clean.pull-left {
  margin-right: .3em;
}
.dirty-indicator-clean.pull-right {
  margin-left: .3em;
}
.dirty-indicator-clean:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f00c";
}
.dirty-indicator-clean:before.pull-left {
  margin-right: .3em;
}
.dirty-indicator-clean:before.pull-right {
  margin-left: .3em;
}
#filename {
  font-size: 16pt;
  display: table;
  padding: 0px 5px;
}
#current-mode {
  padding-left: 5px;
  padding-right: 5px;
}
#texteditor-backdrop {
  padding-top: 20px;
  padding-bottom: 20px;
}
@media not print {
  #texteditor-backdrop {
    background-color: #EEE;
  }
}
@media print {
  #texteditor-backdrop #texteditor-container .CodeMirror-gutter,
  #texteditor-backdrop #texteditor-container .CodeMirror-gutters {
    background-color: #fff;
  }
}
@media not print {
  #texteditor-backdrop #texteditor-container .CodeMirror-gutter,
  #texteditor-backdrop #texteditor-container .CodeMirror-gutters {
    background-color: #fff;
  }
}
@media not print {
  #texteditor-backdrop #texteditor-container {
    padding: 0px;
    background-color: #fff;
    -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
    box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  }
}
/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI colors. */
.ansibold {
  font-weight: bold;
}
/* use dark versions for foreground, to improve visibility */
.ansiblack {
  color: black;
}
.ansired {
  color: darkred;
}
.ansigreen {
  color: darkgreen;
}
.ansiyellow {
  color: #c4a000;
}
.ansiblue {
  color: darkblue;
}
.ansipurple {
  color: darkviolet;
}
.ansicyan {
  color: steelblue;
}
.ansigray {
  color: gray;
}
/* and light for background, for the same reason */
.ansibgblack {
  background-color: black;
}
.ansibgred {
  background-color: red;
}
.ansibggreen {
  background-color: green;
}
.ansibgyellow {
  background-color: yellow;
}
.ansibgblue {
  background-color: blue;
}
.ansibgpurple {
  background-color: magenta;
}
.ansibgcyan {
  background-color: cyan;
}
.ansibggray {
  background-color: gray;
}
div.cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  border-radius: 2px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  width: 100%;
  padding: 5px;
  /* This acts as a spacer between cells, that is outside the border */
  margin: 0px;
  outline: none;
  border-left-width: 1px;
  padding-left: 5px;
  background: linear-gradient(to right, transparent -40px, transparent 1px, transparent 1px, transparent 100%);
}
div.cell.jupyter-soft-selected {
  border-left-color: #90CAF9;
  border-left-color: #E3F2FD;
  border-left-width: 1px;
  padding-left: 5px;
  border-right-color: #E3F2FD;
  border-right-width: 1px;
  background: #E3F2FD;
}
@media print {
  div.cell.jupyter-soft-selected {
    border-color: transparent;
  }
}
div.cell.selected {
  border-color: #ababab;
  border-left-width: 0px;
  padding-left: 6px;
  background: linear-gradient(to right, #42A5F5 -40px, #42A5F5 5px, transparent 5px, transparent 100%);
}
@media print {
  div.cell.selected {
    border-color: transparent;
  }
}
div.cell.selected.jupyter-soft-selected {
  border-left-width: 0;
  padding-left: 6px;
  background: linear-gradient(to right, #42A5F5 -40px, #42A5F5 7px, #E3F2FD 7px, #E3F2FD 100%);
}
.edit_mode div.cell.selected {
  border-color: #66BB6A;
  border-left-width: 0px;
  padding-left: 6px;
  background: linear-gradient(to right, #66BB6A -40px, #66BB6A 5px, transparent 5px, transparent 100%);
}
@media print {
  .edit_mode div.cell.selected {
    border-color: transparent;
  }
}
.prompt {
  /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */
  min-width: 14ex;
  /* This padding is tuned to match the padding on the CodeMirror editor. */
  padding: 0.4em;
  margin: 0px;
  font-family: monospace;
  text-align: right;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
  /* Don't highlight prompt number selection */
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  /* Use default cursor */
  cursor: default;
}
@media (max-width: 540px) {
  .prompt {
    text-align: left;
  }
}
div.inner_cell {
  min-width: 0;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_area {
  border: 1px solid #cfcfcf;
  border-radius: 2px;
  background: #f7f7f7;
  line-height: 1.21429em;
}
/* This is needed so that empty prompt areas can collapse to zero height when there
   is no content in the output_subarea and the prompt. The main purpose of this is
   to make sure that empty JavaScript output_subareas have no height. */
div.prompt:empty {
  padding-top: 0;
  padding-bottom: 0;
}
div.unrecognized_cell {
  padding: 5px 5px 5px 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.unrecognized_cell .inner_cell {
  border-radius: 2px;
  padding: 5px;
  font-weight: bold;
  color: red;
  border: 1px solid #cfcfcf;
  background: #eaeaea;
}
div.unrecognized_cell .inner_cell a {
  color: inherit;
  text-decoration: none;
}
div.unrecognized_cell .inner_cell a:hover {
  color: inherit;
  text-decoration: none;
}
@media (max-width: 540px) {
  div.unrecognized_cell > div.prompt {
    display: none;
  }
}
div.code_cell {
  /* avoid page breaking on code cells when printing */
}
@media print {
  div.code_cell {
    page-break-inside: avoid;
  }
}
/* any special styling for code cells that are currently running goes here */
div.input {
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.input {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_prompt {
  color: #303F9F;
  border-top: 1px solid transparent;
}
div.input_area > div.highlight {
  margin: 0.4em;
  border: none;
  padding: 0px;
  background-color: transparent;
}
div.input_area > div.highlight > pre {
  margin: 0px;
  border: none;
  padding: 0px;
  background-color: transparent;
}
/* The following gets added to the <head> if it is detected that the user has a
 * monospace font with inconsistent normal/bold/italic height.  See
 * notebookmain.js.  Such fonts will have keywords vertically offset with
 * respect to the rest of the text.  The user should select a better font.
 * See: https://github.com/ipython/ipython/issues/1503
 *
 * .CodeMirror span {
 *      vertical-align: bottom;
 * }
 */
.CodeMirror {
  line-height: 1.21429em;
  /* Changed from 1em to our global default */
  font-size: 14px;
  height: auto;
  /* Changed to auto to autogrow */
  background: none;
  /* Changed from white to allow our bg to show through */
}
.CodeMirror-scroll {
  /*  The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/
  /*  We have found that if it is visible, vertical scrollbars appear with font size changes.*/
  overflow-y: hidden;
  overflow-x: auto;
}
.CodeMirror-lines {
  /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */
  /* we have set a different line-height and want this to scale with that. */
  padding: 0.4em;
}
.CodeMirror-linenumber {
  padding: 0 8px 0 4px;
}
.CodeMirror-gutters {
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.CodeMirror pre {
  /* In CM3 this went to 4px from 0 in CM2. We need the 0 value because of how we size */
  /* .CodeMirror-lines */
  padding: 0;
  border: 0;
  border-radius: 0;
}
/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org>
Adapted from GitHub theme

*/
.highlight-base {
  color: #000;
}
.highlight-variable {
  color: #000;
}
.highlight-variable-2 {
  color: #1a1a1a;
}
.highlight-variable-3 {
  color: #333333;
}
.highlight-string {
  color: #BA2121;
}
.highlight-comment {
  color: #408080;
  font-style: italic;
}
.highlight-number {
  color: #080;
}
.highlight-atom {
  color: #88F;
}
.highlight-keyword {
  color: #008000;
  font-weight: bold;
}
.highlight-builtin {
  color: #008000;
}
.highlight-error {
  color: #f00;
}
.highlight-operator {
  color: #AA22FF;
  font-weight: bold;
}
.highlight-meta {
  color: #AA22FF;
}
/* previously not defined, copying from default codemirror */
.highlight-def {
  color: #00f;
}
.highlight-string-2 {
  color: #f50;
}
.highlight-qualifier {
  color: #555;
}
.highlight-bracket {
  color: #997;
}
.highlight-tag {
  color: #170;
}
.highlight-attribute {
  color: #00c;
}
.highlight-header {
  color: blue;
}
.highlight-quote {
  color: #090;
}
.highlight-link {
  color: #00c;
}
/* apply the same style to codemirror */
.cm-s-ipython span.cm-keyword {
  color: #008000;
  font-weight: bold;
}
.cm-s-ipython span.cm-atom {
  color: #88F;
}
.cm-s-ipython span.cm-number {
  color: #080;
}
.cm-s-ipython span.cm-def {
  color: #00f;
}
.cm-s-ipython span.cm-variable {
  color: #000;
}
.cm-s-ipython span.cm-operator {
  color: #AA22FF;
  font-weight: bold;
}
.cm-s-ipython span.cm-variable-2 {
  color: #1a1a1a;
}
.cm-s-ipython span.cm-variable-3 {
  color: #333333;
}
.cm-s-ipython span.cm-comment {
  color: #408080;
  font-style: italic;
}
.cm-s-ipython span.cm-string {
  color: #BA2121;
}
.cm-s-ipython span.cm-string-2 {
  color: #f50;
}
.cm-s-ipython span.cm-meta {
  color: #AA22FF;
}
.cm-s-ipython span.cm-qualifier {
  color: #555;
}
.cm-s-ipython span.cm-builtin {
  color: #008000;
}
.cm-s-ipython span.cm-bracket {
  color: #997;
}
.cm-s-ipython span.cm-tag {
  color: #170;
}
.cm-s-ipython span.cm-attribute {
  color: #00c;
}
.cm-s-ipython span.cm-header {
  color: blue;
}
.cm-s-ipython span.cm-quote {
  color: #090;
}
.cm-s-ipython span.cm-link {
  color: #00c;
}
.cm-s-ipython span.cm-error {
  color: #f00;
}
.cm-s-ipython span.cm-tab {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=);
  background-position: right;
  background-repeat: no-repeat;
}
div.output_wrapper {
  /* this position must be relative to enable descendents to be absolute within it */
  position: relative;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  z-index: 1;
}
/* class for the output area when it should be height-limited */
div.output_scroll {
  /* ideally, this would be max-height, but FF barfs all over that */
  height: 24em;
  /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */
  width: 100%;
  overflow: auto;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  display: block;
}
/* output div while it is collapsed */
div.output_collapsed {
  margin: 0px;
  padding: 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
div.out_prompt_overlay {
  height: 100%;
  padding: 0px 0.4em;
  position: absolute;
  border-radius: 2px;
}
div.out_prompt_overlay:hover {
  /* use inner shadow to get border that is computed the same on WebKit/FF */
  -webkit-box-shadow: inset 0 0 1px #000;
  box-shadow: inset 0 0 1px #000;
  background: rgba(240, 240, 240, 0.5);
}
div.output_prompt {
  color: #D84315;
}
/* This class is the outer container of all output sections. */
div.output_area {
  padding: 0px;
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.output_area .MathJax_Display {
  text-align: left !important;
}
div.output_area .rendered_html table {
  margin-left: 0;
  margin-right: 0;
}
div.output_area .rendered_html img {
  margin-left: 0;
  margin-right: 0;
}
div.output_area img,
div.output_area svg {
  max-width: 100%;
  height: auto;
}
div.output_area img.unconfined,
div.output_area svg.unconfined {
  max-width: none;
}
/* This is needed to protect the pre formating from global settings such
   as that of bootstrap */
.output {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.output_area {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
div.output_area pre {
  margin: 0;
  padding: 0;
  border: 0;
  vertical-align: baseline;
  color: black;
  background-color: transparent;
  border-radius: 0;
}
/* This class is for the output subarea inside the output_area and after
   the prompt div. */
div.output_subarea {
  overflow-x: auto;
  padding: 0.4em;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
  max-width: calc(100% - 14ex);
}
div.output_scroll div.output_subarea {
  overflow-x: visible;
}
/* The rest of the output_* classes are for special styling of the different
   output types */
/* all text output has this class: */
div.output_text {
  text-align: left;
  color: #000;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
}
/* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */
div.output_stderr {
  background: #fdd;
  /* very light red background for stderr */
}
div.output_latex {
  text-align: left;
}
/* Empty output_javascript divs should have no height */
div.output_javascript:empty {
  padding: 0;
}
.js-error {
  color: darkred;
}
/* raw_input styles */
div.raw_input_container {
  line-height: 1.21429em;
  padding-top: 5px;
}
pre.raw_input_prompt {
  /* nothing needed here. */
}
input.raw_input {
  font-family: monospace;
  font-size: inherit;
  color: inherit;
  width: auto;
  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;
  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0em 0.25em;
  margin: 0em 0.25em;
}
input.raw_input:focus {
  box-shadow: none;
}
p.p-space {
  margin-bottom: 10px;
}
div.output_unrecognized {
  padding: 5px;
  font-weight: bold;
  color: red;
}
div.output_unrecognized a {
  color: inherit;
  text-decoration: none;
}
div.output_unrecognized a:hover {
  color: inherit;
  text-decoration: none;
}
.rendered_html {
  color: #000;
  /* any extras will just be numbers: */
}
.rendered_html em {
  font-style: italic;
}
.rendered_html strong {
  font-weight: bold;
}
.rendered_html u {
  text-decoration: underline;
}
.rendered_html :link {
  text-decoration: underline;
}
.rendered_html :visited {
  text-decoration: underline;
}
.rendered_html h1 {
  font-size: 185.7%;
  margin: 1.08em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
}
.rendered_html h2 {
  font-size: 157.1%;
  margin: 1.27em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
}
.rendered_html h3 {
  font-size: 128.6%;
  margin: 1.55em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
}
.rendered_html h4 {
  font-size: 100%;
  margin: 2em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
}
.rendered_html h5 {
  font-size: 100%;
  margin: 2em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
  font-style: italic;
}
.rendered_html h6 {
  font-size: 100%;
  margin: 2em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
  font-style: italic;
}
.rendered_html h1:first-child {
  margin-top: 0.538em;
}
.rendered_html h2:first-child {
  margin-top: 0.636em;
}
.rendered_html h3:first-child {
  margin-top: 0.777em;
}
.rendered_html h4:first-child {
  margin-top: 1em;
}
.rendered_html h5:first-child {
  margin-top: 1em;
}
.rendered_html h6:first-child {
  margin-top: 1em;
}
.rendered_html ul {
  list-style: disc;
  margin: 0em 2em;
  padding-left: 0px;
}
.rendered_html ul ul {
  list-style: square;
  margin: 0em 2em;
}
.rendered_html ul ul ul {
  list-style: circle;
  margin: 0em 2em;
}
.rendered_html ol {
  list-style: decimal;
  margin: 0em 2em;
  padding-left: 0px;
}
.rendered_html ol ol {
  list-style: upper-alpha;
  margin: 0em 2em;
}
.rendered_html ol ol ol {
  list-style: lower-alpha;
  margin: 0em 2em;
}
.rendered_html ol ol ol ol {
  list-style: lower-roman;
  margin: 0em 2em;
}
.rendered_html ol ol ol ol ol {
  list-style: decimal;
  margin: 0em 2em;
}
.rendered_html * + ul {
  margin-top: 1em;
}
.rendered_html * + ol {
  margin-top: 1em;
}
.rendered_html hr {
  color: black;
  background-color: black;
}
.rendered_html pre {
  margin: 1em 2em;
}
.rendered_html pre,
.rendered_html code {
  border: 0;
  background-color: #fff;
  color: #000;
  font-size: 100%;
  padding: 0px;
}
.rendered_html blockquote {
  margin: 1em 2em;
}
.rendered_html table {
  margin-left: auto;
  margin-right: auto;
  border: 1px solid black;
  border-collapse: collapse;
}
.rendered_html tr,
.rendered_html th,
.rendered_html td {
  border: 1px solid black;
  border-collapse: collapse;
  margin: 1em 2em;
}
.rendered_html td,
.rendered_html th {
  text-align: left;
  vertical-align: middle;
  padding: 4px;
}
.rendered_html th {
  font-weight: bold;
}
.rendered_html * + table {
  margin-top: 1em;
}
.rendered_html p {
  text-align: left;
}
.rendered_html * + p {
  margin-top: 1em;
}
.rendered_html img {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.rendered_html * + img {
  margin-top: 1em;
}
.rendered_html img,
.rendered_html svg {
  max-width: 100%;
  height: auto;
}
.rendered_html img.unconfined,
.rendered_html svg.unconfined {
  max-width: none;
}
div.text_cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.text_cell > div.prompt {
    display: none;
  }
}
div.text_cell_render {
  /*font-family: "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;*/
  outline: none;
  resize: none;
  width: inherit;
  border-style: none;
  padding: 0.5em 0.5em 0.5em 0.4em;
  color: #000;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
a.anchor-link:link {
  text-decoration: none;
  padding: 0px 20px;
  visibility: hidden;
}
h1:hover .anchor-link,
h2:hover .anchor-link,
h3:hover .anchor-link,
h4:hover .anchor-link,
h5:hover .anchor-link,
h6:hover .anchor-link {
  visibility: visible;
}
.text_cell.rendered .input_area {
  display: none;
}
.text_cell.rendered .rendered_html {
  overflow-x: auto;
  overflow-y: hidden;
}
.text_cell.unrendered .text_cell_render {
  display: none;
}
.cm-header-1,
.cm-header-2,
.cm-header-3,
.cm-header-4,
.cm-header-5,
.cm-header-6 {
  font-weight: bold;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.cm-header-1 {
  font-size: 185.7%;
}
.cm-header-2 {
  font-size: 157.1%;
}
.cm-header-3 {
  font-size: 128.6%;
}
.cm-header-4 {
  font-size: 110%;
}
.cm-header-5 {
  font-size: 100%;
  font-style: italic;
}
.cm-header-6 {
  font-size: 100%;
  font-style: italic;
}
/*!
*
* IPython notebook webapp
*
*/
@media (max-width: 767px) {
  .notebook_app {
    padding-left: 0px;
    padding-right: 0px;
  }
}
#ipython-main-app {
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  height: 100%;
}
div#notebook_panel {
  margin: 0px;
  padding: 0px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  height: 100%;
}
div#notebook {
  font-size: 14px;
  line-height: 20px;
  overflow-y: hidden;
  overflow-x: auto;
  width: 100%;
  /* This spaces the page away from the edge of the notebook area */
  padding-top: 20px;
  margin: 0px;
  outline: none;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  min-height: 100%;
}
@media not print {
  #notebook-container {
    padding: 15px;
    background-color: #fff;
    min-height: 0;
    -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
    box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  }
}
@media print {
  #notebook-container {
    width: 100%;
  }
}
div.ui-widget-content {
  border: 1px solid #ababab;
  outline: none;
}
pre.dialog {
  background-color: #f7f7f7;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding: 0.4em;
  padding-left: 2em;
}
p.dialog {
  padding: 0.2em;
}
/* Word-wrap output correctly.  This is the CSS3 spelling, though Firefox seems
   to not honor it correctly.  Webkit browsers (Chrome, rekonq, Safari) do.
 */
pre,
code,
kbd,
samp {
  white-space: pre-wrap;
}
#fonttest {
  font-family: monospace;
}
p {
  margin-bottom: 0;
}
.end_space {
  min-height: 100px;
  transition: height .2s ease;
}
.notebook_app > #header {
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
}
@media not print {
  .notebook_app {
    background-color: #EEE;
  }
}
kbd {
  border-style: solid;
  border-width: 1px;
  box-shadow: none;
  margin: 2px;
  padding-left: 2px;
  padding-right: 2px;
  padding-top: 1px;
  padding-bottom: 1px;
}
/* CSS for the cell toolbar */
.celltoolbar {
  border: thin solid #CFCFCF;
  border-bottom: none;
  background: #EEE;
  border-radius: 2px 2px 0px 0px;
  width: 100%;
  height: 29px;
  padding-right: 4px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-pack: end;
  -moz-box-pack: end;
  box-pack: end;
  /* Modern browsers */
  justify-content: flex-end;
  display: -webkit-flex;
}
@media print {
  .celltoolbar {
    display: none;
  }
}
.ctb_hideshow {
  display: none;
  vertical-align: bottom;
}
/* ctb_show is added to the ctb_hideshow div to show the cell toolbar.
   Cell toolbars are only shown when the ctb_global_show class is also set.
*/
.ctb_global_show .ctb_show.ctb_hideshow {
  display: block;
}
.ctb_global_show .ctb_show + .input_area,
.ctb_global_show .ctb_show + div.text_cell_input,
.ctb_global_show .ctb_show ~ div.text_cell_render {
  border-top-right-radius: 0px;
  border-top-left-radius: 0px;
}
.ctb_global_show .ctb_show ~ div.text_cell_render {
  border: 1px solid #cfcfcf;
}
.celltoolbar {
  font-size: 87%;
  padding-top: 3px;
}
.celltoolbar select {
  display: block;
  width: 100%;
  height: 32px;
  padding: 6px 12px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #555555;
  background-color: #fff;
  background-image: none;
  border: 1px solid #ccc;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
  width: inherit;
  font-size: inherit;
  height: 22px;
  padding: 0px;
  display: inline-block;
}
.celltoolbar select:focus {
  border-color: #66afe9;
  outline: 0;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
}
.celltoolbar select::-moz-placeholder {
  color: #999;
  opacity: 1;
}
.celltoolbar select:-ms-input-placeholder {
  color: #999;
}
.celltoolbar select::-webkit-input-placeholder {
  color: #999;
}
.celltoolbar select::-ms-expand {
  border: 0;
  background-color: transparent;
}
.celltoolbar select[disabled],
.celltoolbar select[readonly],
fieldset[disabled] .celltoolbar select {
  background-color: #eeeeee;
  opacity: 1;
}
.celltoolbar select[disabled],
fieldset[disabled] .celltoolbar select {
  cursor: not-allowed;
}
textarea.celltoolbar select {
  height: auto;
}
select.celltoolbar select {
  height: 30px;
  line-height: 30px;
}
textarea.celltoolbar select,
select[multiple].celltoolbar select {
  height: auto;
}
.celltoolbar label {
  margin-left: 5px;
  margin-right: 5px;
}
.completions {
  position: absolute;
  z-index: 110;
  overflow: hidden;
  border: 1px solid #ababab;
  border-radius: 2px;
  -webkit-box-shadow: 0px 6px 10px -1px #adadad;
  box-shadow: 0px 6px 10px -1px #adadad;
  line-height: 1;
}
.completions select {
  background: white;
  outline: none;
  border: none;
  padding: 0px;
  margin: 0px;
  overflow: auto;
  font-family: monospace;
  font-size: 110%;
  color: #000;
  width: auto;
}
.completions select option.context {
  color: #286090;
}
#kernel_logo_widget {
  float: right !important;
  float: right;
}
#kernel_logo_widget .current_kernel_logo {
  display: none;
  margin-top: -1px;
  margin-bottom: -1px;
  width: 32px;
  height: 32px;
}
#menubar {
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  margin-top: 1px;
}
#menubar .navbar {
  border-top: 1px;
  border-radius: 0px 0px 2px 2px;
  margin-bottom: 0px;
}
#menubar .navbar-toggle {
  float: left;
  padding-top: 7px;
  padding-bottom: 7px;
  border: none;
}
#menubar .navbar-collapse {
  clear: left;
}
.nav-wrapper {
  border-bottom: 1px solid #e7e7e7;
}
i.menu-icon {
  padding-top: 4px;
}
ul#help_menu li a {
  overflow: hidden;
  padding-right: 2.2em;
}
ul#help_menu li a i {
  margin-right: -1.2em;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu > .dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
}
.dropdown-submenu:hover > .dropdown-menu {
  display: block;
}
.dropdown-submenu > a:after {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  display: block;
  content: "\f0da";
  float: right;
  color: #333333;
  margin-top: 2px;
  margin-right: -10px;
}
.dropdown-submenu > a:after.pull-left {
  margin-right: .3em;
}
.dropdown-submenu > a:after.pull-right {
  margin-left: .3em;
}
.dropdown-submenu:hover > a:after {
  color: #262626;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left > .dropdown-menu {
  left: -100%;
  margin-left: 10px;
}
#notification_area {
  float: right !important;
  float: right;
  z-index: 10;
}
.indicator_area {
  float: right !important;
  float: right;
  color: #777;
  margin-left: 5px;
  margin-right: 5px;
  width: 11px;
  z-index: 10;
  text-align: center;
  width: auto;
}
#kernel_indicator {
  float: right !important;
  float: right;
  color: #777;
  margin-left: 5px;
  margin-right: 5px;
  width: 11px;
  z-index: 10;
  text-align: center;
  width: auto;
  border-left: 1px solid;
}
#kernel_indicator .kernel_indicator_name {
  padding-left: 5px;
  padding-right: 5px;
}
#modal_indicator {
  float: right !important;
  float: right;
  color: #777;
  margin-left: 5px;
  margin-right: 5px;
  width: 11px;
  z-index: 10;
  text-align: center;
  width: auto;
}
#readonly-indicator {
  float: right !important;
  float: right;
  color: #777;
  margin-left: 5px;
  margin-right: 5px;
  width: 11px;
  z-index: 10;
  text-align: center;
  width: auto;
  margin-top: 2px;
  margin-bottom: 0px;
  margin-left: 0px;
  margin-right: 0px;
  display: none;
}
.modal_indicator:before {
  width: 1.28571429em;
  text-align: center;
}
.edit_mode .modal_indicator:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f040";
}
.edit_mode .modal_indicator:before.pull-left {
  margin-right: .3em;
}
.edit_mode .modal_indicator:before.pull-right {
  margin-left: .3em;
}
.command_mode .modal_indicator:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: ' ';
}
.command_mode .modal_indicator:before.pull-left {
  margin-right: .3em;
}
.command_mode .modal_indicator:before.pull-right {
  margin-left: .3em;
}
.kernel_idle_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f10c";
}
.kernel_idle_icon:before.pull-left {
  margin-right: .3em;
}
.kernel_idle_icon:before.pull-right {
  margin-left: .3em;
}
.kernel_busy_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f111";
}
.kernel_busy_icon:before.pull-left {
  margin-right: .3em;
}
.kernel_busy_icon:before.pull-right {
  margin-left: .3em;
}
.kernel_dead_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f1e2";
}
.kernel_dead_icon:before.pull-left {
  margin-right: .3em;
}
.kernel_dead_icon:before.pull-right {
  margin-left: .3em;
}
.kernel_disconnected_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f127";
}
.kernel_disconnected_icon:before.pull-left {
  margin-right: .3em;
}
.kernel_disconnected_icon:before.pull-right {
  margin-left: .3em;
}
.notification_widget {
  color: #777;
  z-index: 10;
  background: rgba(240, 240, 240, 0.5);
  margin-right: 4px;
  color: #333;
  background-color: #fff;
  border-color: #ccc;
}
.notification_widget:focus,
.notification_widget.focus {
  color: #333;
  background-color: #e6e6e6;
  border-color: #8c8c8c;
}
.notification_widget:hover {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
.notification_widget:active,
.notification_widget.active,
.open > .dropdown-toggle.notification_widget {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
.notification_widget:active:hover,
.notification_widget.active:hover,
.open > .dropdown-toggle.notification_widget:hover,
.notification_widget:active:focus,
.notification_widget.active:focus,
.open > .dropdown-toggle.notification_widget:focus,
.notification_widget:active.focus,
.notification_widget.active.focus,
.open > .dropdown-toggle.notification_widget.focus {
  color: #333;
  background-color: #d4d4d4;
  border-color: #8c8c8c;
}
.notification_widget:active,
.notification_widget.active,
.open > .dropdown-toggle.notification_widget {
  background-image: none;
}
.notification_widget.disabled:hover,
.notification_widget[disabled]:hover,
fieldset[disabled] .notification_widget:hover,
.notification_widget.disabled:focus,
.notification_widget[disabled]:focus,
fieldset[disabled] .notification_widget:focus,
.notification_widget.disabled.focus,
.notification_widget[disabled].focus,
fieldset[disabled] .notification_widget.focus {
  background-color: #fff;
  border-color: #ccc;
}
.notification_widget .badge {
  color: #fff;
  background-color: #333;
}
.notification_widget.warning {
  color: #fff;
  background-color: #f0ad4e;
  border-color: #eea236;
}
.notification_widget.warning:focus,
.notification_widget.warning.focus {
  color: #fff;
  background-color: #ec971f;
  border-color: #985f0d;
}
.notification_widget.warning:hover {
  color: #fff;
  background-color: #ec971f;
  border-color: #d58512;
}
.notification_widget.warning:active,
.notification_widget.warning.active,
.open > .dropdown-toggle.notification_widget.warning {
  color: #fff;
  background-color: #ec971f;
  border-color: #d58512;
}
.notification_widget.warning:active:hover,
.notification_widget.warning.active:hover,
.open > .dropdown-toggle.notification_widget.warning:hover,
.notification_widget.warning:active:focus,
.notification_widget.warning.active:focus,
.open > .dropdown-toggle.notification_widget.warning:focus,
.notification_widget.warning:active.focus,
.notification_widget.warning.active.focus,
.open > .dropdown-toggle.notification_widget.warning.focus {
  color: #fff;
  background-color: #d58512;
  border-color: #985f0d;
}
.notification_widget.warning:active,
.notification_widget.warning.active,
.open > .dropdown-toggle.notification_widget.warning {
  background-image: none;
}
.notification_widget.warning.disabled:hover,
.notification_widget.warning[disabled]:hover,
fieldset[disabled] .notification_widget.warning:hover,
.notification_widget.warning.disabled:focus,
.notification_widget.warning[disabled]:focus,
fieldset[disabled] .notification_widget.warning:focus,
.notification_widget.warning.disabled.focus,
.notification_widget.warning[disabled].focus,
fieldset[disabled] .notification_widget.warning.focus {
  background-color: #f0ad4e;
  border-color: #eea236;
}
.notification_widget.warning .badge {
  color: #f0ad4e;
  background-color: #fff;
}
.notification_widget.success {
  color: #fff;
  background-color: #5cb85c;
  border-color: #4cae4c;
}
.notification_widget.success:focus,
.notification_widget.success.focus {
  color: #fff;
  background-color: #449d44;
  border-color: #255625;
}
.notification_widget.success:hover {
  color: #fff;
  background-color: #449d44;
  border-color: #398439;
}
.notification_widget.success:active,
.notification_widget.success.active,
.open > .dropdown-toggle.notification_widget.success {
  color: #fff;
  background-color: #449d44;
  border-color: #398439;
}
.notification_widget.success:active:hover,
.notification_widget.success.active:hover,
.open > .dropdown-toggle.notification_widget.success:hover,
.notification_widget.success:active:focus,
.notification_widget.success.active:focus,
.open > .dropdown-toggle.notification_widget.success:focus,
.notification_widget.success:active.focus,
.notification_widget.success.active.focus,
.open > .dropdown-toggle.notification_widget.success.focus {
  color: #fff;
  background-color: #398439;
  border-color: #255625;
}
.notification_widget.success:active,
.notification_widget.success.active,
.open > .dropdown-toggle.notification_widget.success {
  background-image: none;
}
.notification_widget.success.disabled:hover,
.notification_widget.success[disabled]:hover,
fieldset[disabled] .notification_widget.success:hover,
.notification_widget.success.disabled:focus,
.notification_widget.success[disabled]:focus,
fieldset[disabled] .notification_widget.success:focus,
.notification_widget.success.disabled.focus,
.notification_widget.success[disabled].focus,
fieldset[disabled] .notification_widget.success.focus {
  background-color: #5cb85c;
  border-color: #4cae4c;
}
.notification_widget.success .badge {
  color: #5cb85c;
  background-color: #fff;
}
.notification_widget.info {
  color: #fff;
  background-color: #5bc0de;
  border-color: #46b8da;
}
.notification_widget.info:focus,
.notification_widget.info.focus {
  color: #fff;
  background-color: #31b0d5;
  border-color: #1b6d85;
}
.notification_widget.info:hover {
  color: #fff;
  background-color: #31b0d5;
  border-color: #269abc;
}
.notification_widget.info:active,
.notification_widget.info.active,
.open > .dropdown-toggle.notification_widget.info {
  color: #fff;
  background-color: #31b0d5;
  border-color: #269abc;
}
.notification_widget.info:active:hover,
.notification_widget.info.active:hover,
.open > .dropdown-toggle.notification_widget.info:hover,
.notification_widget.info:active:focus,
.notification_widget.info.active:focus,
.open > .dropdown-toggle.notification_widget.info:focus,
.notification_widget.info:active.focus,
.notification_widget.info.active.focus,
.open > .dropdown-toggle.notification_widget.info.focus {
  color: #fff;
  background-color: #269abc;
  border-color: #1b6d85;
}
.notification_widget.info:active,
.notification_widget.info.active,
.open > .dropdown-toggle.notification_widget.info {
  background-image: none;
}
.notification_widget.info.disabled:hover,
.notification_widget.info[disabled]:hover,
fieldset[disabled] .notification_widget.info:hover,
.notification_widget.info.disabled:focus,
.notification_widget.info[disabled]:focus,
fieldset[disabled] .notification_widget.info:focus,
.notification_widget.info.disabled.focus,
.notification_widget.info[disabled].focus,
fieldset[disabled] .notification_widget.info.focus {
  background-color: #5bc0de;
  border-color: #46b8da;
}
.notification_widget.info .badge {
  color: #5bc0de;
  background-color: #fff;
}
.notification_widget.danger {
  color: #fff;
  background-color: #d9534f;
  border-color: #d43f3a;
}
.notification_widget.danger:focus,
.notification_widget.danger.focus {
  color: #fff;
  background-color: #c9302c;
  border-color: #761c19;
}
.notification_widget.danger:hover {
  color: #fff;
  background-color: #c9302c;
  border-color: #ac2925;
}
.notification_widget.danger:active,
.notification_widget.danger.active,
.open > .dropdown-toggle.notification_widget.danger {
  color: #fff;
  background-color: #c9302c;
  border-color: #ac2925;
}
.notification_widget.danger:active:hover,
.notification_widget.danger.active:hover,
.open > .dropdown-toggle.notification_widget.danger:hover,
.notification_widget.danger:active:focus,
.notification_widget.danger.active:focus,
.open > .dropdown-toggle.notification_widget.danger:focus,
.notification_widget.danger:active.focus,
.notification_widget.danger.active.focus,
.open > .dropdown-toggle.notification_widget.danger.focus {
  color: #fff;
  background-color: #ac2925;
  border-color: #761c19;
}
.notification_widget.danger:active,
.notification_widget.danger.active,
.open > .dropdown-toggle.notification_widget.danger {
  background-image: none;
}
.notification_widget.danger.disabled:hover,
.notification_widget.danger[disabled]:hover,
fieldset[disabled] .notification_widget.danger:hover,
.notification_widget.danger.disabled:focus,
.notification_widget.danger[disabled]:focus,
fieldset[disabled] .notification_widget.danger:focus,
.notification_widget.danger.disabled.focus,
.notification_widget.danger[disabled].focus,
fieldset[disabled] .notification_widget.danger.focus {
  background-color: #d9534f;
  border-color: #d43f3a;
}
.notification_widget.danger .badge {
  color: #d9534f;
  background-color: #fff;
}
div#pager {
  background-color: #fff;
  font-size: 14px;
  line-height: 20px;
  overflow: hidden;
  display: none;
  position: fixed;
  bottom: 0px;
  width: 100%;
  max-height: 50%;
  padding-top: 8px;
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  /* Display over codemirror */
  z-index: 100;
  /* Hack which prevents jquery ui resizable from changing top. */
  top: auto !important;
}
div#pager pre {
  line-height: 1.21429em;
  color: #000;
  background-color: #f7f7f7;
  padding: 0.4em;
}
div#pager #pager-button-area {
  position: absolute;
  top: 8px;
  right: 20px;
}
div#pager #pager-contents {
  position: relative;
  overflow: auto;
  width: 100%;
  height: 100%;
}
div#pager #pager-contents #pager-container {
  position: relative;
  padding: 15px 0px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
div#pager .ui-resizable-handle {
  top: 0px;
  height: 8px;
  background: #f7f7f7;
  border-top: 1px solid #cfcfcf;
  border-bottom: 1px solid #cfcfcf;
  /* This injects handle bars (a short, wide = symbol) for 
        the resize handle. */
}
div#pager .ui-resizable-handle::after {
  content: '';
  top: 2px;
  left: 50%;
  height: 3px;
  width: 30px;
  margin-left: -15px;
  position: absolute;
  border-top: 1px solid #cfcfcf;
}
.quickhelp {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
  line-height: 1.8em;
}
.shortcut_key {
  display: inline-block;
  width: 21ex;
  text-align: right;
  font-family: monospace;
}
.shortcut_descr {
  display: inline-block;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
span.save_widget {
  margin-top: 6px;
}
span.save_widget span.filename {
  height: 1em;
  line-height: 1em;
  padding: 3px;
  margin-left: 16px;
  border: none;
  font-size: 146.5%;
  border-radius: 2px;
}
span.save_widget span.filename:hover {
  background-color: #e6e6e6;
}
span.checkpoint_status,
span.autosave_status {
  font-size: small;
}
@media (max-width: 767px) {
  span.save_widget {
    font-size: small;
  }
  span.checkpoint_status,
  span.autosave_status {
    display: none;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  span.checkpoint_status {
    display: none;
  }
  span.autosave_status {
    font-size: x-small;
  }
}
.toolbar {
  padding: 0px;
  margin-left: -5px;
  margin-top: 2px;
  margin-bottom: 5px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
.toolbar select,
.toolbar label {
  width: auto;
  vertical-align: middle;
  margin-right: 2px;
  margin-bottom: 0px;
  display: inline;
  font-size: 92%;
  margin-left: 0.3em;
  margin-right: 0.3em;
  padding: 0px;
  padding-top: 3px;
}
.toolbar .btn {
  padding: 2px 8px;
}
.toolbar .btn-group {
  margin-top: 0px;
  margin-left: 5px;
}
#maintoolbar {
  margin-bottom: -3px;
  margin-top: -8px;
  border: 0px;
  min-height: 27px;
  margin-left: 0px;
  padding-top: 11px;
  padding-bottom: 3px;
}
#maintoolbar .navbar-text {
  float: none;
  vertical-align: middle;
  text-align: right;
  margin-left: 5px;
  margin-right: 0px;
  margin-top: 0px;
}
.select-xs {
  height: 24px;
}
.pulse,
.dropdown-menu > li > a.pulse,
li.pulse > a.dropdown-toggle,
li.pulse.open > a.dropdown-toggle {
  background-color: #F37626;
  color: white;
}
/**
 * Primary styles
 *
 * Author: Jupyter Development Team
 */
/** WARNING IF YOU ARE EDITTING THIS FILE, if this is a .css file, It has a lot
 * of chance of beeing generated from the ../less/[samename].less file, you can
 * try to get back the less file by reverting somme commit in history
 **/
/*
 * We'll try to get something pretty, so we
 * have some strange css to have the scroll bar on
 * the left with fix button on the top right of the tooltip
 */
@-moz-keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}
@-webkit-keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}
@-moz-keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/*properties of tooltip after "expand"*/
.bigtooltip {
  overflow: auto;
  height: 200px;
  -webkit-transition-property: height;
  -webkit-transition-duration: 500ms;
  -moz-transition-property: height;
  -moz-transition-duration: 500ms;
  transition-property: height;
  transition-duration: 500ms;
}
/*properties of tooltip before "expand"*/
.smalltooltip {
  -webkit-transition-property: height;
  -webkit-transition-duration: 500ms;
  -moz-transition-property: height;
  -moz-transition-duration: 500ms;
  transition-property: height;
  transition-duration: 500ms;
  text-overflow: ellipsis;
  overflow: hidden;
  height: 80px;
}
.tooltipbuttons {
  position: absolute;
  padding-right: 15px;
  top: 0px;
  right: 0px;
}
.tooltiptext {
  /*avoid the button to overlap on some docstring*/
  padding-right: 30px;
}
.ipython_tooltip {
  max-width: 700px;
  /*fade-in animation when inserted*/
  -webkit-animation: fadeOut 400ms;
  -moz-animation: fadeOut 400ms;
  animation: fadeOut 400ms;
  -webkit-animation: fadeIn 400ms;
  -moz-animation: fadeIn 400ms;
  animation: fadeIn 400ms;
  vertical-align: middle;
  background-color: #f7f7f7;
  overflow: visible;
  border: #ababab 1px solid;
  outline: none;
  padding: 3px;
  margin: 0px;
  padding-left: 7px;
  font-family: monospace;
  min-height: 50px;
  -moz-box-shadow: 0px 6px 10px -1px #adadad;
  -webkit-box-shadow: 0px 6px 10px -1px #adadad;
  box-shadow: 0px 6px 10px -1px #adadad;
  border-radius: 2px;
  position: absolute;
  z-index: 1000;
}
.ipython_tooltip a {
  float: right;
}
.ipython_tooltip .tooltiptext pre {
  border: 0;
  border-radius: 0;
  font-size: 100%;
  background-color: #f7f7f7;
}
.pretooltiparrow {
  left: 0px;
  margin: 0px;
  top: -16px;
  width: 40px;
  height: 16px;
  overflow: hidden;
  position: absolute;
}
.pretooltiparrow:before {
  background-color: #f7f7f7;
  border: 1px #ababab solid;
  z-index: 11;
  content: "";
  position: absolute;
  left: 15px;
  top: 10px;
  width: 25px;
  height: 25px;
  -webkit-transform: rotate(45deg);
  -moz-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  -o-transform: rotate(45deg);
}
ul.typeahead-list i {
  margin-left: -10px;
  width: 18px;
}
ul.typeahead-list {
  max-height: 80vh;
  overflow: auto;
}
ul.typeahead-list > li > a {
  /** Firefox bug **/
  /* see https://github.com/jupyter/notebook/issues/559 */
  white-space: normal;
}
.cmd-palette .modal-body {
  padding: 7px;
}
.cmd-palette form {
  background: white;
}
.cmd-palette input {
  outline: none;
}
.no-shortcut {
  display: none;
}
.command-shortcut:before {
  content: "(command)";
  padding-right: 3px;
  color: #777777;
}
.edit-shortcut:before {
  content: "(edit)";
  padding-right: 3px;
  color: #777777;
}
#find-and-replace #replace-preview .match,
#find-and-replace #replace-preview .insert {
  background-color: #BBDEFB;
  border-color: #90CAF9;
  border-style: solid;
  border-width: 1px;
  border-radius: 0px;
}
#find-and-replace #replace-preview .replace .match {
  background-color: #FFCDD2;
  border-color: #EF9A9A;
  border-radius: 0px;
}
#find-and-replace #replace-preview .replace .insert {
  background-color: #C8E6C9;
  border-color: #A5D6A7;
  border-radius: 0px;
}
#find-and-replace #replace-preview {
  max-height: 60vh;
  overflow: auto;
}
#find-and-replace #replace-preview pre {
  padding: 5px 10px;
}
.terminal-app {
  background: #EEE;
}
.terminal-app #header {
  background: #fff;
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
}
.terminal-app .terminal {
  width: 100%;
  float: left;
  font-family: monospace;
  color: white;
  background: black;
  padding: 0.4em;
  border-radius: 2px;
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.4);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.4);
}
.terminal-app .terminal,
.terminal-app .terminal dummy-screen {
  line-height: 1em;
  font-size: 14px;
}
.terminal-app .terminal .xterm-rows {
  padding: 10px;
}
.terminal-app .terminal-cursor {
  color: black;
  background: white;
}
.terminal-app #terminado-container {
  margin-top: 20px;
}
/*# sourceMappingURL=style.min.css.map */
    </style>
<style type="text/css">
    .highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
    </style>
<style type="text/css">
    
/* Temporary definitions which will become obsolete with Notebook release 5.0 */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-bold { font-weight: bold; }

    </style>


<style type="text/css">
/* Overrides of notebook CSS for static HTML export */
body {
  overflow: visible;
  padding: 8px;
}

div#notebook {
  overflow: visible;
  border-top: none;
}@media print {
  div.cell {
    display: block;
    page-break-inside: avoid;
  } 
  div.output_wrapper { 
    display: block;
    page-break-inside: avoid; 
  }
  div.output { 
    display: block;
    page-break-inside: avoid; 
  }
}
</style>

<!-- Custom stylesheet, it must be in the same directory as the html file -->
<link rel="stylesheet" href="custom.css">

<!-- Loading mathjax macro -->
<!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --></head>
<body>
  <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>pataki norbert
patakino@elte.hu
14:00-15:30</p>
<p>számonkérés:
gyakorlaton 3db +/-
jegyszerzés géptermi vizsga elméleti rész + gyakorlati rész</p>
<blockquote><p>elmélet egy 15 kérdéses teszt, félévközben +/- -okon indul
jegy = (elm + gyak)/2, gyak irányába kerekítve
elm 30-40 perc, gyakorlati vizsga 3 óra (főleg a gyakorlati példákra épít), lovardában, vizsgaidőszak
opcionális beadandó, félév második felében - kódminőséget néznek és nem test case-eket (jó operátorok, elnevezési konvenciók, indentálás)
legfontosabb, hogy gyakoroljatok</p>
</blockquote>
<p>régebbi beadandok, vizsgafeladatok: patakino.web.elte.hu/pny2</p>
<p>gyakorlatokon táblás termekben kis kódrészleteket fogunk megnézni
rövid példák, nem lesznek hosszúak, megértést szolgálják
60 gyak vizsga sorból 55 rutinból megírható
hf-okat meg kell csinálni
előadás katalógus</p>
<p>ajánlott irodalom: stroustrup: a cpp programozási nyelv - ha kimaradt volna egy-egy előadás
gyakorlat és előadás jegyzeteket kell alapvetően használni
template fejezet a kedvence a könyvből
meyers könyv olvasmányosabb: hatékony cpp, olvasmányos, de nem minden órai téma van benne</p>
<p>tematika:</p>
<p>processzor csak gépi kódot ért
utasításkészlet &lt;-&gt; assembly nyelv (MOV,NOP,mnemonik)</p>
<ol>
<li>fordítás/futtatás</li>
<li>típusrendszer</li>
<li>alprogramok (függvények), paraméterátadás</li>
<li>memóriakezelés</li>
<li>OOP nyelvi eszközei</li>
<li>sablonok (templatek), STL(szabványkönyvtár) felépítése</li>
</ol>
<p>végrehajtási verem</p>
<p>Bevezetés
Nyelvek/paradigmák fogalma, története
           van egy komplex feladat(függvényekben, eljárásokban ogndolkodok vagy osztályokban? objektumorientált módon?)
           komplex feladatot, más és más módon tudom felosztani
                 dekomponálás(dekompozíció)
             lesz eszközkészlet, szokott lenni know-how, mikor használok singleton design patternt stb</p>
<p>ezekhez a pradigmákhoz nyelvek is kapcsolódnak melyekhez támogatják a paradigmákat
 1945-től vannak gépek
 1949: assembly - itt még alacsony szinten vagyunk
 imperatív: (te processzor hajtsd véger ezt a kurva lépést)</p>
<blockquote><p>leírja, hogy milyen utasításokat hajtsunk végre</p>
</blockquote>
<p>1950- magasszintű programozás nyelvek megjelennek, absztrakció réteget biztosít<br>
      vezérlési szerkezetek megjelennek, változó fogalma megjelenik<br>
      fortran (formula translator), fizikai képletek számítására<br></p>
<p>1960- <strong>procedurális nyelvek</strong> megjelennek, ne kelljen copy pastelni (C,Pascal)<br>
      függvények eljárások (alprogramok)<br></p>

<pre><code>  ekkor más paradigma is megjelenik: Lisp: **funkcionális programozás** -&gt; haskell, scala&lt;br&gt;

  megjelenik a **deklaratív programozás**: sql, structured query language&lt;br&gt;
           nem hogyan fusson le, hanem mit várok el&lt;br&gt;

</code></pre>
<p>1967 simula - első <strong>objektumorientált</strong> nyelv<br>
1970 <strong>logikai programozás</strong> - prolog<br></p>
<p>c++, 70-es évek környékén, unix op rendszert meg akarták írni, ritchie thompson többiek
előtte feltalálnak egy programozási nyelvet, legyen c, gyorsan lehet implementálni a segítségével
a processzor fölé, könnyen fordítható assembly szintre</p>
<p>stroustrup, jó a c ,de nem támogatja az oo-t, legyen reverse kompatibilitás (kezdeti fejlődés során ehhez ragaszkodtak)
ma már nem érvényes a reverz kompatibilitás, oo c = c++, legyen majdnem olyan gyors
multi paradigma, bekerült az exception kezelés, nagyon sokminden bejött egyszerre, ezért bonyolult a c++, névterek, template-k stb</p>
<p><strong>gyakorlat1</strong></p>
<p>számonkérések: írunk 3 db +/- (potolhato óra előtti emaillel)
pár perces, kódrészlet értelmezés + géptermi vizsga
kis kódokat érdemes kipróbálni</p>
<p>(linux konzol / CLI fordítás/futtatás)
fapadosnak tűnik, jó programozó nincs meg command line nélkül
mai informatika abba az irányba megy el minden, hogy command line-ból futtassunk mindent</p>
<blockquote><p>CI rendszerek (változtatnak valamit repoba) - jenkins, trevis
cloud, konténerek - tipikusan virtuális gépek, nem lesz monitora, ezekbe ssh-zunk és command line-ból dolgozunk
virtualizált megoldásokban egyre fontosabb a CL</p>
</blockquote>
<p>ajánlott irodalom: stroustrup cpp programozási nyelv (nem tanköny jellege van)
                   scott meyers hatékony cpp (olvasmányosabb, tankönyv jelleg)</p>
<p>régebbi vizsgafeladatok: patakino.web.elte.hu/pny2
C-re épült, sokáig igény volt a backward kompatibilitás, közben új nyelvi konstrukciókat tudtak bevezetni
Tematika(miért váltzonak a nyelvek, hogyan változnak)
mit örökölt a c-től,hogyan bővült,hogyan változik, megértjük a miérteket,objektumorientált készlet</p>
<blockquote><p>nyelvek változása, c-&gt; cpp/cpp11 esetleg vs jáva</p>
</blockquote>
<p>Mai alkalom? C/C++ programok fordítása</p>
<p>a.cpp (cpp forrásfájl)     &lt;&gt;      cpu (processzor) | ezek nem kompatibilisek, mégis végig akarjuk hajtani a kódot a processzoron, alacsony szintű a kód a cpu-n, a forrásfájlban magas szintű konstrukciók vannak
a fordítóprogram a magas szintű kódot fordítja a processzor alacsony szintű kódjára
eszköz: vizsgálja a kódot (validálja)
mindenféle architektúrára generál kódot</p>
<p>(0. forráskód gépelése)
1.: preprocesszálás - preprocesszor
2.: nyelvi fordítás - compiler
3.: összeszerkeszté - linker
-
végén: futtatható - idáig eltelt idő a fordítási idő
-
-
futtatás</p>
<p>1: preprocesszor: szövegátalakító rendszer: search \&amp; replace, filetartalom bemásolás (#-kal kezdődő sorok feldolgozás), szövegrész kivágása
2: fordít, .o/.obj obejct/tárgykódot készít - egységes alcsonyszintű kód ami már alacsonyszintű architektúrára ksézült
3: akkor jön be ha modulokra bontunk
       nem egy fájlba dolgozunk - a.cpp ........... n.cpp nfájlban dolgozunk</p>

<pre><code>                              1.                1.
                              a\'.cpp           n'.cpp
                              2.                2.
                              a.o (object       n.o
                                          ||3.
                                         linker -&gt;futtatható állomány
                                    az a.h-t csak egyikben kelle bemásolni, különben linkelési hibát ad
                                    a.o ......n.o-ban benne lesz
                                    a header nem kerül fordításra, a preproc másolgatja össze vissza

</code></pre>
<p>linkelési hibák:</p>
<ol>
<li>undefined reference, az objectekben nem talál valamit</li>
<li>ambiguous reference, ugyanaz a függvény több tárgykódban is megtalálható</li>
</ol>
<p>miért jobb az iteratív faktoriális a rekurzívnál?</p>
<p>a.cpp, írjunk faktoriális függvényt</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//a.cpp -a.o, itt nincs hiba</span>

<span class="c1">//main.cpp</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// így már befordul és lesz egy main.o</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fact</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// compiler nem tudja mi a fact</span>
<span class="p">}</span>
<span class="c1">//ha ki van kommentezve a fact -&gt; ettől még lesz main.o, de undefined reference lesz</span>
</pre></div>
<p>chez cpphez gcc/g++ compiler</p>
<div class="highlight"><pre><span></span><span class="c1">//g++ hello.cpp</span>
<span class="c1">//-&gt; futtatható: a.exe/a.out</span>

<span class="c1">//g++  -o hello hello.cpp</span>
<span class="c1">//-&gt; futtatható: hello</span>

<span class="c1">//-W -Wall warningokat magas szintre állítjuk</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">){</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;OK&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;wtf&quot;</span><span class="p">;</span> <span class="c1">//-&gt;wtf</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="c1">//előjeles és előjeles nélkülit akarunk összehasonlítani, szabvány szerint konvertálni kell: wtf jön ki</span>
<span class="c1">//előjel bit, helyiérték bit be lesz billentve</span>
</pre></div>
<p>-ansi    szabvány szerint működjön a compiler, szabványban nincs szó arról, hogy mit kell csinálni a preproc fájlokkal<br>
-pedantic tartsuk be a c++ szabvány előírásait<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">];</span> <span class="c1">// nem szabványos cpp 99-es szabvány ezt engedte, gcc ez alapján készült</span>
          <span class="c1">//tömb méretét nem ismerjük fordítási időben, ilyen nincs -pedantic ezt megtagadja</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>2. előadás</strong> 09.18</p>
<p>main cpp</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// warning: division by zero</span>
  <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">;</span> <span class="c1">// error: ‘x’ was not declared in this scope</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//initialized to zeros (garbage?)</span>
  <span class="n">t</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span> <span class="c1">// *** stack smashing detected ***:</span>
<span class="p">}</span>
</pre></div>
<p>'A' vs 'ABC' vs "ABC"<br></p>
<p><strong>fordítás:</strong><br>
gcc main.cpp -&gt; a.out (bináris)<br></p>
<p>preprocess utasítás (szövegszerű helyettesítés)<br>
include<iostream> - mintha begépeltem volna<br></p>
<p>3 soros függvény<br>
int f(int x){return 2*x};<br>
2 deklaráció: int és függvény deklaráció - <strong>deklaráció</strong>: név entitáshoz típust rendelünk
visszatérési értéket adjuk meg illetve az argumentum is deklarálandó</p>
<p><strong>void</strong> (semmivel visszatérő)
<strong>függvény szignatúra</strong> (ahogy kinéz a függvény)</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">g</span><span class="p">();</span> <span class="c1">// elegendő deklaráció a fordítónak</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">();</span> <span class="c1">// deklarálni többször is lehet</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{}</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">g</span><span class="p">();</span>
  <span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// 84</span>
<span class="p">}</span>
</pre></div>
<p>az hogy mit csinál a fv elég később megadni<br>
void g(){cout &lt;&lt; "hello";} - deklaráció + def<br>
függvény <strong>definíciója</strong>, ha megadom a törzset is<br>
<strong>one definition rule</strong> - definiálni csak egyszer  lehet, ha többször akkor nem fordul<br></p>
<p><strong>input és annak a hasznossága:</strong><br></p>
<div class="highlight"><pre><span></span><span class="c1">//előbb definiált f fv-t f.cpp fájlba rakjuk</span>
<span class="c1">//hogyan deklarálom most f-et</span>

<span class="c1">//main cpp</span>
<span class="cp">#include</span><span class="cpf">&lt;f.cpp&gt; //rossz példa, ILYET NE, nagyon rossz programozási stílus</span><span class="cp"></span>

<span class="c1">//f.h header</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">//headerben deklarálunk</span>

<span class="cp">#include</span><span class="cpf">&lt;f.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span><span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">);}</span>
</pre></div>
<p>gcc main.cpp f.cpp (<strong>helyes fordítás</strong>)</p>
<p>fordítás jön most - szintaktikus nyelvi elemzés, klasszikus fordítási hibák jelentkeznek</p>
<p>gcc main.cpp f.cpp -c   invokes just the compile stage<br>
                   -E   csak a preprocess hajtja végre, iostreamre megy a preprocesszált egység<br></p>
<p>f.h új változat - klasszikus header (fejléc):</p>
<div class="highlight"><pre><span></span><span class="cp">#ifndef F_H </span><span class="c1">//header guard</span>
<span class="cp">#define F_H makrotoken önmagában</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="cp">#define X 42 </span><span class="c1">// X **makrotoken értékadással** </span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define F(x) x*x </span><span class="c1">//függvényszerű makrotoken</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">F</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// 3+3 * 3+3-&gt;15, just textual replacement</span>
<span class="p">}</span>
</pre></div>
<p>szövegszerű egyszerű behelyettesítés<br>
buta helyettesítés -&gt; 3+3 * 3+3 nem a hat négyzete<br></p>
<p>tfh kétszer includeolva lett a fejléc<br></p>
<p>ha az F_H nem lett definiálva akkor definiáljuk (if not def ifndef - ennek példájára más célból ifdef is létezik)<br>
második include -&gt; definiálva lett, átugorja, ez a <strong>header guard</strong>!<br></p>
<p>vizsgán a header guardnál az egészet végig kell mondani, onnantól kezdve, hogy ne sértsünk one def rulet<br>
<code>#pragma once</code> &gt; fordító támogatja, szabványos kódot kell írni, tehát a pragmát ne használjuk<br></p>
<p>cpp 11-ben<br>
auto x=42;  a fordító már kitalálja, hogy legyen x int<br>
vizsgán ilyet nem lehet<br></p>
<p>ez volt a preprocesszálás<br>
linkelés a végén minden szimbólum definícióját megkeressük<br></p>
<p><strong>vezérlési szerkezetek:</strong><br>
szekvencia, ciklus, procedurális<br>
beépített alaptípusok: int, char,float, bool, double etc.<br></p>
<blockquote><p>int i; egész számokat tudok benne tárolni, típuselmélet vs halmazelmélet
hány bájtot tulajdonítsunk neki, ennyi a lényege a típusnak
típusértékhalmaz így adott és az értelmezett műveletek</p>
</blockquote>
<p>int i;<br>
i értéke ekkor még memóriaszemét<br>
<strong>futásidejű hatékonyság</strong><br>
3/2 = 1<br>
int típusú változónak architektúrától függően, futási időben hatékony legyen, annyi bájtot foglal le<br>
64 biten 8 bájt a kényelmetlen<br></p>
<p>hf: cout &lt;&lt; sizeof(int), próbálgassuk végig az összes típussal<br></p>
<div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="c1">//4</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="c1">//4</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="c1">//2</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="c1">//8</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="c1">//1</span>
<span class="k">sizeof</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="c1">//8</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="c1">//4</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="c1">//8</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="c1">//1</span>
</pre></div>
<p><strong>float vs double</strong> különbség<br>
<strong>long int</strong> eggyel nagyobb bájton tárolódik mint az int, ennyit mond a szabvány<br>
kivétel: a <strong>char</strong> mindig 1 bájt, ezt mondja a szabvány, a többi ennek a többszöröse<br>
1 bájt 8 bit, kivéve cpp, <strong>annyi amennyit az architektúra kényelmesen kezelni tud</strong><br></p>
<p><strong>tömbök</strong><br>
<code>int t[10];</code> allokálok a memóriában tfh most 4 bájt az integer, minden cellában 4 bájtot foglal a memóriában<br>
szabvány szerint fordítási időben a tömb méret konstans kell, hogy legyen<br>
<code>t[i];</code> <strong>nem szabványos</strong>!, lefordul de vizsgán nincs elfogadva<br></p>
<p><strong>pointerek fogalma:</strong><br>
másfajta típuskonstrukcióseszköz<br>
<code>int* p;</code>  pointer mutató, memóriacímeket tud tárolni<br></p>
<p>memória<br>
#1<br>
#2 i  42<br>
#3  p   #3<br>
...<br></p>
<p>int i=42; <strong>dekl+def</strong>, változó helyet kap a memóriában<br></p>
<p>&amp; címlekérdező operátor, <code>int*p =&amp;i</code>  megkapja a 2-est ahova tárolta<br>
pointererel rámutatunk mindig, hogy hol van a követekző láncszem<br></p>
<p><strong>dereferencia:</strong><br></p>
<div class="highlight"><pre><span></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// ez a csillag egy művelet, kiíródik egy szám,42 </span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>   <span class="c1">// i memóriacíme íródik ki 16-os számrendszerben 0x7ffcce65c5ac </span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span> <span class="c1">// pointer memóriacíme 0x7ffcce65c5b0 itt tárolja a p értékét, ami 0x7ffcce65c5ac</span>
</pre></div>
<p><strong>tömbök pointerek</strong></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">p</span><span class="o">=</span><span class="n">t</span><span class="p">;</span> <span class="c1">//ilyet lehet írni? ez itt különböző típus -lehet tömböt pointerbe konvertálni</span>
     <span class="c1">//igen a szabály, hogy a pointer a tömb első elemére fog mutatni, ez volt a tömb pointer kapcsolata</span>
     <span class="c1">//miért hasznos ez?</span>
     <span class="c1">//pointerhez hozzá lehet adni egy számot</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>   <span class="c1">//0x7ffe16a52860</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//0x7ffe16a52864, int pointer int-nyit fog lépni</span>

<span class="c1">//pointer aritmetika</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">p</span><span class="p">;</span> <span class="c1">////0x7ffe16a52864</span>
<span class="c1">//kikötöttük, hogy a tömbelemek a memóriában egymás mellettvannak</span>
<span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// ==t[2]</span>
<span class="c1">// vicces példa</span>
<span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">p</span><span class="p">)</span> <span class="c1">// analógia == 2[t] és ez működik</span>

<span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span> <span class="c1">// 1, konverzió működik</span>
<span class="kt">bool</span> <span class="n">b</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span> <span class="c1">// 1, implicit típuskonverzió itt is működik, szabályokat itt tudni kell</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>2. gyakorlat</strong> 09.19</p>
<div class="highlight"><pre><span></span><span class="cm">/* Hello World */</span> <span class="c1">//C komment</span>
</pre></div>
<p>cpp-ben ez a fajta kommentelés nem egymásba ágyazható <br>
néha zavaró lehet a komment, clean code<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt; /* enélkül is fordul a Hello C-ben */</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* ez sem kell felétlenül, hogy ott legyen */</span>
              <span class="cm">/* linux alatt a visszatérés egy környezeti változóba: echo dollár kérdőjel */</span>
</pre></div>
<p>cpp változat<br></p>
<div class="highlight"><pre><span></span><span class="c1">// egy soros komment</span>
<span class="cm">/* blokk komment*/</span>
</pre></div>
<h1>include<iostream></h1>
<p>int main()
{
    std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
}</p>

<pre><code>
main visszatérési értéke int és nem void!&lt;br&gt;
automatikusan 0-val tér vissza, kifejezetten a mainre vonatkozik, return ettől kiadható&lt;br&gt;

cout, itt minősített névvel lettek megadva, std a szabványkönyvtár névtere&lt;br&gt;
miért kell névtér? vannak függvénynevek melyek nevei ugyanazok&lt;br&gt;
pl osztálykönyvtár openGL, ne ütközzenek a felhasználók által írt függvényekkel,ezért gl prefixszel dolgoztak&lt;br&gt;
pvm - parallel virtual machine, voltak ilyenek, hogy pvm_Send, pvm_getid&lt;br&gt;
konvenciót lecserélték nyelvi konstrukcióra -&gt; névtér&lt;br&gt;
**namespace** bevezetése, minősített neve, ezek már **operátorok**   std::, **namespace resolution operator**&lt;br&gt;

```cpp
namespace A
{
    void f() //A::f()
    {
    }
}
namespace B
{
    void f() //B::f()
    {
    }
}

A::f();
B::f();</code></pre>
<p><strong>using direktívák</strong></p>
<div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</pre></div>
<p>ekkor használhatók minősített név nélkül a methodok
using std::cout;    cout használható szimplán ekkor, endl csak minősített névvel std::endl
névtér feloldási operátor</p>
<p>header fájlba <strong>nem</strong> írunk using direktívákat</p>
<div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">B</span><span class="p">;</span>
<span class="n">f</span><span class="p">();</span>
<span class="c1">///ha az A névterét is használjuk akkor a compiler hibát ír, fordítási hiba</span>
</pre></div>
<p><strong>feladat2</strong>
F:[-60,140] 10-esével végigmegyünk az intervallumon és szeretnénk a fahrenheit értékeket celsiusben szeretnénk kiíratni egy kis táblázatban
x -&gt; 5/9*(x-32)<br></p>
<p>konstansokat szeparáljuk le a végrehajtási egységekről, nem égetjük bele a kód belsejébe</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="mi">60</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">upper</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">lower</span><span class="p">;</span> <span class="cm">/* ciklusváltozó deklaráció és def */</span>
    <span class="cm">/* üres inicializáló lépés */</span>
    <span class="k">for</span><span class="p">(;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">upper</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="n">step</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="cm">/* %d decimális formázó */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%dFahr</span><span class="se">\t</span><span class="s">%dCelsius</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">5</span><span class="o">/</span><span class="mi">9</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">32</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>eredmény -60 0<br>
         -50 0.....5/9-nél probléma<br></p>
<p>5.0 ez már double, lebegőpontos konstans<br>
javítva: <code>5./9*(i-32)</code> innnetől már tudja a cpp, hogy mit kell csinálni<br></p>
<p>double d=5/9; // 0.0 lesz<br></p>
<p>eredmény -60 9273641<br>
         -50 835426.....</p>
<p>javítás:</p>
<div class="highlight"><pre><span></span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%dFahr</span><span class="se">\t</span><span class="s">\%fCelsius</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mf">5.</span><span class="o">/</span><span class="mi">9</span><span class="err">\</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">32</span><span class="p">));</span>
</pre></div>
<p><strong>memória menedzsment</strong></p>
<div class="highlight"><pre><span></span><span class="cp"># include &lt;stdio.h&gt;</span>

<span class="cp"># define LOWER = -60;</span>
<span class="cp"># define UPPER = 140;</span>
<span class="cp"># define STEP = 10;</span>

<span class="cm">/* lehet makrót írni */</span>
<span class="cp"># define FAHR2CELS(x)(5./9((x)-32))</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">LOWER</span><span class="p">;</span> 
    <span class="k">for</span><span class="p">(;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">UPPER</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="n">STEP</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%dFahr</span><span class="se">\t</span><span class="s">%fCelsius</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">FAHR2CELS</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>cpp</p>
<div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">double</span> <span class="nf">fahr2cels</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mf">5.</span><span class="o">/</span><span class="mi">9</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// paraméterátadásilag tök mindegy hogy inline-nak nevezem-e vagy sem</span>
<span class="n">nem</span> <span class="n">kell</span> <span class="n">f</span><span class="err">ü</span><span class="n">ggv</span><span class="err">é</span><span class="n">nyt</span> <span class="n">csin</span><span class="err">á</span><span class="n">lni</span><span class="p">,</span> <span class="n">csak</span> <span class="n">cser</span><span class="err">é</span><span class="n">lje</span> <span class="n">be</span> <span class="n">a</span> <span class="n">k</span><span class="err">é</span><span class="n">pletet</span> <span class="n">a</span> <span class="n">compiler</span><span class="p">,</span> <span class="n">ez</span><span class="err">é</span><span class="n">rt</span> <span class="kr">inline</span> <span class="n">a</span> <span class="n">neve</span>
<span class="n">makr</span><span class="err">ó</span><span class="n">k</span> <span class="n">nem</span> <span class="n">f</span><span class="err">ü</span><span class="n">ggv</span><span class="err">é</span><span class="n">nyek</span><span class="p">,</span> <span class="n">ez</span> <span class="n">a</span> <span class="n">baja</span> <span class="n">vle</span><span class="err">ü</span><span class="n">k</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">=-</span><span class="mi">60</span><span class="p">;</span> <span class="c1">// ennek nem fog megváltozni az értéke</span>
  <span class="c1">//const biztonságosabban lehet programozni és hatékonyabb a kezelés, ha mégis megváltozna adjon a compiler hibát</span>
  <span class="c1">//mit jelent majd pointernél, referencián további gyakorlatokon</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">=</span><span class="mi">140</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">lower</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">upper</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="n">step</span><span class="p">)</span> <span class="c1">//step+=i hibás c-ben, cpp-ben fordítási hiba</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">fahr2cels</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> 
<span class="p">}</span>

<span class="c1">//változókat nem az elején lehet csak bevezetni, bárhol lehet</span>
<span class="c1">// az rekurzió nem lehet inlineosítani</span>
<span class="c1">// inline csak egy ajánlás</span>
</pre></div>
<p>a.cpp<br>
void f(){} -&gt; a.obj<br>
b.cpp <br>
void f();<br>
f(); linker megtlalálja<br></p>
<p><strong>inline függvény</strong> mehet headerbe!!, linkelésen keresztül nem lehet megosztani az inline-t mert nem lesz belőle object kód<br>
<strong>normál függvényből</strong> tárgykód lesz, object és linkerrel megosztható<br>
linkelésileg más az inline és a függvény<br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>3 előadás</strong></p>
<ol>
<li>preprocesszálás múlt órán volt (szövegbeillesztés)<br></li>
<li>nyelvi fordítás<br></li>
<li>linker összeszerkeszti a programot<br></li>
</ol>
<p>compiler lexikális elmeket(tokeneket) hoz létre a forráskódból<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello World!&quot;</span><span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>tokenizálás: felbontjuk a programot a lexikális elemekre (legelemibb részekre)<br>
const és static helyzetfüggőek, hogy mit jelentenek</p>
<p>kulcsszavak: if,try,auto,int,main nevek foglaltak<br>
azonosítók: std, endl<br>
Konstans szövegliterálok: "HelloWorld!"<br>
konstans: 0
operátorok: ::
szeparátorok: ;,{},()</p>
<p>azonosítók betűvel kezdődnek és betűvel vagy számmal folytatódhatnak, speciális betű: _ (underscore), ami betűnek számít ebben a felfogásban, case-sensitive (c/cpp/python,java, stb): kisbetű és nagybetű eltér, valid: _asdf1234,xy,t3f2z8,_1,nem valid: 123asd, ékezetes betűk</p>
<p>névkonvenciók: hungarian notation: fFound - float Found vs bFound - bool Found, lpzts Msg - long pointer, zero terminated string, egyre hosszabbá vált, bonyolódott a prefix, CamelCase - érthetőbb a kód, ha kiírjuk a függvényneveket, getSize(), ArrayList java osztalyok, cpp-ben nem kötelező a camelcase használata, STL-ben csupa kisbetűs nevek: unordered_set,push_back,count_if</p>
<p>STL-ben vannak konténerek: <strong>rendezett</strong> adatszerkezetek, set, map, multiset, multimap, log n-es keresés, 1 adatszerkezet a konténerek mögött, amit ténylegesen használnak, __rb_tree,  nyelvi implementáció</p>
<p>g++ hello.cpp -&gt; a.out<br>
nm a.out<br></p>
<p><strong>Konstans szövegliterálok (string)</strong>
"Hello" ennek a típusa const char[6] 'H' 'e' 'l' 'l' 'o' '\0' -zero terminated, 0,1,2,3,4,5
pointer: olyan változó, aminek az értéke memóriacím</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="s">&quot;Hello&quot;</span><span class="p">;</span> <span class="c1">//mintha ez a tömb lenne, pointeren keresztül lekérdezhető</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="s">&quot;Hello&quot;</span><span class="p">;</span> <span class="c1">//c++-ban ez deprecated conversion</span>
<span class="p">}</span>

<span class="c1">//stack szegmens, KONSTANSOKNAK fenntartva</span>
<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;a&#39;</span><span class="p">;</span> <span class="c1">// futási idejű hiba</span>

<span class="kt">void</span> <span class="nf">h</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="s">&quot;blabla&quot;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">strlen</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">fx</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
  <span class="n">strlen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">);</span>
  <span class="n">strlen</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nl">nullpointer</span><span class="p">:</span> <span class="n">nincs</span> <span class="n">valid</span><span class="err">á</span><span class="n">l</span><span class="err">ó</span><span class="n">pont</span><span class="o">?</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">str</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span><span class="o">=</span><span class="s">&quot;blabla&quot;</span><span class="p">;</span>
  <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;e&#39;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// blebla</span>
  <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//ble   addig tart a string amíg nem találjuk meg az első zéró temrinációt</span>
<span class="p">}</span>
</pre></div>
<p>függvényen belül megváltzotatható lokális tömb</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2>3. gyakorlat<br></h2>
<p>bejöttek néhány nyelvi featureök a C -hez képes<br>
const int step = 10; odafigyel a compiler, ez jó dolog<br>
step = 5; // fordítási hibát adna, ha újra definiáljuk a <br></p>
<p>C-nek volt egy fogalma <strong>pointer</strong>, örökölte cpp is, pascal, python, jávában is van, néha letagadják<br>
<strong>a pointer egy olyan változót ír le, aminek az értéke egy memóriacím</strong><br></p>
<p>s<br>
*****<br>
 3      *   &lt;----- p<br>
*****<br></p>
<div class="highlight"><pre><span></span><span class="c1">//legyen</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span> <span class="c1">//címképzés, &amp; address-of operator</span>
<span class="c1">//fundamental operation of a pointer is **dereferencing** (referring to the object pointed to by the pointer) - also called **indirection**</span>
<span class="c1">// the * dereference operator is unary</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 0x24e3b8a2</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// adatot írassuk ki, ami szerepel a tárterületen</span>
<span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">step</span><span class="p">;</span> <span class="c1">//itt fordítási hibát kapunk!!! irassuk ki a hibát</span>
<span class="o">*</span><span class="n">q</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>  <span class="c1">//nem látja a compiler ilyenkor, hogy a stacknek adok értékét</span>
<span class="c1">// mit csinál ilyenkor a cpp</span>
</pre></div>
<p>3 doboz i,j,s 6,2,9</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="mi">9</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="o">=&amp;</span><span class="n">j</span><span class="p">;</span>
<span class="o">*</span><span class="n">ip</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span><span class="c1">//j öt lesz</span>
<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span><span class="c1">//mindkettő engedélyezett</span>

<span class="c1">//két független dimenzió menti konstansság</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cip</span><span class="o">=&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">//mutatott érték most nem változhat</span>
<span class="c1">// A cip azonosítón keresztül a mutatott érték nem változhat</span>
<span class="n">i</span><span class="o">=</span><span class="mi">11</span><span class="p">;</span>
<span class="nl">std</span><span class="p">:</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">cip</span><span class="p">;</span> <span class="c1">// 11</span>
<span class="o">*</span><span class="n">cip</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="c1">// fordítási hibát ad, a compiler nem foglalkozik azzal, hogy a fordítási időben melyik változóra fog mutatni</span>
<span class="n">cip</span><span class="o">=&amp;</span><span class="n">s</span><span class="p">;</span><span class="c1">//változhat, hogy hova mutat</span>
<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">icp</span><span class="o">=&amp;</span><span class="n">j</span><span class="p">;</span><span class="c1">//icp ebben az esetben mindig ugyanoda mutat</span>
<span class="n">icp</span><span class="o">=&amp;</span><span class="n">j</span><span class="p">;</span><span class="c1">//fordítási hiba, fordítási időben ha nem oda mutat, akkor hiba</span>
<span class="o">*</span><span class="n">icp</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="c1">//ez működik</span>

<span class="c1">//ezután jött a mindkét irányba bevezetett konst</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">cicp</span> <span class="o">=&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">//két const, mégis mutathat i-re</span>
<span class="c1">// nem váltzohat meg, hogy hova mutat</span>
<span class="c1">// a mutatott érték a cicp-n keresztül nem változhat meg</span>
<span class="n">i</span><span class="o">=</span><span class="mi">14</span><span class="p">;</span><span class="c1">//valid</span>
</pre></div>
<p>F:másoljuk a std inputot a std outputra!<br>
a b c d \n<br>
a b c d<br>
e f \n<br>
e f<br>
(eof) //dedikált fájl vége jel<br></p>
<p>konzol másolás DOS/Win: copy con<br>
linux cat<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>    <span class="c1">// = értékadás operátor, ciklusfeltételként értékadás!</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">ch</span><span class="o">=</span><span class="n">getchar</span><span class="p">())</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
  <span class="p">{</span>
   <span class="n">printchar</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">// valid</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">y</span><span class="p">){}</span>

<span class="c1">// above condition written out</span>
<span class="n">x</span><span class="o">=</span><span class="n">y</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">!=</span><span class="mi">0</span><span class="p">){}</span>
</pre></div>
<p>precedenciák
std::cout 4+2*5+7</p>
<p>4 + 10
14+7
21
zárójelezni lehet - fenti péládban is a precedencia miatt kell zárójelezni</p>
<p>std::cout (4+2)*5+7
6 30 37</p>
<p>i=4+2*5+7;arra számítok, hogy a jobboldal legyen <strong>előbb kiértékelve</strong>
és utána az értékadás, <strong>kiértékelés precedenciája nagyobb</strong></p>
<p># c-ben a char bájtnyi információt hasnzálták</p>
<div class="highlight"><pre><span></span><span class="c1">//jöhet a cpp változat</span>

<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">noskipws</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">)</span> <span class="c1">// ennek eredménye: std::cin  és a mellékhatás a beolvasás, ennek hatására megváltozik ch</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Kifejezések kiértékelése(call by reference, call by value)<br>
cpp/c ben a kifejezésnek van eredménye<br>
mellékhatás // sideeffect<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">//2</span>
              <span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="c1">//3</span>

<span class="c1">//funkcionális nyelvekben monádokon keresztül lehet kiíratni</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">Fahr</span> <span class="o">&lt;&lt;</span> <span class="n">f2c</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Fahr&quot;</span>
<span class="c1">//std::cout kiértékelés</span>

<span class="c1">//main eredménye 0 lesz, de közben a képernyő a fájljaim megváltoznak</span>
<span class="c1">//programokat a mellékhatások miatt csináljuk</span>
<span class="c1">//std::istream</span>

<span class="c1">//cpp</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span> <span class="c1">//0x143434b4, konverziós operátor van a háttérben, pointer jelenik meg</span>

<span class="c1">//pointerként kiértékelődik a while ciklusfeltétel, ha az eof valamelyik bad flaget leinti, akkor leáll vizsgálja az implementáció, hogy szabad-e még olvasni arról a címről</span>

<span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">//s != 0 ként értékelődik ki!!!</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">complex</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">re</span><span class="p">,</span><span class="n">im</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="c1">//konverziós operátorom</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">re</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="n">im</span><span class="o">=</span><span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">complex</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="c1">//automatikusan meghívja a boolkonverziós operátort</span>
  <span class="p">{</span>
  <span class="p">}</span> 
<span class="p">}</span>
<span class="c1">// mögöttes nyelvi elemek kezdenek csak bonyolulttá válni</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>4. előadás</strong><br>
Láttuk vannak kulcsszavak és azonosítók, konstans szövegliterálokkal elkezdtünk foglalkozni<br>
kimaradt a konstansok fogalma, operátorok és a szeparátorok<br></p>
<p>folytassuk a <strong>konstans</strong>okkal, hogy néz ki a típusrendszerük<br>
pl.: 36 ez egy konstans, az <strong>értéke</strong> 36 a <strong>típusa</strong> int - alapértelmezett egész típus<br>
cpu-ban regiszterek vannak, 32,64, bites a regiszterek (átmeneti tárterületek) mérete<br>
32 bites rendszeren vannak EAX,EBX,ECX,EDX,RAX ezek 32 bites regiszterek  - általános célúak, leírom, hogy x+y pl EAX és EBX bitsorozatokat  összeadja és berakja ECX-be (nem változó-szerű), addig kerül bele, amíg kiértékelődik<br></p>
<p>size of int nincs meghatározva, a nyelv logikája szerint, az int számábrázolásának bájtnyi <br>méretének meghatározását a compilerre bízza, cpp logikája, hogy sizeofint implementációfüggő<br> érték, ezért a leggyorsabb az aritmetikája, legyen hatékony futásidőben és elég számot ki tudjak fejezni, le tudjak írni, implementációfüggő, hogy aritmetikai műveletek<br> minél gyorsabban menjenek végbe<br></p>
<p>compiler a sizeof(int)-et úgy határozza meg, hogy minél gyorsabb legyen, x + y &lt; c + d <br>egyszerűnek tűnik, de a háttérben egy csomó processzorművelet megy végbe, allokáció, regiszterbe másolás stb....<br></p>
<div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span>
<span class="c1">// annyit garantál, hogy az int előjeles egész, negatívakat is tud tárolni</span>
<span class="c1">// long természetesen lassabban fog számolódni</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//tfh van egy 16 bites cpu, int: [-32768,32767] tudja leírni ez a típus</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span><span class="o">+</span><span class="mi">20000</span> <span class="c1">// x értéke nem ismert, mi történik</span>
<span class="c1">//compiler szerint ez int, ha x 15ezer, akkor túlcsordulunk, a negatívak között leszünk</span>
<span class="c1">// emiatt bevezették, hogy ha nincs szükség előjelre, akkor az előjel bit, felhasználható helyiérték bitként</span>
<span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">T</span><span class="p">)</span> 
<span class="c1">//unsigned int: [0,65535]</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">+</span> <span class="mi">20000U</span> <span class="c1">// a konstans típusa usigned, compiler az intet átaalkítja a + bal oldalán is unsigned-ra</span>
<span class="mi">20000L</span> <span class="o">+</span> <span class="n">x</span> <span class="c1">// típusa long int</span>
<span class="mi">158</span> <span class="n">UL</span>
<span class="n">x</span> <span class="o">+</span> <span class="mi">2000U</span> <span class="c1">// miért konvertálódik az int unsigned int-té?</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nl">std</span><span class="p">:</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;OK&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;???!!!!???&quot;</span> <span class="c1">// ezt fogja kiírni</span>
<span class="p">}</span>
</pre></div>
<p>031 == 25<br>
oktális decimális<br>
0xFF, ez már hexadecimális, == 255 decimálisan, bináris alak melyikből állítható elő gyorsabban?<br>
1111 1111                      1111 1111<br>
012U: unsigned int<br></p>
<p><strong>lebegőpontos konstansok</strong><br>
1.42 típusa double, bitsorozattal ki kell fejeznem nem egész részeket, IEEE754 szabvány<br>
van előjelbit 142e-2, előjel, karakterisztika, mantissza; $142\cdot10^{-2}$<br></p>
<div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span> <span class="kt">float</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">)</span>
    <span class="c1">// 6.11F: float</span>
    <span class="c1">// 3.42L: long double</span>
    <span class="c1">// 415e-1L: long double</span>
<span class="c1">// ha ezekkel számolgatunk, akkor hibáink lesznek, mert a tárolásnak limitációi vannak, mindenféle kerekítési hibák</span>
</pre></div>
<p><strong>operátorok</strong><br>
+,prefix és postfix ++,==,=<br>
<strong>kifejezések</strong><br>
x+20000, ennek a <strong>típusát</strong> fordítási időben a compiler kezeli, kiértékelés után <strong>értéket</strong> kap<br>
vannak kifejezések, amelyek mellékhatást (sideeffectet generálnak)<br>
fák -&gt;prognyelvek<br>
ast - abstract szintaxis fa - abstract syntax tree<br>
1+2*3+x   &gt; + [+[1,<em>[2,3]],x]      <br>
infó az AST-ben van<br>
(1+2)</em>(3+x) - compiler AST csinálnak<br>
cpp operátorok precendciája, fejezet<br>
a = b+3;
(a = b)+3;
kifejezések kiértékelés, kifejezés kiértékelés közben megváltoztatja a változó, akkor mi lesz az érték?
mi a melékhatás, mi az eredmény?</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="c1">//5</span>
<span class="n">i</span>  <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span><span class="c1">//6</span>

<span class="c1">//prefix inkrementálás hatékonyabb szokott lenni</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">//postfixet akkor használjuk, ha annak ki is használjuk az eredményét</span>
<span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;)</span>
<span class="p">{</span>
  <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">//szekv pont, ebben a kifejezésben implementálás i++, mindkét irányban kiértékelődhet előbb</span>
            <span class="c1">//olyan sorrendben csinálhatja, ahogy szeretné, heurisztikus forráskód szinten</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// ez már szekvenciapont és frissítve a változók</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">szekv</span> <span class="n">pont</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">)</span> <span class="c1">// logikai operátorok lusták, ha az x&gt;&gt; 10 már hamis akkor a maradék</span>
<span class="p">{}</span>                                 <span class="c1">//nem hajtódik végre, lazy evaluation, éppen ezért szekvenciapont</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="n">itt</span> <span class="p">)</span> <span class="c1">// || szekvenciapont</span>
<span class="p">{</span>   <span class="c1">//kiértékelődik mint y!=0</span>


<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">fel</span><span class="err">ü</span><span class="n">l</span><span class="err">í</span><span class="n">rt</span><span class="p">,</span> <span class="n">x</span> <span class="err">é</span><span class="n">rt</span><span class="err">é</span><span class="n">kad</span><span class="err">ó</span><span class="n">dott</span> <span class="n">y</span><span class="o">-</span><span class="n">nal</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span> <span class="c1">//először kiértékel (eldobja), másodikat kiértékeli,</span>
<span class="p">{}</span>                                              <span class="c1">//és ez alapján lépbe (eredmény a másodszor lesz)</span>
                                               <span class="c1">//függvényhívás előtt ki kell, hogy értkelődjenek a paraméterek</span>
<span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">){}</span>   <span class="c1">// s!=0</span>

<span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">i</span><span class="o">++</span><span class="p">);</span> <span class="c1">// kiértékelódhet mint 3 4 és 4 3</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2>4. gyakorlat <br></h2>
<p><strong>Tömbök,pointerek</strong></p>
<p>cpp-ben a tömb méretét fordítási időben ismerni kell, a tömb egy egybefüggő tárterület</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">v</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// ilyenkor tudja a compiler, hogy öt elemű tömb</span>
<span class="c1">// technikailag valid a következő</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// valaki belenyúl,átírja, eltűnhet egy vessző stb</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">23</span><span class="p">};</span> <span class="c1">// lefordul, három elemű tömb lesz, ahol nem tudjuk mi az a[2]</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span> <span class="c1">// erre már beszól, fordítási hiba</span>
<span class="c1">// növeljük meg eggyel minden elemet</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="o">++</span><span class="n">i</span><span class="p">){}</span>  <span class="c1">//lekérdezzük sizeoffal, hogy hány bájtos a tömb</span>
<span class="c1">// áttérhetünk double-re és akkor itt benne maradt az int, ez nem jó megoldás</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">++</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// megnöveljük eggyel a v[i]-edik elemet</span>
<span class="p">}</span>
<span class="c1">//ha többször kell, akkor csináljunk belőle egy inkrementáló függvényt</span>
<span class="kt">void</span> <span class="n">inc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span> 
<span class="p">}</span>
<span class="c1">//meghívjuk</span>
<span class="n">inc</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// függvénnyel gond lesz, mert inc(&amp;v[0]); -ra fog mutatni az átadott tömb, azaz int *a lett, azaz azt adja meg a sizeof(a) pointere hány bájton lett ábrázolva, így ez független a tömb hosszától, sizeof(a)/sizeof(a[0]) ez nem a tömb hosszát jelenti most már, hanem architektúra függő fix érték </span>
<span class="n">inc</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span> <span class="c1">// helyes meghívás</span>
<span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//compiler nem biztosítja, hogy az argumentumok ténylegesen összetartozó adatok</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
  <span class="p">}</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="n">t</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="c1">//pointernek adjuk értékül</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// miért nem kell &amp;?, mert önmagában t egy memóriacím</span>
<span class="c1">//tudunk pointerekkel spec műveleteket végezni, pointer aritmetika</span>
<span class="o">++</span><span class="n">p</span><span class="p">;</span> <span class="c1">//p-t a következő indexű elemre lépteti</span>
<span class="n">p</span><span class="o">++</span><span class="p">;</span> <span class="c1">//p-t a következő indexű elemre lépteti</span>
<span class="c1">// visszafele is lehet léptetni az előző indexre</span>
<span class="o">--</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span><span class="o">--</span><span class="p">;</span>
<span class="c1">//többszörös léptetés</span>
<span class="n">p</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">//bármi megengedett - túlléptetés is lehetséges, bármi megtörténhet</span>
<span class="n">p</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
<span class="c1">//szabvány szerint ez undefined behavior</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello&quot;</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// itt a &quot;Hello&quot; const char[6] &quot;H&quot;&quot;e&quot;&quot;l&quot;&quot;l&quot;&quot;o&quot;&quot;\n&quot;</span>
<span class="c1">//az első első elemre mutat és &quot;llo&quot; íródik ki</span>

<span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="c1">//pointer aritmetikai formátumban</span>
<span class="o">*</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="c1">//compiler ilyen formába alakítja, tehát így is adhatunk értéket</span>
<span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">v</span><span class="p">)</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="c1">//valid, de akkor</span>
<span class="mi">2</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="c1">// is valid</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">q</span><span class="o">=</span><span class="n">t</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// ilyen formában is működik</span>
<span class="c1">//pointerek összehasonlítása, ugyanoda mutatnak-e</span>
<span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="p">;</span>
<span class="n">p</span> <span class="o">!=</span> <span class="n">q</span><span class="p">;</span> <span class="c1">//negálás</span>
<span class="c1">//értelmezhetők:</span>
<span class="n">p</span><span class="o">&gt;</span><span class="n">q</span><span class="p">;</span> <span class="c1">// p nagyobb indexűre mutat-e mint a q</span>
<span class="n">p</span><span class="o">&gt;=</span><span class="n">q</span><span class="p">;</span>
<span class="n">p</span><span class="o">&lt;</span><span class="n">q</span><span class="p">;</span>
<span class="n">p</span><span class="o">&lt;=</span><span class="n">q</span><span class="p">;</span>
<span class="n">q</span><span class="o">-</span><span class="n">p</span><span class="p">;</span> <span class="c1">// p-t mennyivel kell léptetni, hogy elérje q-t?</span>
<span class="c1">// technikailag 6 elemű tömb a &quot;Hello&quot;</span>
<span class="s">&quot;Hello&quot;</span><span class="o">:</span> <span class="k">const</span> <span class="kt">char</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="c1">//string kezelő függvények</span>
<span class="c1">//C-ben volt egy string.h fejállomány, nem ugyanaz mint a cpp-s</span>
<span class="o">&lt;</span><span class="n">string</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span> <span class="c1">//C</span>
<span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="c1">//cpp, std::string típus</span>
<span class="c1">// C-s string.h cpp-ben: &lt;cstring&gt;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Sanyi&quot;</span> <span class="c1">// ez C, elfogadja ugyan a cpp, de deprecated conversiont ír ki, figyelmeztetés, de nem okoz fordítási hibát, itt sérül a cpp konstans biztonsága,  nem örülünk</span>
<span class="c1">//nézzünk C string utility függvényeket</span>
<span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="mi">5</span><span class="p">;</span> <span class="c1">//hány karakter szerepel a \n -ig</span>
<span class="c1">//nézzük ennek a built in-nek az implementációját</span>
<span class="kt">int</span> <span class="nf">strlen</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">//</span> <span class="n">strlen</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">ezzel</span> <span class="n">megh</span><span class="err">í</span><span class="n">vhat</span><span class="err">ó</span> <span class="o">-</span> <span class="n">nullpointer</span><span class="p">,</span> <span class="n">nem</span> <span class="n">szabad</span> <span class="n">derefer</span><span class="err">á</span><span class="n">lni</span><span class="p">,</span> <span class="n">ez</span><span class="err">é</span><span class="n">rt</span> <span class="n">ez</span> <span class="n">fut</span><span class="err">á</span><span class="n">si</span> <span class="n">idej</span><span class="err">ű</span> <span class="n">hib</span><span class="err">á</span><span class="n">t</span> <span class="n">okozna</span>    
<span class="c1">// if (p==0){return 0}; erre van nyelvi eszköz, de nem akarják validálgatni, hogy nem nulla, ne értékelődjön ki minden hívásnál, romlik a hatékonyság</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">m</span><span class="err">á</span><span class="n">solat</span> <span class="n">p</span><span class="o">-</span><span class="n">r</span><span class="err">ő</span><span class="n">l</span><span class="p">,</span> <span class="n">ez</span> <span class="n">a</span> <span class="n">q</span> <span class="err">é</span><span class="n">s</span> <span class="n">l</span><span class="err">é</span><span class="n">ptetj</span><span class="err">ü</span><span class="n">k</span> <span class="n">a</span> <span class="n">q</span> <span class="n">m</span><span class="err">á</span><span class="n">solatot</span> <span class="n">a</span> <span class="sc">&#39;\n&#39;</span><span class="o">-</span><span class="n">ig</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="c1">// mi van ha a ! jel véletlenül lemarad</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">q</span><span class="p">;</span> 
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">q</span><span class="o">-</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">strlen</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">);</span>  <span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;\0&#39;</span>

<span class="c1">//mi történhet a hibás strlen-nel (ha lemaradt a while feltételből a !, tehát az ott értékadás lesz)</span>
<span class="c1">//1. strlen(&quot;Hello&quot;); futási idejű hiba access violation</span>

<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span><span class="o">=</span><span class="s">&quot;kukumuku&quot;</span><span class="p">;</span> <span class="c1">//9elemű tömb, ez itt megváltozhat  \0ukumuku\0</span>
    <span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">;</span> <span class="c1">// nem ír ki semmit</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// ukumuku, nem karakter veszett el, nincs futási idejű hiba, hanem a \0 az üres string reprezentációja</span>
<span class="p">}</span>

<span class="c1">//megoldás C-ben:</span>
<span class="kt">int</span> <span class="n">strlen</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="sc">&#39;\0&#39;</span> <span class="o">!=</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="c1">// konstans kerül bal oldalra</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">q</span><span class="p">;</span> 
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">q</span><span class="o">-</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//megoldás cpp-ben:</span>
<span class="kt">int</span> <span class="n">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//mutathatok változtatható és nem megváltoztatható tömbre is</span>
  <span class="k">while</span> <span class="p">(</span><span class="sc">&#39;\0&#39;</span> <span class="o">!=</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="c1">// konstans kerül bal oldalra *q = &#39;\0&#39;</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">q</span><span class="p">;</span> 
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">q</span><span class="o">-</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="5.-el&#337;ad&#225;s">5. el&#337;ad&#225;s<a class="anchor-link" href="#5.-el&#337;ad&#225;s">&#182;</a></h2><p>g++ dekl1.cpp dekl2.cpp</p>
<div class="highlight"><pre><span></span><span class="c1">// legyen egy header decl.h</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){};</span>
<span class="c1">//ha csak deklaráltuk volna akkor undefined</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">// legyen egy header decl2.h</span>
<span class="cp">#include</span> <span class="cpf">&quot;decl.h&quot;</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{};</span> <span class="c1">// ne írjunk definíciót headerbe</span>

<span class="kt">int</span> <span class="nf">h</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="n">g</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;decl.h&quot;</span><span class="cp"></span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// int x; mégegyszer már fordítási hiba - one definition rule</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// deklaráció</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// mit csinál f ez már def</span>
<span class="c1">// deklarálni sokszor lehet definiálni csak egyszer</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="n">g</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//linkelesi hiba bemutatva</span>
</pre></div>
<p>h1  h2
 | |  |
cpp   cpp</p>
<p>ii    ii       pp
 o    o        copm
   exe
(ii: fordítási egység)</p>
<p>fordító optimalizál is - inline</p>
<blockquote><p>headerbe kerül mégis a függvény def: helyette: inline void g(int x){};
speciálisan megjelölt g az inline kulcsszóval, valamelyik definíciót választja a compiler - random
az inline csak ajánlás a fordító számára és előfordulhat, hogy figyelmen kívül hagyja</p>
</blockquote>
<p>majdnem minden def egyben deklaráció is - egy kivétel van -&gt; későbbi órákon</p>
<div class="highlight"><pre><span></span><span class="c1">//nyelvtani többértelműségek feloldása</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
  <span class="n">X</span><span class="p">(){}</span> <span class="c1">// konstruktor</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">X</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">X</span> <span class="n">x</span><span class="p">();</span> <span class="c1">// példányosítás(konstruktorhívás) vagy függvénydefiníció? ha valami értelmezhető deklarációként akkor az legyen deklaráció</span>
<span class="c1">// helyes példányosítás</span>
 <span class="n">X</span> <span class="n">x</span><span class="p">;</span>
 <span class="c1">//cpp11 -új init szintaxis</span>
 <span class="n">X</span> <span class="n">x</span><span class="p">{};</span>
 <span class="c1">// bonyolítás</span>
 <span class="n">X</span> <span class="n">x</span><span class="p">(</span><span class="n">X</span><span class="p">());</span> <span class="c1">// copy constructor, de ezt is deklarációként értelmezi a compiler</span>
 <span class="n">x</span><span class="p">;</span>
 <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="c1">// deklaráció függvénytörzsön belül, csak ott látható</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//miért veszélyesek a tömbök</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">t</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//kiindexelve a tömbből az nem definiált viselkedés, szabvány nem mond semmit, hogy mit ccsináljon ilynekor</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//isadmin ott lehet a tömb mellett a stacken</span>
<span class="c1">//return is ott lehet- ez gyakoribb - instruction pointer</span>
<span class="c1">// véget ért, hova kell visszaugrani - ha valaki felül tudja írni a visszatérési címet, akkor szinte bármit meg tud csinálni az illető return oriented programming (ROP)- hekker bármit meg tud csinálni pl ha túlindexeltünk egy tömböt</span>
<span class="c1">// fontos megtalálni az ilyen hibákat</span>
<span class="c1">// g++ arrray.cpp -fsanitize=address -g</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="cp">#mutatók - másik változó memóriacímét tudom beleírni</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// t tömb első elemére mutat</span>
<span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// p mutatót egy integernyivel eltolom - tömbön belül lépegetek egy mutatóval</span>
<span class="c1">//kényelmesebb</span>
<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="c1">//mivel ezek ugyanazok:</span>
<span class="c1">// ezért valid</span>
<span class="mi">1</span><span class="p">[</span><span class="n">p</span><span class="p">];</span> <span class="c1">// is</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">t</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">},{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">},{</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}};</span>
  <span class="c1">// milyen típusúra konvertálódik p - első elemre mutató mutató</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
  <span class="c1">// nem valid int **pp = t; fordítási hiba</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>    <span class="c1">//1</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">//3</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">//5</span>

  <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="kt">int</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//5-re mutat</span>
  <span class="o">*</span><span class="p">(</span><span class="n">ip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="mi">2</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// ez mind ugyanaz</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">//20</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="c1">//4</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="c1">//8</span>
  <span class="c1">//fenntarthatóság - mennyire lehet változtatni a kódot</span>
  <span class="c1">//helyesen sizeof(t)/sizeof(int) // fokkal fenntarthatóbb</span>
  <span class="c1">//mostantól double tömb - már nem fenntartható</span>
  <span class="c1">// sizeof(t)/sizeof(t[0]) ez a fenntartható változat</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//tomb atadasa függvénynek</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="mi">5</span><span class="p">]){</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// mainbe</span>
<span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

<span class="c1">//konstansok</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14159</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">pi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ezért kell const, konstanskorrektséget betartatja a </span>
  <span class="kt">double</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span><span class="c1">//nem fordul, ha lefordulna akkor mutatón keresztól meg lehetne változtatni</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span> <span class="c1">// ezt már engedi</span>
  <span class="c1">//double const *dp = *pi; // is valid</span>
  <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//ezt már nem engedi</span>
  <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">;</span>
  <span class="n">r</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// ez minden probléma nélkül lefordul</span>

 <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span> <span class="n">dcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">;</span>
 <span class="o">*</span><span class="n">dcp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// másik mem területre nem állítható át, mindig ugyanarra a területre mutat</span>
<span class="p">}</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span> <span class="c1">// 6 hosszú konstans karaktertömb, nem kéne lefordulnia, de lefordul</span>
                     <span class="c1">// mostanában ezt a kivételt kivették</span>
  <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span> <span class="c1">//ekkor már segmentation fault, jobb ha nem is engedi, hogy fusson</span>
  <span class="c1">//op rendszer ekzeli a memóriát - program indul, bekerül a fizikai memóriába</span>
  <span class="c1">// megfeleltetés fizikai és virtuális között párhuzamosan</span>
  <span class="c1">// két böngészőt nyitok meg - op rendszer: már fut egy ilyen program és vannak doolgok amik már futnak- miért tölteném be kétszer, oprendszer, konstansok ugyanazok, fizikaiból átkerülnek ugyanazok a teljesen másik virtuálisba, tömörítés memóriában</span>
<span class="p">}</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="5.-gyakorlat">5. gyakorlat<a class="anchor-link" href="#5.-gyakorlat">&#182;</a></h3><p>betű konverzió -&gt; programok<br>
char conv(char ch);<br>
A -&gt; b kb65<br>
B -&gt; t kb 66<br>
h -&gt; H kb 105<br>
gyors megoldás, O(1)<br>
kevés memóriát használjunk<br>
harmadik megoldás - karbantarthatóság<br>
stdmap logN-es keresést biztosít<br></p>
<div class="highlight"><pre><span></span><span class="kt">char</span> <span class="nf">conv</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
                                     <span class="c1">//A B C</span>
<span class="p">{</span>                                    <span class="c1">//65.</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">cnv</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">3.</span><span class="p">..</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">,</span><span class="s">&quot;C&quot;</span><span class="p">};</span> <span class="c1">//nagy tömböt a memóriában tartunk futásidő alatt</span>
  <span class="c1">// static statikus tömb, vezérlés ide eljut, lérehozza, nem kell felszabadítani, ha lejut a végére</span>
  <span class="c1">// nem kell minden egyes karakternél létrehozni a tömböt, valahányszor lérehozzuk, ez a tömb már létre van hozva</span>
  <span class="c1">// a memóriában egész a futás végéig</span>
  <span class="c1">// const mert nem akarjuk, hogy változzon</span>
  <span class="k">return</span> <span class="n">cnv</span><span class="p">[</span><span class="n">ch</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">];</span>  <span class="c1">//tömb elem lekérdezés</span>
             <span class="c1">//$\in[0,255]$</span>
    <span class="c1">//bitenkénti és művelet lekérdezés: 0xff = 255</span>
    <span class="c1">//&amp;csomó 0000és a végén 11111111</span>
    <span class="c1">//                      01100110ch</span>
    <span class="c1">//               0000   01100110  </span>
    <span class="c1">// char típus lehet előjeles és előjel nélküli</span>
<span class="p">}</span>

<span class="c1">//cppban van egy template metaprogramozási lehetőség</span>
<span class="c1">//létrehozható fordítási időben - gyors, de nem biztos, hogy átlag programozó megérti</span>
<span class="c1">//azaz elvileg van lehetőség arra, hogy</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//kevés memória megoldás, konverziós függvény tömbök nélkül</span>
<span class="c1">//erre van egy dedikált vezérlési egység: switch</span>
<span class="k">switch</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="c1">//benne van a vezérlésben, hogyk izárólag összehasonlításra működik, karbantathatóbb</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;A&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span><span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;B&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="sc">&#39;t&#39;</span><span class="p">;</span><span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;b&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="sc">&#39;H&#39;</span><span class="p">;</span><span class="k">break</span><span class="p">;</span>
    <span class="k">default</span> <span class="n">ch</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//konstansok benne vannak, kiszeparálhatók</span>
<span class="c1">//break után nem fog végre hajtódni, ha nincs break, akkor rácsorog a többi case ágra, case ágak összefoghatók</span>
<span class="k">if</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="o">==</span><span class="n">ch</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="n">elseif</span><span class="p">(</span><span class="n">B</span><span class="o">&gt;=</span><span class="n">ch</span><span class="p">)</span> <span class="c1">//valid, mi történik, switchnél ilyen hiba nincs, csak egyenlőségvizsgálat</span>
    <span class="k">return</span> <span class="n">t</span>
    <span class="p">...</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//karbantartható megoldás, hogy ne vezérlési szerkezetekben kelljen gondolkodni</span>
<span class="c1">//from,to tömbök, azonos indexűek</span>
<span class="kt">char</span> <span class="nf">conv</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">from</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">,</span><span class="sc">&#39;h&#39;</span><span class="p">};</span>
  <span class="c1">//karbantarthatóság2.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">from</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">to</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="sc">&#39;T&#39;</span><span class="p">,</span><span class="sc">&#39;H&#39;</span><span class="p">};</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">to</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="sc">&#39;T&#39;</span><span class="p">,</span><span class="sc">&#39;H&#39;</span><span class="p">};</span>

  <span class="c1">//karbantarthatóság1: ez így nem olyan jó</span>
  <span class="c1">//if (sizeof(from) != sizeof(to)):</span>
  <span class="c1">//{</span>
    <span class="c1">//exception?, mit írjak ki?</span>
  <span class="c1">//}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">from</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">from</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">ch</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">to</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//cpp 11 van egy static assert - fordítási időben kirétékelhető értékek alapján forduljon vagy hibát adjon</span>
<span class="c1">// static assert sem jó megoldás</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//jó megoldás 1 tömb</span>
<span class="k">struct</span> <span class="n">Pair</span>  <span class="c1">//~pure C</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">from</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">to</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">char</span> <span class="nf">conv</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">Pair</span> <span class="n">cnv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">},{</span><span class="sc">&#39;B&#39;</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">},{</span><span class="sc">&#39;h&#39;</span><span class="p">,</span><span class="sc">&#39;H&#39;</span><span class="p">}};</span>
                           <span class="c1">//{{&#39;A&#39;,&#39;b&#39;},{&#39;t&#39;},{&#39;h&#39;,&#39;H&#39;}};</span>
                           <span class="c1">// ha törlődi akkor &#39;t&#39; from lesz</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cnv</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cnv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cnv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span> <span class="o">==</span> <span class="n">ch</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">cnv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Pair</span>  <span class="c1">//~pure cpp</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">from</span><span class="p">,</span><span class="n">to</span><span class="p">;</span>
  <span class="n">Pair</span><span class="p">(</span><span class="kt">char</span> <span class="n">f</span><span class="p">,</span> <span class="kt">char</span> <span class="n">t</span><span class="p">)</span> <span class="c1">//lesz a structnak egy konstruktora //nincs viszatérési érték</span>
  <span class="p">{</span>
    <span class="n">from</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">to</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">char</span> <span class="nf">conv</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">Pair</span> <span class="n">cnv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Pair</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),</span><span class="n">Pair</span><span class="p">(</span><span class="sc">&#39;B&#39;</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">),</span><span class="n">Pair</span><span class="p">(</span><span class="sc">&#39;h&#39;</span><span class="p">,</span><span class="sc">&#39;H&#39;</span><span class="p">)};</span>
  <span class="c1">//technikailag még felcserélhető from és to, lehet bonyolítani, le kell-e tiltani konverziókat</span>
  <span class="c1">//bool vagy enumként megkülönböztetni a from és to-t</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cnv</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cnv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cnv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span> <span class="o">==</span> <span class="n">ch</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">cnv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//legyen még egy specifikus probléma:</span>
<span class="c1">//kisbetűből nagybetű</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">noskipws</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ch</span><span class="o">&gt;=</span><span class="sc">&#39;a&#39;</span><span class="o">&amp;&amp;</span><span class="n">ch</span><span class="o">&lt;=</span><span class="sc">&#39;z&#39;</span><span class="o">?</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="sc">&#39;A&#39;</span><span class="p">;</span><span class="n">ch</span><span class="p">);</span>
             <span class="c1">//  logikai kifejezés ? kif értéke(intnek gondolja a compiler);különben</span>
    <span class="c1">//fix táv A 65 a 97</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ch</span><span class="o">&gt;=</span><span class="sc">&#39;a&#39;</span><span class="o">&amp;&amp;</span><span class="n">ch</span><span class="o">&lt;=</span><span class="sc">&#39;z&#39;</span><span class="o">?</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="sc">&#39;A&#39;</span><span class="p">;</span><span class="n">ch</span><span class="p">);</span> <span class="c1">//compiler castingolja a típust és értékelje karakterként</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//test AaBb\n</span>
<span class="c1">//65666....</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="6-.-el&#337;ad&#225;s">6 . el&#337;ad&#225;s<a class="anchor-link" href="#6-.-el&#337;ad&#225;s">&#182;</a></h2><p>cpp memóriamodellje<br>
cpu-n belül regiszterek vannak, nem direkt leképezései a programozási nyelv regisztereinek<br>
nincs annyi regiszter mint amennyi változót tárolunk, ezért a memóriában tároljuk a változóinkat<br></p>
<p>végrehajtási verem (runtime stack) - ez a kényelmes<br>
heap memória<br>
a fenti kettő a legfontosabb<br>
van egy harmadik: statikus tárterület, névtérbeli változókra, globális stb<br></p>
<p><strong>runtime stack</strong><br>
leallokált tárterület (doboz)</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">i</span>  <span class="o">&lt;</span> <span class="n">s</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//if-en belül ++i- ig tart a láthatósága</span>
    <span class="c1">// belső blokkban el lehet fedni egy változót, minél kisebb - szűkebb legyen a láthatóság, ha az elején lenne, minden</span>
   <span class="c1">// akkor átláthatatlan mit miért vezettünk be</span>
    <span class="o">++</span><span class="n">s</span><span class="p">;</span> <span class="c1">// referencia ponthoz képest 4 bájtnyira</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="c1">//referencia ponthoz képest 4 bájtnyira</span>
   <span class="c1">// fordítási időben nem határozzuk meg, hogy mi hol van hanem a referenciaponthoz képest hány bájtnyira lesz</span>
   <span class="c1">// így hatékony</span>
   <span class="c1">//mi mire vontakozik belső paraméter vagy függvény paraméter</span>
   <span class="c1">// egymásba ágyazott for ciklusoknál is jó, nyugodtan használd ugyanazt</span>
   <span class="c1">//élettartam, if-es i attól még hogy csak az if-en belül látható, attól még benne lesz a stackframe-ben</span>
   <span class="c1">//utoljára meghívott függvény van a verem tetején</span>
   <span class="c1">// föntről lefele megnézzük a vermet, látjuk milyen függvényhívási láncolatban vagyunk (stack trace, backtrace), ki </span>
   <span class="c1">//kit hívott meg</span>
  <span class="p">}</span>
  <span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="o">++</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>aktivációs rekord (stackframe) futási időben meghatároz fiókokat (rajz)<br></p>
<table>
<thead><tr>
<th>adminisztratív infó</th>
</tr>
</thead>
<tbody>
<tr>
<td>lokális változók</td>
</tr>
<tr>
<td>bemenő paraméterek</td>
</tr>
</tbody>
</table>
<p>-f stackframe bekerül a verembe meghívásakor (fordítási időben készül el) és bekerül a verem tetjére<br>
-x<br>
-main a verembe kerül<br>
stackpointer - ez állítódik fv hívás elején és végén<br>
láthatósági szabályok, élettartam szabályok<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">rek</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="c1">//rekurzív fv lesz</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">rek</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="o">++</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>    
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">rek</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ez a stackoverflow - végtelen ciklusba kerül</span>
<span class="c1">//compiler létrehoz egy vermet</span>
</pre></div>
<table>
<thead><tr>
<th>végtelen sokszor</th>
</tr>
</thead>
<tbody>
<tr>
<td>admin infó</td>
</tr>
<tr>
<td>x</td>
</tr>
<tr>
<td>rek 2</td>
</tr>
<tr>
<td>admin infó</td>
</tr>
<tr>
<td>x</td>
</tr>
<tr>
<td>rek 3</td>
</tr>
<tr>
<td>admin infó</td>
</tr>
<tr>
<td>x</td>
</tr>
<tr>
<td>4 rek</td>
</tr>
<tr>
<td>main</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">h</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">89</span><span class="p">;</span>

<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="n">h</span><span class="p">();</span> <span class="c1">//h stackframe bekerül, kiír valamit</span>
 <span class="n">h</span><span class="p">();</span> <span class="c1">//stackpointer visszaáll(nem nulláz a memóriában, nem töröl, csak visszamegy a stack pointer az előző állapotba), h-nak új stackframe és 89-et ír ki, előző h hívásból otthagyott 89-et felveszi</span>
      <span class="c1">// nem azért mert ugyanaz az i, hanem mert véletlen ugyanaz a stacket hívjuk meg és ott egy 89-es volt</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// hasonlóan nem ismert t, nem tudjuk, hogy T vagy F-ra fog kiértékelődni</span>
         <span class="c1">// feleslegesen nem fog nullázni a cpp, általában ez a leghatékonyabb memória kezelés</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">&lt;</span><span class="n">x</span><span class="p">)</span>
  <span class="p">{}</span>
  <span class="k">else</span>
  <span class="p">{...}</span>
<span class="p">}</span>
</pre></div>
<p><strong>Limitáció stack esetén</strong><br>
az adatok méretét (összeset) fordítási időben ismerni kell, ezt elég gyorsan el lehet érni, 10 számot olvasunk be vagy 5 ezret, hogyan lehet ezt kezelni?<br>
tömb méret beolvasása:<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// ez nem szabványos cpp</span>
</pre></div>
<p>stack adatok méretét, mennyiségét ismerni kell, <strong>különben: heapet kell használnunk</strong>, <br>
ha ezt szabványosan akarjuk akkor dinamikusan allokáljuk a megfelelő tárterületet<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// new-val allokálunk dinamikusan a stackben, tárterület i darab int számára</span>
  <span class="c1">// futási időben oprendszertől kérünk memóriát, lassabb lesz minden</span>
  <span class="n">del</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span> <span class="c1">// dinamikus allokáció után visszaadjuk</span>
 <span class="c1">// akkor kell ha fordítási időben nem látájuk hány adat kell</span>
<span class="p">}</span>
</pre></div>
<p>F: ha a programozó dinamikus memóriát használ, akkor az a feladata, hogy visszaadja ezt az oprendszer szemszögéből nézve, akkor a feladata, annak biztosítása, hogy felszabadítja, az a programozóra hárul;<br>
heap használat visszavezetése stack használatra?<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">//1db intre, mégpedig a hármasnak, a és b itt pointerek és nem a változó neve!</span>
<span class="k">delete</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//ha itt valaki hív egy fv-t és az dob egy exceptiont, kérdés akkor eljutok a delete kódrészletre</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="c1">//három darab int számára foglal a heapben egybefüggő tárterületet</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">b</span><span class="p">;</span>
<span class="c1">//fordítva használat nem definiált viselkedéshez vezet</span>
<span class="n">a</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">//innentől már lehet újrahasználni</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">b</span> <span class="n">mutasson</span> <span class="n">a</span><span class="o">-</span><span class="n">ra</span>
<span class="c1">//rajzban</span>
<span class="c1">//a -&gt; [3]</span>
<span class="c1">//b -&gt; [][][]</span>
<span class="c1">//a -&gt;</span>
<span class="c1">//b -&gt;</span>
<span class="c1">//a -&gt; [][][][][]</span>
<span class="c1">//b -&gt; [][][][][] ugyanoda mutat mint a</span>
<span class="c1">//delete [b];</span>
<span class="c1">//a -</span>
<span class="c1">//b -</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//tipikus hiba</span>
<span class="kt">void</span> <span class="nf">ml</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//leallokálunknew-val és elveszítjük, hogy ez hol van</span>
  <span class="c1">//sokszor meghívjuk, oprendszer elkezdi használni a swapet, majd összeomlik és újrabootol</span>
<span class="p">}</span>
<span class="c1">//-&gt; ez a memory leak - memóriaszivárgás jelensége</span>
</pre></div>
<p>valgrind tool, memoryleak keresésére, mockolt memóriakezelő featureök<br>
cpp nyelvi konstrukció: <strong>destruktor</strong>(jól működő a nyelvi eszköz), legjobb megoldás, ha osztályba csomagoljuk a dolgokat és nem lehet szivárgás mert van destruktor<br>
emiatt a cpp resource oriented programming és nem oop sourstrup szerint<br>
//ha itt valaki hív egy fv-t és az dob egy exceptiont, kérdés akkor eljutok a delete kódrészletre<br>
erőforrásokat csomagoljuk be egy osztályba, ezért kellenek osztályok C fölé<br>
linux alatt too many open files<br>
más programozási nyelvekben vannak garbage collektorok, figyelgetik a fölöslegesen allokált heap objektumokat, lehet valgrinddel jávában keresgélni memóriaszivárgásokat, nem olyan bonyolult memóriaszivárgást elkövetni<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">s</span><span class="p">;</span>
<span class="k">delete</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//futási idejű hiba, viszont a nullpointer deletálása nem okoz hibát</span>


<span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">q</span><span class="p">;</span>
<span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// épp a pointer nem mutat sehova, így nem mutathat a pointer olyan dolgokra ami már nem az enyém</span>
<span class="k">delete</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// ez nem okoz hibát</span>
</pre></div>
<p>// ezenfelül van egy másik fajta kezelés is: malloc<br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="6.-gyakorlat-10.17">6. gyakorlat 10.17<a class="anchor-link" href="#6.-gyakorlat-10.17">&#182;</a></h2><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span> <span class="c1">//ennek a típusa std::string, ami létrejön a hagyományos &quot;Hello &quot;C stringből, strlen</span>
<span class="c1">//optimalizált osztály és eltakarja a C-s változat alacsony szintű reprezentációját</span>
<span class="c1">//ehhez hozzá lehet adni, összehasonlítani</span>
<span class="c1">//s.str(); //std::string kovert to C string</span>
<span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;H&#39;</span><span class="p">,</span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>
<span class="c1">//itt nem változhat a tömb mérete</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span> <span class="n">a</span><span class="o">==</span><span class="s">&quot;Hello&quot;</span> <span class="p">)</span> <span class="c1">//ez hamis állítás lesz, pointerré konvertálódik és első elemére mutat</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;OK&quot;</span><span class="p">;</span>
<span class="p">}</span>




<span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">back</span><span class="p">(</span><span class="sc">&#39;!&#39;</span><span class="p">);</span> <span class="c1">// ennek dinamikusan tudom változtatni a méretét</span>
<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;Wald&quot;</span><span class="p">;</span>
</pre></div>
<p><strong>referenciák</strong> fogalma a cpp-ban, ez határozottan nem létezett C-ben</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">//címképzés</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//7 lett, átírhattuk, referenciák valami hasonlók lesznek</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//itt r az a változónak az álneve, mégegy nevet kap  a,r [6] doboz rajz</span>
<span class="c1">//mindig ugyanannak az álneve, másik doboz k[3]</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//8</span>
<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span><span class="c1">// ar[3] k[3]</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// arc[3] k[3], c-n keresztül a hivatkozott tárterület nemváltozhat meg</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// fordítási hibát adna</span>
<span class="c1">//nagyon hasonló a két fogalom jöjjön egy összehasonlítás</span>
</pre></div>
<table>
<thead><tr>
<th>pointer</th>
<th>referencia</th>
</tr>
</thead>
<tbody>
<tr>
<td>c/cpp</td>
<td>cpp</td>
</tr>
<tr>
<td>memóriacím</td>
<td>álnév</td>
</tr>
<tr>
<td>címképzés,dereferálás</td>
<td>itt nincs címképzés, dereferálás</td>
</tr>
<tr>
<td>változhat, hogy hova mutat, ha csak le nem tiltom</td>
<td>mindig ugyanannak az álneve, nem tudjuk megváltoztatni</td>
</tr>
<tr>
<td>Nullpointer</td>
<td>miért vezetnék be álnevet arra ami sehova nem mutat, nincs létjogosultsága</td>
</tr>
<tr>
<td>nem kötelező inicializálni</td>
<td>kötelező inicializálni</td>
</tr>
<tr>
<td>pointer aritmetika</td>
<td>nincs analóg</td>
</tr>
<tr>
<td>függvény pointerek</td>
<td>-</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span>
<span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//nem mutat sehova</span>
<span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="c1">//pointer intit</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//fv ami megnöveli egy változó értékét,inkrementálás</span>
<span class="c1">// C implement</span>
<span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="c1">//átveszem a p értékét</span>
<span class="p">{</span>
  <span class="c1">//if(p!=0){} //bonyolódik a kód</span>
  <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">//t által mutatott terület megnövelése    </span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
<span class="c1">//cpp implement</span>
<span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="c1">// r álnéven keresztül növelem meg az értéket, nem érdekel mi van ott</span>
    <span class="c1">//referenciák kényelmessé teszik a függvények paraméterezését</span>
<span class="p">{</span>
  <span class="o">++</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">inc</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">//mindkettő jó megoldás, de kifejezőbb a cpp és biztonságosabb</span>

<span class="c1">//ha inc(0); hívom meg, akkor elszáll a C-s, a cpp nem</span>


<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// az y-ról készült másolatot növeli meg, érték szerinti paraméterátadás</span>
<span class="c1">//külsőre nem volt hatással, mert másolaton dolgozott a függvény</span>
<span class="p">{</span>
  <span class="o">++</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">// ekkor y ==2 marad</span>


<span class="c1">//jöjjön három fv, nem tudjuk mit csinálnak belül</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> <span class="c1">//érték szerint veszi átt a paraméterét</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span> <span class="c1">//referencia szerint</span>
<span class="kt">void</span> <span class="nf">h</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span><span class="c1">//konstans referencia szerint várják az int-et</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="c1">//fordul, tudjuk a == 2 (a kettő marad)</span>
<span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span><span class="c1">//fordul</span>
<span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="c1">//fordul</span>
<span class="n">f</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">);</span><span class="c1">//fordul, megnövelt érték kerül bele</span>
<span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span><span class="c1">//fordul, a növeli, de a régi értéke kerül bele</span>

<span class="c1">//f fordul, létrejön egy új lokális változó (i), ebbe belemásolódik az aktuális paraméter értéke</span>
<span class="c1">//költségek: másolás(copy konstruktor), felszabadítás</span>
<span class="c1">//void f(std::vector&lt;int&gt; v){}, üres törzs, de sok minden történik a háttérben, tehát felhasnzálói költsége van a másolásnak a függvény hívásakor, int esetén nincs igazán</span>
<span class="c1">//copy konstruktor bonyolult lehet, általában nem tudjuk mit csinál</span>

<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="c1">//átadható, fordul ÉS x értéke megváltozhatott</span>
<span class="c1">//pl int s; </span>
<span class="c1">//std::cin &gt;&gt; s; ez is egy referencia szerinti pm</span>
<span class="n">g</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="c1">//fordítási hiba, r álnéven keresztül nem változtatható meg az 5 értéke</span>
<span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span><span class="c1">//fordítási hiba, nincs értelme x+4 eredményét álnéven keresztül megváloztatni</span>
<span class="n">g</span><span class="p">(</span><span class="o">++</span><span class="n">x</span><span class="p">);</span><span class="c1">//fordul megnövelt x-re álnéven keresztül</span>
<span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">++</span><span class="p">);</span><span class="c1">//ford hiba, mi volt x értéke növelés előtt, mit csináljon a referencia egy értékkel</span>

<span class="c1">//g: álnéven(r) keresztül a külső változóval dolgozik</span>
<span class="c1">//NINCS másolási, felszabadítási költség</span>

<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">h</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="c1">//fordul, hiába hivatkozik, nem használja ki y megváltoztathatóságát</span>
<span class="c1">//A h fv c álnéven keresztül y-nal dolgozik, de y értéke nem változhat meg</span>
<span class="n">h</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="c1">//fordul, c álneve lesz a 4nek</span>
<span class="n">h</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span><span class="c1">//fordul létrehoz egy álnevet amin keresztól úgy sem lehet megváltoztatni</span>
<span class="n">h</span><span class="p">(</span><span class="o">++</span><span class="n">y</span><span class="p">);</span><span class="c1">//fordul</span>
<span class="n">h</span><span class="p">(</span><span class="n">y</span><span class="o">++</span><span class="p">);</span><span class="c1">//fordul</span>
<span class="c1">//NINCS másolási, felszabadítási költség</span>
<span class="c1">// általában jobban járunk a konstans referencia szerinti értékátadással f &lt;-&gt; h</span>
<span class="c1">//konstans referenciával dolgozzunk</span>
</pre></div>
<p>gyakorló feladat jön erre a témakörre:</p>
<div class="highlight"><pre><span></span><span class="c1">//eof-ig számokat olvasunk be, nem kérdezzük meddig, írjuk ki rendezetten</span>
<span class="c1">//bináris keresőfa adatszerkezet erre jó</span>
<span class="c1">//node 6 //root</span>
<span class="c1">//node 3 node 8</span>
<span class="c1">//node 5 node 7</span>
<span class="c1">//inorder bejárás - rekurzíve meghívjuk</span>
<span class="c1">//    3,5,6,7,8 bal részfa bejárás befejeződött</span>
<span class="c1">//pont rendezetten írja ki</span>

<span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="c1">//két nodera mutató pointer</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="c1">//beszúróművelet</span>
<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="c1">//itt a hiba csak a másolat változik</span>
<span class="c1">//helyes:</span>
<span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">Node</span> <span class="o">*&amp;</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="c1">//C-ben mi volt- kellett egy plus pointer</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1">//n!=0</span>
    <span class="c1">//n-&gt;val, n általá mutatott faelemet vesszük, (*n).val, root-&gt;right-&gt;left-&gt;val</span>
    <span class="p">{</span>
      <span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">?</span> <span class="n">n</span><span class="o">-&gt;</span><span class="nl">left</span><span class="p">:</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//megyünk le a fában amíg el nem érünk egy nullpointert</span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span><span class="o">*</span><span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>   
<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="err">&#39;&#39;</span><span class="p">;</span>
     <span class="n">print</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
     <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//kezdetben a root nullpointer</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">print</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//indítás, gépelem 7,2,8,3,6</span>
<span class="c1">//promptot visszaadja</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="7.-gyakorlat-10.24">7. gyakorlat 10.24<a class="anchor-link" href="#7.-gyakorlat-10.24">&#182;</a></h3><p>téma: a cpp standard template library (STL)<br>
rendezni akartunk néhány számot, szívtunk paraméterátadásokkal, ha mindig ezt kellene csinálni akkor nem lenne tól produktív<br>
vannak előre megírt algoritmusok és adatszerkezetek<br>
konténerek<br>
algoritmusok 60-80, ebből ngéyet megnézünk<br>
iterátorok<br>
számtalan stl doc elérhető neten, pl sgi.com\/tech\/stl<br>
de a stroustrup könyvben is van leírás az STL-ről, de szokjunk hozzá az angol dokumentációkhoz<br>
szünetben nézzünk bele 1-2 stl dokumentációban, vizsgán lehet STL-t hasnzálni, sikeres a vizsga, ha jól tudunk választani konténert, algoritmust és iterátort<br>
letisztult a kód, sokkal világosabb a kód, ha szabványos STL-t használjuk<br>
mindenki ismeri az STL kódokat, <br>
ha csak a vektort ismerem, akkor az nem lesz túl kényelmes<br>
nézzük meg, hogy vizsgán találjuk meg a megfelelőeket<br>
műveletigény garancia<br>
<strong>F</strong> eof-ig számokat olvasunk be, írjuk ki rendezetten, múlt órai STL használatával<br>
map, set említette</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;vector&gt; //tömbszerű, tömb mérete nem volt trükkök nélkül változtatható, itt a vektor tud dinamikusan méretet változtatni</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="c1">//1. megoldás: vektorral oldjuk meg</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//leggyorsabb bepakolási mód, amortizált konstans idejű: van egy leallokált tárterüle (capacity), míg a size kisebb mint capacity addig nincs gond, utána se mert allokál egy kétszer akkorát majd átpakol mindent és átállítja a pointert és felszabadítja a korább lefoglalt tárterületet, ha épp be van telve a kapacitás, akkor nem lesz konstans idejű, ezért minden átpakol és ezért lassabb lesz egy kicsit a push_back művelet, vannak esetek amikor pont nem konstans idejű</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="err">&#39;&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//egyszerűsítések:</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="err">&#39;&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">print</span><span class="p">);</span> <span class="c1">//összes elemmel meghívjuk a print fv-t</span>
<span class="c1">//vektor létrehozás a std inputról érkező input intervallumból, üres vektro helyett</span>

<span class="c1">//két pm a vektor létrehozásához, kostruktor, include iteratorból</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">),</span>  <span class="c1">//ez olyan mint &quot;std::cin.begin()&quot;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>         <span class="c1">//ez olyan mint &quot;std::cin.end()&quot;</span>
<span class="c1">//másolás std outputra</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">));</span> <span class="c1">//szóközökkel elválasztva</span>
<span class="c1">//mindent sikerült stl-esíteni</span>
</pre></div>
<p>múlthéten felépítettünk egy keresőfát, szívás volt, stl-esítsük<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;set&gt; //rendezett halmaz, multiset egyből több is lehet rendezett</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">),</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">//multiset rendezett kész a megoldás</span>
  <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//betűstatisztika - almafa std::cin-ről(eofig), melyik betűből mennyi van táblázat std::cout-ra</span>
<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>               <span class="c1">//karaktereket tárol</span>
    <span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">stat</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">),</span>
      <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span>
   <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span><span class="o">=</span><span class="n">stat</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">i</span><span class="o">!=</span><span class="n">stat</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="c1">//valid  a ++i is</span>
        <span class="c1">//aaaflm mettől meddig tartanak [) a részintervallumok</span>
        <span class="c1">// ez az equal_range az stl-ben: lower_bound és upper_bound</span>
        <span class="c1">//</span>
   <span class="p">{</span>                           <span class="c1">//logaritmikus számolási igény, gyorsabb mint std::count</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">stat</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                 <span class="c1">//pontosan mint a pointer</span>
     <span class="n">i</span><span class="o">=</span><span class="n">stat</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="c1">//az uppertől folytassuk a ciklust</span>
     <span class="c1">//validnak tűnik az i+= stat.count(*i), de nem gyors vektor, tömb oké lenne</span>
   <span class="p">}</span>
 <span class="c1">//volt olyan szó, hogy pointerhez hozzá tudunk adni n-et, ptr += n &lt;- vektronál ez működik</span>
 <span class="c1">// nem tudok itt csak ész nélkül odébb lépni</span>

<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//nézzünk egy másik megoldást</span>
<span class="c1">//van egy kulcs és ahhoz értékeket tárolunk el: map(kulcs szerint rendezett)</span>
<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
         <span class="c1">//konstans referencia érték szerinti paraméter átadás</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="c1">//kulcs érték párok kezelése</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">stat</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">++</span><span class="n">stat</span><span class="p">[</span><span class="n">ch</span><span class="p">];</span> <span class="c1">//ch-hoz tartozó asszociatív tömbelemet növeljük</span>
                  <span class="c1">//nincs indexelés, kulcs szerint rendezett, logaritmikus futási idő</span>
    <span class="p">}</span>             <span class="c1">//megváltozik a map, nem olvasási művelet</span>
                  <span class="c1">//látszólag hagyonmányos indexelés, de semmilyen szempontból nem az</span>

    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">stat</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">print</span><span class="p">);</span> <span class="c1">//sokféle különböző megoldás, mikor elegánsabb, melyik a leggyorsabb, melyik számomra a legkényelmesebb</span>
<span class="p">}</span>
<span class="c1">//nem tudunk mindent végignézni, transform miben más mint a copy</span>
<span class="c1">//minél többet ismerünk az stl-ből, annél egyszerűbb a vizsga</span>
<span class="c1">//még van idő az stl-lel való ismerkedéshez</span>
<span class="c1">//szünet után folytatás innen</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="11.06-el&#337;ad&#225;s">11.06 el&#337;ad&#225;s<a class="anchor-link" href="#11.06-el&#337;ad&#225;s">&#182;</a></h2><p><strong>láthatóság és élettartam szabályok</strong>
láthatóság változó honnan hivatkozható
élettartam futásidejű fogalom, futás során mikor szűnik meg a változó</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// függvényen kívül is lehet definiálni x változót, ez globális változó</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="o">++</span><span class="n">y</span><span class="p">;</span><span class="c1">// y  láthatóság ez a sor és az előző, külső x idáig hivatkozható, majd a belső blokkban el lesz fedve</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//belső blokkban egy ugyanolyan nevű változó, láthatóság ez a sor és következő</span>
    <span class="o">++</span><span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">(){</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// fordítási hiba, nincs belső blokk, nem tudom elfedni az először definiált s-et</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">//globálisra hivatkozik</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="o">++</span><span class="n">y</span><span class="p">;</span><span class="c1">//létezik a külső y, memóriában van, csak forráskód szinten nem tudom meghivatkozni</span>
  <span class="p">}</span>
  <span class="o">++</span><span class="n">y</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">h</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">++</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// lokális értékét adom hozzá</span>
  <span class="o">++</span><span class="n">y</span><span class="p">;</span>
  <span class="o">::</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// eszköz a globális elérésére</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//b.cpp, az a.cpp globális x változójára akarok hivatkozni</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">max</span><span class="p">()</span>
<span class="p">{</span>
  <span class="o">++</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//c.cpp, static én csak a c.cppből akarom, hogy elérhető legyen</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span> <span class="c1">//C-s maradvány, valid</span>
<span class="c1">//cpp-os szintén valid, de van rá másik megoldás, berakjuk egy névtelen névtérbe (névtelen névtér)</span>
<span class="k">namespace</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//::s</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">A</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//A::x //minősített neve</span>
  <span class="kt">void</span> <span class="nf">f</span><span class="p">();</span> <span class="c1">//A::f()</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">f</span><span class="p">()</span> <span class="c1">//belekerültem A névtérbe tehát a blokk x változója az A::x lesz</span>
<span class="p">{</span>
  <span class="o">++</span><span class="n">x</span><span class="p">;</span> <span class="c1">//A::x-et inkrementálja</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="o">++</span><span class="n">x</span><span class="p">;</span> <span class="c1">//felette lévőt növeli</span>
<span class="p">}</span>
<span class="c1">//névterek egymásba ágyazhatóak</span>
</pre></div>
<p>élettartam szabályok <br>
kérdések: mikor jön létre a változó, mikor szűnik meg?
mikor jön létre egy objektum - konstruktor futását jelenti objektumoknál, egy intnél ennek nincs jelenetősége
mikor szűnik meg az objektum - destruktor lefutását jelenti, kettő között használhatom-e a változómat, lefoglalt memóriaterületet</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="c1">// automatikus változó</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//külső x</span>
  <span class="o">++</span><span class="n">x</span><span class="p">;</span><span class="c1">//külső x</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="c1">//külső x</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">x</span><span class="p">;</span><span class="c1">//külső x</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//belső x</span>
    <span class="o">++</span><span class="n">x</span><span class="p">;</span> <span class="c1">//belső x</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">//aktivációs rekordban ott lesz, de ténylegesen a konstruktor akkor fut le ha beléptünk az if ágba, oprendszernek visszaadja az allokált területet</span>
<span class="n">az</span> <span class="k">if</span> <span class="n">v</span><span class="err">é</span><span class="n">g</span><span class="err">é</span><span class="n">n</span> <span class="n">lefut</span> <span class="n">a</span> <span class="n">destruktor</span>
  <span class="p">}</span>
  <span class="o">++</span><span class="n">x</span><span class="p">;</span> <span class="c1">//külső x</span>
<span class="p">}</span><span class="c1">//stacken ott van mindkettő, futás közben nem változik a  stackframe</span>
</pre></div>
<p><strong>automatikus változók</strong> szabálya: <br>
létrejönnek: a vezérlés eléri a deklarációt<br>
megszűnek: a vezérlés elhagyja a deklaráló blokkot<br></p>
<p><strong>globális/névtérbeli/osztály statikus tag</strong><br>
létrejönnek: a program indulásakor<br>
megszűnnek: a program futásának végén<br></p>
<p><strong>dinamikus változók</strong></p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="c1">//mit csináljon a pointer, ha elhagyta a blokkot</span>
<span class="p">{</span>
 <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
 <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="c1">//vezessük vissza az automatikus változókra, mert az mindenképpen lefut (ez lesz a konstruktor)</span>
 <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span><span class="c1">//én feladatom felaszabadítani</span>
 <span class="c1">//mi biztosítja azt, hogy a delete-ig eljut a delete-hez</span>
 <span class="c1">//előtte van egy foo(), ami dob egy kivételt és nem jut el</span>
 <span class="c1">// a delete-et meg rakjuk bele a destruktorba</span>
 <span class="c1">//RAII a táblán</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="o">*</span> <span class="nf">mem</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">//pointer rámutat a 4 elemű tömbre</span>
  <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span><span class="c1">//anti-pattern</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">mem</span><span class="p">();</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">s</span><span class="p">;</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">//dinamikus allokálás a háttérben</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>   <span class="c1">//érték szerint adjuk vissza, copy konstruktorát meghívja</span>
    <span class="c1">//kiadja utána a területet a felhasználó számára</span>
<span class="p">}</span><span class="c1">//cpp11 move szemantika</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">b</span><span class="p">;</span><span class="c1">//valamelyiken keresztül fel kell szabadítani különben memóriaszivárgás lesz</span>
</pre></div>
<p><strong>dinamikus változók/objektumok:</strong><br>
létrejönnek: amikor a new kiértékelődik<br>
megszűnik: a delete kiértékelődik<br></p>
<p>tömbelemek:<br>
létrejönnek: a tömb létrehozásakor<br>
megszűnik: a tömb megszűnésekor<br></p>
<div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="c1">//ennek a hat elemnek létre kell jönnie  mindenféle utasítás? nélkül</span>
</pre></div>
<p>osztály adattagok:<br>
létrejönnek: a tartalmazó objektum létrejön<br>
megszűnik: a tartalmazó objektum megszűnésekor<br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="11.07.-gyakorlat">11.07. gyakorlat<a class="anchor-link" href="#11.07.-gyakorlat">&#182;</a></h2><p>objektum orientált nyelvi eszközök cpp<br>
elmezendő kódrészlet:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>

<span class="p">};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">X</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//default ctor(constructor), létrehozott valid objektum ezen a ponton, értékszemantika</span>
  <span class="n">X</span> <span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="p">;</span> <span class="c1">//b osztály létrehozása, ez  az a másolata, X b(a)(paraméteres konstruktor, most vexing pairs); copy ctor, itt már két!!! objektum van, nem kell new mint javában egy külön object létrehozásához</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//itt mit történik? értékadás</span>
  <span class="n">X</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">//2db címképző operátor van más más fut le ha const X - később lesz szó erről részletesen</span>
  <span class="c1">//sizeof(X) == sizeof(char)</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//VS JAVA</span>
<span class="n">X</span> <span class="n">a</span><span class="o">;</span><span class="c1">// X a = null és nincs mögötte objektum, referenciaszemantika</span>
<span class="n">a</span> <span class="o">=</span>  <span class="k">new</span> <span class="n">X</span><span class="o">();</span> <span class="c1">// egy objektum</span>
<span class="n">X</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="c1">// 1 objektum két hivatkozással</span>
</pre></div>
<p>default(alapértelmezett) ctor<br>
paraméter nélkül hívható ctor<br>
nyelvi konstrukciók/ szabványkönyvtár rendszeresen hasnzálja<br>
ctor feladata az, hogy ha lefutott mint művelet, akkor az objektum működőképes állapotban legyen<br></p>
<div class="highlight"><pre><span></span><span class="n">X</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="c1">// 5 db def ctort  meghív</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 1db def ctor hívás</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="c1">//def ctor</span>
<span class="c1">//lesznek default konstruálható eszközök, pl az osztály az, ez jó vagy nem, hogy default konstruálható</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;blabla&quot;</span><span class="p">;</span>
 <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
 <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;e&#39;</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>mikor default konstruálható egy típus, mikor hívható meg a def ctor<br></p>
<blockquote><p>Ha írunk egyet<br>
semmilyen ctort nem írunk<br></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Foo</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// ez a def ctort hívja meg, nem írunk üres zárójelet a most vexing parse miatt</span>
  <span class="n">Foo</span> <span class="n">a</span><span class="p">();</span> <span class="c1">// deklarációnak értelmezné a compiler, fv ami Foo vissztérési értékű</span>
<span class="p">}</span>
</pre></div>
<p>cpp11 uniform initialization: Foo b{}; def ctor hívás a cpp11 szabvány szerint<br></p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">A</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// nem default konstruálható, mert meg kell adni a paramétert</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// így def konstruálható;</span>
  <span class="n">A</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// ez már fordítási hiba lenne</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Complex</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{}</span>
    <span class="c1">// meghívható 0, 1 és 2 pm-rel is, mivel default értékeket adtunk meg</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Complex</span> <span class="n">a</span><span class="p">(</span><span class="mf">1.6</span><span class="p">,</span><span class="mf">7.3</span><span class="p">);</span>
  <span class="n">Complex</span> <span class="n">b</span><span class="p">(</span><span class="mf">3.5</span><span class="p">);</span><span class="c1">//valós rész a 3.5-ös lesz, életbe lép az i=0.0 default érték</span>
  <span class="n">Complex</span> <span class="n">c</span><span class="p">();</span> <span class="c1">// mindkét pm-nél van alapértlmezett érték</span>
<span class="p">}</span>
</pre></div>
<p><strong>copy ctor, értékadás operátor</strong>
mindig léteznek</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Complex</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">re</span><span class="p">,</span><span class="n">im</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Complex</span> <span class="n">a</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">7.5</span><span class="p">);</span>
  <span class="n">Complex</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//szépen átkerül a két szám a b üres objektumba objektum, copy konstruktorral másol</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// szintén átkerülnek a számok, értékadóoperátorral másol</span>
<span class="p">}</span>
</pre></div>
<p>Vector: capacity,size,ptr<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>    
  <span class="n">Vector</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">Vector</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// cap size ptr átmásolódik, mi van ha a b belső blokkban van, bajok lehetnek mert ptr miatt a két vektor objektum ugyanazzal a pointerrel dolgozik, ilyenkor szokás copy ctort írni</span>
<span class="c1">//alapértelmezett access modifier private a classnél ezért írjuk ki a publicot, structnál a default az public</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Vector</span> 
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Vector</span><span class="p">()</span> <span class="p">{}</span>
    <span class="c1">//Vector (Vector rhs) {}</span>
    <span class="c1">//Vector (Vector &amp;rhs) {}//nem tehetek mást mint referencián keresztül</span>
    <span class="n">Vector</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span><span class="c1">// ez a helyes megoldás</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Vector</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">Vector</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// Vector rhs=a; futna le végtelen ciklus mert itt is copy hívódik meg</span>
<span class="p">}</span>
</pre></div>
<p>auto pointer vs smart pointer<br>
másolás $\rightarrow$<br>
auto pointer ez törlődik mert egyetlen kell,hogy maradjon ami felelős a többi az null pointerre állítódik a heapen ezzel az lett a gond<br></p>
<div class="highlight"><pre><span></span><span class="c1">//operator=</span>
<span class="c1">//a = b; nem hívódik meg a copy ctor, helyette az operator= operál: a.operator=(b)</span>
<span class="n">Vector</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//Vector referenciával tér vissza</span>

<span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">//törzs nélküli copy ctor</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">//törzs nélkül</span>

<span class="c1">//így még friendekkel sem hívhatók meg a private műveletek, ha nincs törzs akkor linkelési hibát kap az ember</span>
<span class="c1">//cpp 11:= delete;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
   <span class="o">~</span><span class="n">X</span><span class="p">(){}</span> <span class="c1">//dtor</span>
<span class="p">};</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="11.13-el&#337;ad&#225;s">11.13 el&#337;ad&#225;s<a class="anchor-link" href="#11.13-el&#337;ad&#225;s">&#182;</a></h2><p>beadandó: <a href="http://patakino.web.elte.hu/pny2/beadando.html">http://patakino.web.elte.hu/pny2/beadando.html</a><br></p>
<p>alprogramok, paraméterátadás</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="c1">//formális paraméter 2 db</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">a</span><span class="p">;</span>
  <span class="c1">//ez egy alprogram</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>  
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mi">5</span><span class="p">));</span> <span class="c1">//meghívásnál aktuális paramétereket adunk meg - argumentum</span>

<span class="p">}</span>
</pre></div>
<p>érték szerinti pm átadás<br>
cím szerinti pm átadás<br>
(van név eredmény szerinti stb is)<br></p>
<p><strong>érték szerinti (pass by value)</strong> átadás<br>
pl C<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="c1">//érték szerint átadjuk</span>
<span class="p">{</span>
  <span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="n">megn</span><span class="err">ö</span><span class="n">velhetj</span><span class="err">ü</span><span class="n">k</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">//létrejön egy új lokális változó, ebbe belemásolódik az aktuális paraméter értékem de s értéke nem változik meg, függvény visszatérése után meg is szűnik a lokális változó</span>
  <span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">f</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
  <span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="o">++</span><span class="p">);</span> <span class="c1">//s=2 adódik át, de a mainben s most már 3</span>
  <span class="n">f</span><span class="p">(</span><span class="o">++</span><span class="n">s</span><span class="p">);</span> <span class="c1">//s=3 adódik át, mainben s most már 3</span>
<span class="p">}</span>
<span class="c1">//C-ben paraméterként megkapott tömb rendezése</span>
<span class="kt">void</span> <span class="nf">sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">[])</span> <span class="p">{}</span> <span class="c1">// void sort(int *v,int n), át kellett adni a méretet is, pointer miatt ez az infó elveszett</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">//valójában helyette sort(&amp;a[0]); pointert átadni olcsóbb</span>
  <span class="c1">//ezért</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="p">}</span>
<span class="c1">//inkrementálás C-ben</span>
<span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// hogy ezt ne kelljen minden alkalommal, ezért a cím szerinti átadás jött be</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="n">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span> <span class="c1">//eredménye i == 7, címképzés művelete (más mint a referencia!)</span>
  <span class="n">inc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">// nullpointer  dereferálása miatt leállna</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
  <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p><strong>cím szerinti</strong> (pass by reference) átadás<br></p>
<div class="highlight"><pre><span></span><span class="c1">//c++ referenciák, referenciákat kötelező inicializálni!!!&lt;br&gt;</span>
<span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//a ketteshez a memóriában r és s is tartozik;</span>
<span class="o">++</span><span class="n">r</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// ez alapján void inc</span>

<span class="kt">void</span> <span class="nf">inc</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">++</span><span class="n">r</span><span class="p">;</span><span class="c1">//dereferált pointer ezen a ponton</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
 <span class="n">inc</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="c1">// x==4</span>
<span class="p">}</span>
</pre></div>
<table>
<thead><tr>
<th>pointer c/cpp</th>
<th style="text-align:center">referencia cpp</th>
</tr>
</thead>
<tbody>
<tr>
<td>memóriacím</td>
<td style="text-align:center">álnév</td>
</tr>
<tr>
<td>dereferelás/címképzés</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>nullpointer</td>
<td style="text-align:center">- (nincs nullreferencia, referencia mindig valaminek az álneve)</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">kötelező inicializáció</td>
</tr>
<tr>
<td>változhat, hogy hova mutat</td>
<td style="text-align:center">nem változhat, hogy minek az álneve</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><span class="c1">//két integer értékének felcserélése</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="c1">//lefordulna ampersand nélkül is, mi lenne ekkor nem csrélődne</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//számokat akarok std outputról egy vektorba EOF-ig</span>
<span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span><span class="c1">//ref jel nélkül is lefordul, másolatra fog végrehajtódni ha nincs ampersand</span>
<span class="p">{</span>
  <span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>    

<span class="c1">//vagy</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">()</span> <span class="c1">//kiírva akkor megpróbálok egy olyat visszaadni ami már nem létezi</span>
<span class="p">{</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">read</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">inc</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">++</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">inc</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span><span class="c1">// inc(5), referencia változót, aminek címe van, fordítási hibát ad</span>
  <span class="n">inc</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span><span class="c1">//fordítási hiba, mert a referencia változót vár paraméterként</span>
  <span class="n">inc</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="c1">//fordul és r álnéven keresztül s-sel dolgozik az inkrementáló függvény</span>
<span class="p">}</span>
</pre></div>
<p><strong>const referencia</strong><br>
sok esetben jobban működik, mint az érték szerinti<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="c1">// ez a konstansság, c-n keresztül hivatkozott tárterület nem változhat meg</span>
<span class="p">{</span> <span class="c1">//itt nincs másolási költség, hiszen referencia, hatékonyabb ezért, mint az érték szerinti pm átadás</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">// a c álnéven keresztül nem lehet megváltoztatni, de valid a függvényhívás, t az 6 marad</span>
  <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// a c lehet a 3 álneve, valid</span>
  <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span><span class="c1">// valid, c álnéven keresztül kiolvasom a t temporális értékét</span>
  <span class="c1">//hasonlóan</span>
  <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">++</span><span class="p">);</span>
  <span class="n">f</span><span class="p">(</span><span class="o">++</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>léteznek makrók<br></p>
<div class="highlight"><pre><span></span><span class="cp">#define SQ(x) ((x)*(x))</span>
<span class="cp">#define INC(x) ++x</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">INC</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">// y == 3 lesz, makróknál megváltozik a változó</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">SQ</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//25-öt kiír, makróparaméterezés sajátossága, hogy tulajdonképpen egyszerre működik név és   címszerinti pm átadásként</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">SQ</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="c1">//42 (i++) * (i++) és közben az i==8 lesz</span>
<span class="c1">//helyette cpp-ben inline függvények, úgy működik, ahogy elvárjuk, tehát, hogy a 6 négyzete az 36 lesz</span>
<span class="p">}</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2>11.14 gyakorlat <br></h2>
<p>folytatjuk az oo fogalmainak tárgyalását<br></p>
<div class="highlight"><pre><span></span><span class="c1">//referenciaszemantika és értékszemantika különbségei, előnyei, hátrányai</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//complex.h</span>
<span class="k">class</span> <span class="nc">complex</span> <span class="c1">//privát adattagok</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">re</span><span class="p">,</span><span class="n">im</span><span class="p">;</span> <span class="c1">//más referencia?</span>
<span class="p">};</span>
<span class="c1">//értékszemantika van C++-ban</span>
<span class="cp">#include</span> <span class="cpf">&quot;complex.h&quot; //mert tudnom kell a méretét, ha a reprezentáció, méret megváltozik nyilván újra kell fordítani</span><span class="cp"></span>
<span class="n">complex</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//ezen a ponton tök mindegy a különbség, valid létrehozott obj. alábbi is oké, de minek, gyorsabb futás, fordítás, complex a; a stacken hozta létre az objektumot</span>
<span class="n">a</span><span class="p">.</span><span class="n">im</span><span class="o">=</span><span class="mf">3.4</span><span class="p">;</span><span class="c1">//fordítási hiba, mert az adattag privát</span>
<span class="n">complex</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">complex</span><span class="p">();</span> <span class="c1">//ez is valid, döntési helyzet, heapen hoztam most létre az objektumot</span>
<span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//dinamikusan allokált objektum törléséért én felelek</span>
<span class="c1">//jávában döntési helyzetem nincs</span>
<span class="c1">//hogyan lehetene a ref szemantikát modellezni cpp-ban</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//JAVA referenciaszemantika</span>
<span class="n">complex</span> <span class="n">a</span><span class="o">;</span> <span class="c1">// a==null, nem foglalkozik a JAVA azzal, hogy valójában mi van a háttérben</span>
           <span class="c1">// el tud vonatkoztatni, hogy complex mögött meg lehet változtatni</span>
           <span class="c1">// valójában ez egy nullára inicializált pointer, ez a poén</span>
<span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">complex</span><span class="o">();</span> <span class="c1">//JAVA-ban mindig kötelezően new-val a heapre kell létrehozni az objektumot</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//C++</span>
<span class="c1">//hogyan lehetne a JAVA ref szemantikát modellezni cpp-ban - compilation firewall, pimpl idiom,bridge design pattern </span>
<span class="c1">//ne kelljen a fordítónak azzal foglalkoznia, hogy mögötte mi van, hanem csak a meghívott publikus műveleteivel</span>

<span class="c1">//complex.h</span>
<span class="c1">//átlag felhasználó ezt includeolja és ezt nem kell újrafordítani, ha változik a mögöttes koncepció</span>
<span class="c1">//impl implementáció</span>
<span class="k">class</span> <span class="nc">complex_impl</span><span class="p">;</span> <span class="c1">//forward deklarálja a típust, ez a firewall ami leválasztja az implementációról</span>

<span class="k">class</span> <span class="nc">complex</span> <span class="c1">// többi programozó, ezt a típust fogja használni</span>
<span class="p">{</span>
  <span class="n">complex_impl</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">//pointer a tényleges implementációra, valid, tudom dereferálni</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="c1">//deklarációk</span>
    <span class="n">complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span><span class="o">=</span><span class="mf">0.0</span><span class="p">);</span>
    <span class="kt">double</span> <span class="nf">get_re</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">//() kell?</span>
    <span class="n">complex</span><span class="p">(</span><span class="k">const</span> <span class="n">complex</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">//copy ctor - const ref szerint vesszük át a lemásolandót</span>
    <span class="n">complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">complex</span><span class="o">&amp;</span><span class="p">);</span><span class="c1">//értékadó operátor a neve</span>
    <span class="o">~</span><span class="n">complex</span><span class="p">();</span> <span class="c1">//dtor</span>
<span class="p">};</span>

<span class="c1">//lesz a complex.h-hoz egy </span>
<span class="c1">//complex.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;complex.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;complex_impl.h&quot;</span><span class="cp"></span>
<span class="n">complex</span><span class="o">::</span><span class="n">complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span><span class="p">);</span>
<span class="p">{</span>
  <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">complex_impl</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">i</span><span class="p">);</span> <span class="c1">//itt már nincs logika,meghívjuk a complex_impl konstruktor</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="n">complex</span><span class="o">::</span><span class="n">get_re</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">get_re</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">complex</span><span class="o">::</span><span class="n">complex</span><span class="p">(</span><span class="k">const</span> <span class="n">complex</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="c1">//copy ctor implementáció</span>
<span class="p">{</span>
  <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">complex_impl</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">p</span><span class="p">));</span> <span class="c1">//p pointer, dereferálom és copy hív rá a copy-ra</span>
<span class="p">}</span>
<span class="c1">//c=d; hez tartozik, van a jobb és bal oldali operandus</span>
<span class="n">complex</span><span class="o">&amp;</span> <span class="n">complex</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">complex</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="c1">//complex ref értékű visszatérés</span>
<span class="p">{</span>
  <span class="c1">//baloldali object mögötti pointer</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">p</span><span class="p">);</span> <span class="c1">//jobb és bal oldali operandus</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">complex</span><span class="o">::~</span><span class="n">complex</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//ellőbbiek mind csak az implementációra mutatnak</span>


<span class="c1">//complex_impl.h</span>
<span class="k">class</span> <span class="nc">complex_impl</span>
<span class="p">{</span>
 <span class="kt">double</span> <span class="n">re</span><span class="p">,</span><span class="n">im</span><span class="p">;</span> <span class="c1">// private adattagok</span>
 <span class="k">public</span><span class="o">:</span>
   <span class="n">complex_impl</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="kt">double</span> <span class="n">i</span><span class="o">=</span><span class="mf">0.0</span><span class="p">);</span> <span class="c1">//dtor</span>
   <span class="kt">double</span> <span class="nf">get_re</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//copmlex_impl s;</span>
<span class="c1">//s.get_re(); // ezeket az objekutom végezzük</span>

<span class="c1">//complex_impl.cpp: fejtsük ki a műveleteket</span>
<span class="cp">#include</span> <span class="cpf">&quot;complex_impl.h&quot;</span><span class="cp"></span>
<span class="n">complex_impl</span><span class="o">::</span><span class="n">complex_impl</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">re</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">im</span> <span class="o">=</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="n">complex_impl</span><span class="o">::</span><span class="n">get_re</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">re</span><span class="p">;</span> <span class="c1">//this-&gt;re</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">complex</span> <span class="n">c</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">);</span>
  <span class="n">complex</span> <span class="n">d</span><span class="o">=</span><span class="n">c</span><span class="p">;</span> <span class="c1">//most pont mint a jávában a c és d  heapbeli objektumra mutat, egy leallokált implementációs object</span>
  <span class="n">c</span><span class="p">.</span><span class="n">set_re</span><span class="p">(</span><span class="mf">6.3</span><span class="p">);</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span><span class="c1">//c.operator=(d);</span>
<span class="p">}</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="11.20-el&#337;ad&#225;s">11.20 el&#337;ad&#225;s<a class="anchor-link" href="#11.20-el&#337;ad&#225;s">&#182;</a></h2><p><strong>Objektumorientáltság</strong><br>
<a href="http://aszt.inf.elte.hu/~gsd/pny2/html/ea6_date/date.h.html">http://aszt.inf.elte.hu/~gsd/pny2/html/ea6_date/date.h.html</a><br>
<a href="http://aszt.inf.elte.hu/~gsd/pny2/html/ea6_date/datemain.cpp.html">http://aszt.inf.elte.hu/~gsd/pny2/html/ea6_date/datemain.cpp.html</a><br>
simulában jelent meg először, ritcheyéknek (C) nem volt szüksége rá<br>
C++ már az alapoktól támogatja az oo-t<br></p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">complex</span> <span class="c1">//összetartozó egybetartozó adatok, rekord típus               </span>
<span class="p">{</span>              <span class="c1">//aktivációs rekordon - a stacken - tényleg egymás mellé kerülnek</span>
  <span class="kt">double</span> <span class="n">re</span><span class="p">,</span><span class="n">im</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">complex</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">c</span><span class="p">.</span><span class="n">re</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>
  <span class="n">c</span><span class="p">.</span><span class="n">im</span> <span class="o">=</span> <span class="mf">3.4</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>ne foglalkozzanak a felhasználók a reprezentációval, csak használják, rejtsük el a reprezentációt<br>
ha a privátot használná, akkor reprezentáció áttérésénél, a kódja már nem tudna lefutni feltehetően<br>
a reprezentáció megváltozhat a háttérben<br>
cpp lassabban fordít, de a felhasználásnál legyen gyors, fordítás legyen lassú, de a végrehajtás gyors<br>
lokális változót a stackre, dinamikusat a heapre allokálok<br></p>
<div class="highlight"><pre><span></span><span class="n">date</span> <span class="n">d</span><span class="p">;</span> <span class="c1">//valid objektum, már le tudom kérdezni, lefutott a konstruktora, aktív</span>
</pre></div>
<p>cpp-ben mindkét típusról el tudom dönteni, hogy most heap vagy stackre kerüljön - stack hatékonyabb, majd ha szükség lesz heapre akkor ott fogok allokálni, cpp ad lehetőséget gondolkodásra ez a ponton $\Longleftrightarrow$ JAVA<br>
konstruktor neve megegyezik az osztály nevével és nincs semmiféle visszatérési értéke<br></p>
<div class="highlight"><pre><span></span><span class="n">date</span> <span class="nf">today</span><span class="p">(</span><span class="mi">2018</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
<span class="n">date</span> <span class="nf">s</span><span class="p">(</span><span class="mi">2019</span><span class="p">);</span>
<span class="n">date</span> <span class="n">d</span><span class="p">;</span> <span class="c1">//2000 jan 1</span>
</pre></div>
<p>tagfüggvények (pl get set)- osztályon belül vannak, másképp hívjuk meg őket<br></p>
<div class="highlight"><pre><span></span><span class="n">s</span><span class="p">.</span><span class="n">set_year</span><span class="p">(</span><span class="mi">2018</span><span class="p">);</span> <span class="c1">//tagfüggvényt, kap egy új változót, egy objektum amin meghívják, (self this máshol)</span>
<span class="kt">double</span> <span class="nf">abs</span><span class="p">(</span><span class="n">complex</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//....</span>
<span class="p">}</span>
</pre></div>
<p>set_year, set_month, set_day, összetartoznak, közös változóhalmaza van<br></p>
<div class="highlight"><pre><span></span><span class="n">s</span><span class="p">.</span><span class="n">set_year</span><span class="p">(</span><span class="mi">2018</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">get_year</span><span class="p">();</span> <span class="c1">//2018</span>
<span class="c1">//következők mik?</span>
<span class="n">date</span> <span class="nf">s</span><span class="p">(</span><span class="s">&quot;2018.01.31&quot;</span><span class="p">);</span> <span class="c1">//számokat kell bűvészkedni</span>
<span class="n">date</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span> <span class="c1">//stringből beparseoljuk a dátumot, fokkal hosszabb az implementációja ez nem itt van ezért?</span>
<span class="n">date</span><span class="o">&amp;</span> <span class="n">next</span><span class="p">();</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//x.h:</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(){}</span>
<span class="n">a</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span>
<span class="cp">#include</span> <span class="cpf">&quot;x.h&quot;</span><span class="cp"></span>
<span class="c1">//-&gt;obj</span>

<span class="c1">//b.cpp:</span>
<span class="cp">#include</span> <span class="cpf">&quot;x.h&quot;</span><span class="cp"></span>
<span class="c1">//-&gt;obj</span>
<span class="c1">//multiple reference linker probléma</span>

<span class="c1">//osztályon belüli függvények inlineként ezért kell a headert includeolni, nem kerül bele az objectbe, ezért itt nem lesz linkelési hiba</span>
<span class="kt">int</span>  <span class="n">get_day</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">day</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">get_day</span><span class="p">();</span> <span class="c1">//valójában &amp;s átadódik és lesz a this paramétere</span>
<span class="c1">//valójában tök ugyanaz mint</span>
<span class="k">return</span> <span class="n">day</span><span class="p">;</span>
<span class="c1">//valójában tök ugyanaz mint</span>
<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">day</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">set_year</span><span class="p">(</span><span class="mi">2019</span><span class="p">);</span>
<span class="k">this</span><span class="o">-&gt;</span><span class="n">year</span><span class="o">=</span><span class="n">y</span><span class="p">;</span>
<span class="c1">//&amp;s: this</span>
<span class="n">date</span><span class="o">&amp;</span>  <span class="n">set_year</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span><span class="n">year</span><span class="o">=</span><span class="n">y</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;}</span>
<span class="c1">// abból indulunk ki, hogy megváltoztatjuk az objektum állapotát</span>

<span class="c1">//vannak const objektumok születésnap pl</span>
<span class="k">const</span> <span class="n">date</span> <span class="n">birthday</span><span class="p">(</span><span class="mi">1982</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">26</span><span class="p">)</span>
<span class="c1">//meg tudom magam fiatalítani? ezen működik a set?</span>
<span class="n">birthday</span><span class="p">.</span><span class="n">set_year</span><span class="p">(</span><span class="mi">1999</span><span class="p">);</span> <span class="c1">//fordítási hiba kell, konstans obektumon nem hívogatunk tagfüggvényeket</span>
<span class="c1">//int  get_year() const { return year; } //const jelzi, hogy nem rontja el az objektum állapotát</span>
<span class="c1">//const a this-nek az állapotán változtat?</span>
<span class="c1">//lefordul a következő:</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">birthday</span><span class="p">.</span><span class="n">get_year</span><span class="p">();</span>
<span class="c1">// itt pl nincs const</span>
<span class="c1">//date&amp; set_day(int d) {day= d; return *this;} //this, hogy meg tudja változtatni a bemenő objektumot</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//constok</span>
<span class="n">set_year</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">){...}</span>
<span class="c1">//valójában van egy this pm-em, +this: date * const this a típusa, még pedig egy pointer egy dátumra, ami nem váltzotatható meg, this-en keresztül megváltoztatható jogunk van rá</span>
<span class="n">get_year</span><span class="p">(){...}</span> <span class="c1">// itt is van egy this pm, de ez const date * const this, olvasni tudjuk az objektumot, de változtatni nem</span>
<span class="n">date</span> <span class="n">d</span><span class="p">;</span>
<span class="c1">//date&amp; == date referenciával tér vissza a set_year</span>
<span class="n">d</span><span class="p">.</span><span class="n">set_year</span><span class="p">(</span><span class="mi">2018</span><span class="p">)</span> <span class="c1">//mert referenciál térünk vissza</span>
<span class="n">d</span><span class="p">.</span><span class="n">set_year</span><span class="p">(</span><span class="mi">2018</span><span class="p">).</span><span class="n">set_month</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span><span class="c1">//láncba is lehet kötni emiatt, referenciával térünk vissza, ampersand biztosítja, hogy ezen hajtódik vissza és nem másolódik - itt fontos a referencia szerinti értékadás </span>
<span class="n">d</span><span class="p">.</span><span class="n">set_year</span><span class="p">(</span><span class="mi">2018</span><span class="p">).</span><span class="n">set_month</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="n">next</span><span class="p">();</span> <span class="c1">//fontos a *this-sel emiatt visszatérni, voiddal is lehetne, de akkor nincs láncolási lehetőség</span>

<span class="c1">//miért van kettő prefix, postfix</span>
<span class="n">date</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="c1">//prefix növelés</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">next</span><span class="p">();</span> 
<span class="p">}</span> 
<span class="n">date</span>  <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="c1">//postfix növelés</span>
<span class="p">{</span>
  <span class="n">date</span> <span class="n">curr</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="cm">/*lokális változó*/</span>
  <span class="n">next</span><span class="p">();</span>          <span class="c1">//lokális változó nem adható vissza referencia szerint, ezért nem &amp; a visszatérés</span>
  <span class="k">return</span> <span class="n">curr</span><span class="p">;</span> <span class="c1">//érték szerint visszadva</span>
<span class="p">}</span>
 <span class="c1">//pre és post megkülönböztethető: postnak van egy látszólagos int paramétere</span>
<span class="c1">//                                 visszatérési érték: pre ref, post érték szerint</span>
<span class="n">date</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//referencia szerint tér vissza, ebből csak egy van</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//miért lettek ezek nem tagfüggvények? van két dátum:</span>
<span class="n">date</span> <span class="nf">a</span><span class="p">(</span><span class="s">&quot;2018.09.24&quot;</span><span class="p">);</span>
<span class="n">date</span> <span class="nf">b</span><span class="p">(</span><span class="s">&quot;2017.12.30&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//a.operator &lt;(b), osztályon belül így is meg lehet írni, lásd alább</span>
  <span class="c1">//vagy</span>
  <span class="c1">//operator &lt; (a,b) ilyen akar lenni</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">date</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>           
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">date</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">date</span> <span class="nf">x</span><span class="p">(</span><span class="mi">2018</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2018</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">x</span><span class="p">.</span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">2018</span><span class="p">)</span>
  <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2018</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">szeretj</span><span class="err">ü</span><span class="n">k</span> <span class="err">á</span><span class="n">ltal</span><span class="err">á</span><span class="n">ban</span> <span class="n">ink</span><span class="err">á</span><span class="n">bb</span> <span class="n">azt</span><span class="p">,</span> <span class="n">hogy</span>
<span class="k">if</span> <span class="p">(</span><span class="mi">2018</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// ez nem tudna ebben a pillanatban tagfüggvényként működni</span>
<span class="mf">2018.</span><span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="c1">//ez fordítási hibát adna, arra vagyunk szoktatva, hogy a konstans a bal oldalon van</span>
<span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2018</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

<span class="cm">/* globális műveletek az osztályon */</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span> <span class="n">date</span> <span class="n">d1</span><span class="p">,</span> <span class="n">date</span> <span class="n">d2</span><span class="p">);</span> <span class="c1">//egyet kifejtünk és a többit annak segítségével</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">date</span> <span class="n">d1</span><span class="p">,</span> <span class="n">date</span> <span class="n">d2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">d1</span><span class="o">&lt;</span><span class="n">d2</span> <span class="o">||</span> <span class="n">d2</span><span class="o">&lt;</span><span class="n">d1</span><span class="p">);</span> <span class="p">}</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span> <span class="n">date</span> <span class="n">d1</span><span class="p">,</span> <span class="n">date</span> <span class="n">d2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">d1</span><span class="o">&lt;</span><span class="n">d2</span> <span class="o">||</span> <span class="n">d2</span><span class="o">&lt;</span><span class="n">d1</span><span class="p">;</span> <span class="p">}</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="11.21-gyakorlat">11.21 gyakorlat<a class="anchor-link" href="#11.21-gyakorlat">&#182;</a></h2><p>+/- javítás</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">);</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="kt">int</span>  <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>csináltunk egy saját complex típust, jobban akartuk támogatni az oop-t így a pimpl mintával<br>
saját típusaink esetében, hogyan tudunk operátorokat definiálni, ezeket túlterhelni stb<br>
cpp alapkoncepció, hogy vannak túlterhelhető operátorok saját típusaink esetén, ilyen volt az =, == (egyenlőségvizsgálat), &amp; (címképzés, de ezt nem érdemes túlterhelni), ++(2),+....<br>
vannak nem túlterhelhetőek: sizeof(),.,?:<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="p">...</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span>
<span class="n">X</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">();</span> <span class="c1">//malloc-ot akarja meghívni malloc(sizeof(X))</span>
<span class="p">...</span>
<span class="k">delete</span> <span class="n">s</span><span class="p">;</span>
</pre></div>
<p>pont operátort engedjük-e túlterhelni? évről évre felmerülő kérdés<br></p>
<div class="highlight"><pre><span></span><span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">()</span> <span class="c1">//ha ez smart pointerrel túlterhelhető</span>
<span class="n">r</span><span class="p">.</span><span class="n">f</span><span class="p">()</span> <span class="c1">// akkor ez miért ne?, lehetne emiatt motiváció mögött</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(...)</span>
<span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span>
</pre></div>
<p>túlterheltő operátorok is fix aritással rendelkeznek, ész nélkül nem tudom megírni más paraméterekkel<br></p>
<div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//infix forma, van operátor és két operandusa</span>
<span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="o">+</span> <span class="n">a</span>
<span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="c1">// saját típus a és tagfv a.operator+(b) vagy globális művelet operator+(a,b)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="c1">// saját típus a és tagfv a.operator==(b) vagy operator==(a,b)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="c1">//értékadás a.operator=(b)</span>
</pre></div>
<p>gömbölyű zárójel operátor ()<br></p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">complex</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">re</span><span class="p">,</span><span class="n">im</span><span class="p">;</span> <span class="c1">// privát adattagok</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">:</span><span class="n">re</span><span class="p">(</span><span class="n">r</span><span class="p">),</span><span class="n">im</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="c1">//tag inicializáló lista - hatékonyságot tudja növelni</span>
    <span class="p">{</span>
    <span class="p">}</span>
    <span class="kt">double</span> <span class="n">get_re</span><span class="p">()</span> <span class="k">const</span> <span class="c1">//művelet, lekérdezzük a valós részt, const típuson is meg tudjuk hívni </span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">re</span><span class="p">;</span>
      <span class="c1">//vagy</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">re</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*complex operator+(const complex&amp; rhs) const   //visszatérési típus complex, művelet neve: operator+</span>
<span class="cm">                      //jobb oldali pm      bal oldali pm</span>
<span class="cm">    {</span>
<span class="cm">      return complex(re + rhs.re,im+rhs.im);</span>
<span class="cm">                     //bo   jo      bo jo, meg kell szokni, hogy így kell megírni</span>
<span class="cm">    }*/</span>
    <span class="c1">//minden nyelvi eszköz adott, hogy tagfüggvényként megvalósítsam, de nem célszerű így ezért osztályon kívül fog kerülni + az osztályon kívüli műveletek nem látják a privát tagokat</span>
<span class="p">};</span>
<span class="c1">//írjuk meg az operator+-t osztályon kívül</span>
<span class="n">complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">complex</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">complex</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="c1">//nincs kiemelve egyik sem thisként, mindkét oldalon van konverzió, de a privát adattagokat nem használhatom, furcsa</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">complex</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">get_re</span><span class="p">()</span><span class="o">+</span><span class="n">rhs</span><span class="p">.</span><span class="n">get_re</span><span class="p">(),</span><span class="n">lhs</span><span class="p">.</span><span class="n">get_im</span><span class="p">()</span><span class="o">+</span><span class="n">rhs</span><span class="p">.</span><span class="n">get_im</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">complex</span> <span class="n">a</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span><span class="mf">4.8</span><span class="p">);</span>
<span class="n">complex</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">2.6</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
<span class="n">complex</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">2.6</span> <span class="c1">// működik most már</span>
<span class="c1">//kommutatív operátoroknál szeretjük ez a globálos osztályon kívüliként megírni</span>


<span class="n">complex</span> <span class="n">a</span><span class="p">(</span><span class="mf">3.1</span><span class="p">,</span><span class="mf">4.4</span><span class="p">);</span>
<span class="n">complex</span> <span class="nf">b</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.7</span><span class="p">);</span>
<span class="n">complex</span> <span class="n">s</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span><span class="c1">//infix módon le van írva az a+b</span>
<span class="c1">//háttérben a.operator+(b) ,a átadódik thisként a b rhs-nek</span>
<span class="c1">//írjunk egy ilyet</span>
<span class="n">complex</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="mf">2.6</span> <span class="c1">//működik mert a-n meghívjuk a.operator+(2.6), inicializálva volt imag, ilyenkor automatikusan megkonsturálunk egy komplexet, 2.6 komplexszé tud válni a.operator+(complex(2.6))</span>
<span class="c1">//DE</span>
<span class="n">complex</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">2.6</span><span class="o">+</span><span class="n">a</span><span class="p">;</span><span class="c1">//fordítási hibát ad</span>
<span class="c1">//2.6.operator+(a), kommutativitást nem támogatja a fent megírt megoldás, mert a bal oldali pm-ről csak annyit mondtunk, hogy const és nem volt konverziós szabály hozzá</span>

<span class="c1">//mikor használunk init listát pl:</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
  <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span> <span class="c1">//mi van ha ez nem tud default konstruálódni?</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">X</span><span class="p">()</span><span class="o">:</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">){}</span> <span class="c1">//ezen a ponton értéket tudok neki adni, különben fordítási hiba</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="c1">//nem default konstruálható </span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">_</span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">//miért kell a const, pl:</span>
<span class="k">const</span> <span class="n">complex</span> <span class="nf">a</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span><span class="mf">3.8</span><span class="p">)</span>
<span class="n">a</span><span class="p">.</span><span class="n">get_re</span><span class="p">();</span> <span class="c1">//ha nem lenne const felül, akkor egy furcsa hibaüzenetet ad &quot;nem tudja thisnek átadni&quot;</span>
<span class="c1">//&amp;a itt, vizsgán előjöhet ez a hibaüzenet!!!</span>

<span class="kt">double</span> <span class="nf">abs</span><span class="p">(</span><span class="n">complex</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span><span class="c1">//real2complex</span>
<span class="c1">//tagfüggvényként is meg lehet írni</span>
<span class="p">}</span>
<span class="n">abs</span><span class="p">(</span><span class="mf">1.7</span><span class="p">);</span>

<span class="n">complex</span> <span class="nf">s</span><span class="p">(</span><span class="mf">0.6</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//std::cout.operator &lt;&lt; (s)</span>
                <span class="c1">//operator(std::cout,s), ez is legyen globális művelet</span>
                <span class="c1">//legyen láncba köthető egy &lt;&lt; std::endl;-lel</span>
<span class="c1">//újra osztályon kívül vagyunk</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">get_re</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;+&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">get</span><span class="p">.</span><span class="n">im</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;i&#39;</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//két nagy kivétel kommutatív operátorok és io műveletek</span>
</pre></div>
<p>miért érdekes egy gömbölyű zárójel operátor?<br></p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="c1">//</span>
    <span class="p">}</span>

<span class="p">};</span>
<span class="n">X</span> <span class="n">s</span><span class="p">;</span>
<span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// s obejktumon meghívott gömb. zárójel operator a 2 értékadás után s.operator()(2)</span>
<span class="c1">//globális fv meghívásokat lehet álcázni tagfv hívásokkal?</span>


<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">print</span><span class="p">);</span>
<span class="c1">//for_each hova írjon ki és paraméterezhetővé akarjuk tenni, funktor osztályok és functor objektumok</span>

<span class="k">class</span> <span class="nc">Print</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span> <span class="c1">//érték szerint a streamek nem adhatok át, ezért álnéven referenciaként, ref-et inicializálni kell</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">o</span><span class="p">)</span><span class="o">:</span><span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">){}</span><span class="c1">//o-val inicializáljuk os-t és a konstruktor törzs üres marad</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span> <span class="c1">//be tudtam juttatni azt, hogy hova kell kiírnia</span>
<span class="n">Print</span> <span class="nf">p</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">);</span> <span class="c1">//konstruktorhívás</span>
<span class="n">p</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//gömb zárójel op és a std erroron megjelenik a 4, for_each tölti ki?</span>
<span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">p</span><span class="p">);</span>
<span class="c1">//gyakran ezt csináljuk</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">Print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">));</span> <span class="c1">// temporális név nélküli obj, létezik amíg a for_each fut</span>
<span class="c1">//példa vektorban lévő elemek összegét határozzuk meg, hol tároljuk az eddigi részletösszeget?</span>
<span class="kt">int</span> <span class="n">part</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">port</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//hogyan funktorral?</span>
<span class="k">class</span> <span class="nc">Sum</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ps</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">ps</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{};</span> <span class="c1">// nem kell init lista mert nem ref</span>

    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// erre ír rá a for_each</span>
    <span class="p">{</span>
      <span class="n">ps</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">get_sum</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">ps</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">Sum</span> <span class="nf">s</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">//háromról kezdünk összegezni</span>
<span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//ráhívtam a gömb zárójel operátort</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="n">s</span><span class="p">.</span><span class="n">get_sum</span><span class="p">();</span> <span class="c1">//5</span>
<span class="n">s</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="n">s</span><span class="p">.</span><span class="n">get_sum</span><span class="p">();</span><span class="c1">//9</span>
<span class="n">Sum</span> <span class="n">t</span><span class="p">;</span>
<span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="n">t</span><span class="p">.</span><span class="n">get_sum</span><span class="p">();</span> <span class="c1">//2</span>

<span class="c1">//hogy tudjuk ezt az STL-lel használni?</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">Sum</span><span class="p">()).</span><span class="n">get_sum</span><span class="p">();</span>
                                           <span class="c1">//default konstruált anonim temporális szummázó objektumnak, meghívom a get_sum metódusát, és abban van benne az elemek összeg</span>
<span class="c1">//for_eachnek van egy visszatérési értéke, ami jelzi, hogy szummázta</span>
<span class="c1">//eddig eldobtuk a visszatérési értékét</span>
<span class="c1">//funktorok előkerülnek vizsgán</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="11.-27-el&#337;ad&#225;s">11. 27 el&#337;ad&#225;s<a class="anchor-link" href="#11.-27-el&#337;ad&#225;s">&#182;</a></h3><p>date: if (d &lt; d2) d.operator&lt;(d2)
                  operator&lt;(d,d2)</p>
<p>d<2018 -> d.operator&lt;(2018)
          operator&lt;(d,2018)</p>
<p>konverziós probléma miatt globális függvényként írjuk meg
2018 &gt; d -&gt; operator &gt; (2018,d)</p>
<p>while ( cin&gt;&gt;d )
-&gt; cin.operator&gt;&gt;(d) //nyilván nem írok bele a szabványkönyvtárba
   operator&gt;&gt;(cin,d) //nyilván nem írok bele a szabványkönyvtárba</p>
<p>osztályon belüli művelet, automatikusan inline
date::date(const char *s)</p>
<div class="highlight"><pre><span></span><span class="n">date</span> <span class="n">a</span><span class="p">(</span><span class="s">&quot;2018.05.30&quot;</span><span class="p">)</span> <span class="c1">//kettesre mutatni az s, a p1 az első pontra, a p2 a második pontra</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="cm">/* módosítók */</span>
<span class="n">date</span><span class="o">&amp;</span> <span class="n">date</span><span class="o">::</span><span class="n">next</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">day_in_month</span><span class="p">[]</span> <span class="o">=</span>
              <span class="p">{</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span> <span class="p">};</span>
    <span class="o">++</span><span class="n">day</span><span class="p">;</span>

    <span class="cm">/* TODO: szökőév */</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">day</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">day_in_month</span><span class="p">[</span><span class="n">month</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">day</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">++</span><span class="n">month</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">13</span> <span class="o">==</span> <span class="n">month</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">month</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">++</span><span class="n">year</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="c1">//a.next(), a.next().next() return *this miatt</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">date</span><span class="o">&amp;</span> <span class="n">date</span><span class="o">::</span><span class="n">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">next</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">a</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">);</span>

<span class="cm">/* input-output */</span>
<span class="kt">void</span> <span class="n">date</span><span class="o">::</span><span class="n">get</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// nem lenne igazán jó:</span>
    <span class="c1">// is &gt;&gt; year &gt;&gt; month &gt;&gt; day;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">d</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">set</span><span class="p">(</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>
<span class="c1">//tranzakciókezelés</span>
<span class="n">date</span> <span class="n">s</span><span class="p">(</span><span class="mi">2017</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">14</span><span class="p">);</span>
<span class="n">date</span> <span class="nf">s</span><span class="p">(</span><span class="mi">2017</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
<span class="c1">//tranzakciós szemantika</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">date</span><span class="o">::</span><span class="n">put</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// nem lenne igazán jó: os &lt;&lt; year &lt;&lt; month &lt;&lt; day;</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">get_year</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">get_month</span><span class="p">()</span>
                             <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">get_day</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ]&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//reprezentációtól függetlenül megmarad a tagfüggvény, ezért kell, get</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span> <span class="n">date</span> <span class="n">d1</span><span class="p">,</span> <span class="n">date</span> <span class="n">d2</span><span class="p">)</span> <span class="c1">//ezt fejtjük ki a headerben inline bool, a többi ennek segítségével</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">d1</span><span class="p">.</span><span class="n">get_year</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">.</span><span class="n">get_year</span><span class="p">()</span>  <span class="o">||</span>
           <span class="n">d1</span><span class="p">.</span><span class="n">get_year</span><span class="p">()</span> <span class="o">==</span> <span class="n">d2</span><span class="p">.</span><span class="n">get_year</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">d1</span><span class="p">.</span><span class="n">get_month</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">.</span><span class="n">get_month</span><span class="p">()</span>  <span class="o">||</span>
           <span class="n">d1</span><span class="p">.</span><span class="n">get_year</span><span class="p">()</span> <span class="o">==</span> <span class="n">d2</span><span class="p">.</span><span class="n">get_year</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">d1</span><span class="p">.</span><span class="n">get_month</span><span class="p">()</span> <span class="o">==</span> <span class="n">d2</span><span class="p">.</span><span class="n">get_month</span><span class="p">()</span>
                                          <span class="o">&amp;&amp;</span> <span class="n">d1</span><span class="p">.</span><span class="n">get_day</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">.</span><span class="n">get_day</span><span class="p">();</span>

<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">date</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="c1">//referenciaként átvenni!!!, ne egy másolaton dolgozzunk</span>
    <span class="c1">//istream&amp; streameket alapvetően mindig referencia szerint vesszük át</span>
<span class="p">{</span>
    <span class="n">d</span><span class="p">.</span><span class="n">get</span><span class="p">(</span> <span class="n">is</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">date</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">)</span> <span class="c1">//kiíratásnál date const referenciával, ostream normál refként</span>
<span class="p">{</span>
    <span class="n">d</span><span class="p">.</span><span class="n">put</span><span class="p">(</span> <span class="n">os</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">// stacket írunk meg</span>
<span class="c1">//http://aszt.inf.elte.hu/~gsd/pny2/html/ea7_pod/dstackmain1.cpp.html</span>

<span class="c1">// dstack kliens program</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;dstack1.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">dstack</span> <span class="n">d1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//stack létrehozása</span>
    <span class="n">d1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>    <span class="n">d1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mf">4.14</span><span class="p">);</span>    <span class="n">d1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mf">5.14</span><span class="p">);</span> <span class="c1">//push művelet,bepakol</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">dstack</span> <span class="n">d2</span><span class="p">(</span><span class="n">d1</span><span class="p">);</span> <span class="c1">// ugyanaz, mint: dstack d2 = d1;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="o">!</span> <span class="n">d1</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span> <span class="p">)</span> <span class="c1">//üres-e</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;pop: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// verem tetjén lévő adatot eltávolítja</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* output:</span>

<span class="cm">[ 3.14, 4.14, 5.14 ]</span>
<span class="cm">pop: 5.14</span>
<span class="cm">pop: 4.14</span>
<span class="cm">pop: 3.14</span>
<span class="cm">[  ]</span>
<span class="cm">[ 3.14, 4.14, 5.14 ]</span>

<span class="cm">*/</span>


<span class="c1">//</span>
<span class="c1">// _naive_ dstack osztály</span>
<span class="c1">// vigyázat! hibás kód</span>
<span class="c1">//</span>
<span class="cp">#ifndef DSTACK_H</span>
<span class="cp">#define DSTACK_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">dstack</span>
<span class="p">{</span>
    <span class="cm">/* friend deklaráció: nem helyettesíti a függvény deklarációt */</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">dstack</span> <span class="n">ds</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
        <span class="cm">/* konstruktor */</span>
        <span class="n">dstack</span><span class="p">(</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">);</span> <span class="c1">//szükség van dinamikus allokációra</span>
        <span class="c1">//konstruktor paraméter alapértelmezett értéke, default 128 elem széméra</span>

    <span class="kt">void</span>   <span class="nf">push</span><span class="p">(</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>
    <span class="cm">/* a legtöbb könyvtárban: void pop() */</span>
    <span class="kt">double</span> <span class="nf">pop</span><span class="p">();</span>
    <span class="cm">/* a legtöbb könyvtárban lenne még:</span>
<span class="cm">    double&amp; top();</span>
<span class="cm">    double  top() const;</span>
<span class="cm">    */</span>
    <span class="kt">bool</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">is_full</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span>    <span class="n">capacity</span><span class="p">;</span>    <span class="c1">// lefoglalt tárterület mérete, kapacitás</span>
    <span class="kt">int</span>    <span class="n">sp</span><span class="p">;</span>          <span class="c1">// aktuális elemek száma</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>          <span class="c1">// pointer a tárterületre</span>
<span class="p">};</span>
<span class="cm">/* a kiíró művelet deklarációja (friend nem elég) */</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">dstack</span> <span class="n">ds</span><span class="p">);</span> <span class="c1">//nem érem el a privát tagokat - date-nél más volt</span>

<span class="cp">#endif </span><span class="cm">/* DSTACK_H */</span><span class="cp"></span>


<span class="c1">// _naive_ dstack implementáció</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;dstack1.h&quot;</span><span class="cp"></span>

<span class="n">dstack</span><span class="o">::</span><span class="n">dstack</span><span class="p">(</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* ugyanaz, mint </span>
<span class="cm">       capacity = size;</span>
<span class="cm">       v = new double[capacity];</span>
<span class="cm">     */</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">size</span><span class="p">];</span> <span class="c1">//capacity-be belekerül a konstruktor paraméter</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">dstack</span><span class="o">::</span><span class="n">push</span><span class="p">(</span> <span class="kt">double</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// TODO?: hibakezelés</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">is_full</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">v</span><span class="p">[</span><span class="n">sp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// dstack d(10); konstruktor lefut, d.sp=0</span>
<span class="c1">// d.push(3.14); postfix visszatér a növelés előtti értékkel</span>
<span class="c1">// első push hatására sp++ 0. indexre ad értéket, d.sp==1</span>
<span class="c1">//d.spush(4.14); d.sp==2</span>

<span class="kt">double</span> <span class="n">dstack</span><span class="o">::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// TODO?: hibakezelés</span>
    <span class="k">return</span> <span class="n">is_empty</span><span class="p">()</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="n">v</span><span class="p">[</span><span class="o">--</span><span class="n">sp</span><span class="p">];</span> <span class="c1">// ha üres veremből hívjuk meg a pop műveletet</span>
    <span class="c1">//d.pop();    3.14, 4.14</span>
<span class="p">}</span>
<span class="c1">//d.spush(4.14); d.sp==2</span>
<span class="c1">//d.pop(); v ekkor 4.14-re mutat</span>

<span class="c1">// a szabványos könyvtárban: bool empty() const</span>
<span class="kt">bool</span> <span class="n">dstack</span><span class="o">::</span><span class="n">is_empty</span><span class="p">()</span> <span class="k">const</span> <span class="c1">//const objekt esetén is lekérdezhető, hogy üres-e</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">sp</span><span class="p">;</span> <span class="c1">// 0 egyezik a sz sp-vel, bool kifejezés azonnal térhet vissza return-nel</span>
                    <span class="c1">// 0 == sp-t kiértékeli</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">dstack</span><span class="o">::</span><span class="n">is_full</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">capacity</span> <span class="o">==</span> <span class="n">sp</span><span class="p">;</span> <span class="c1">//úgyis kiértékelődik és logikaiként használjuk tovább</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">dstack</span> <span class="n">ds</span><span class="p">)</span>
<span class="p">{</span>   <span class="c1">//friendesítve van</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ &quot;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ds</span><span class="p">.</span><span class="n">sp</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">ds</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>

    <span class="c1">// hogy ne írjunk vesszőt az utolsó elem után:    </span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ds</span><span class="p">.</span><span class="n">sp</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">ds</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">ds</span><span class="p">.</span><span class="n">sp</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ]&quot;</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//hogy került a d2-be 9.99</span>
<span class="n">dstack</span> <span class="n">d2</span><span class="p">(</span><span class="n">d1</span><span class="p">);</span> <span class="c1">//tagonként másolás, három adattagja van, hogyan kell egy pointert értelmesen lemásolni, hogy önálló üres területe legyen am ásolatnak</span>
<span class="c1">// d1 cap. 10, sp. 3, d mutat a heapen leallokált üres tárhelyre</span>
<span class="c1">// d2 cap. 10, sp. 3, d mutat a heapen leallokált üres tárhelyre</span>


<span class="c1">// nagyjából helyes dstack definíció</span>

<span class="cp">#ifndef DSTACK_H</span>
<span class="cp">#define DSTACK_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">dstack</span>
<span class="p">{</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">dstack</span> <span class="n">ds</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
           <span class="n">dstack</span><span class="p">(</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">);</span>
           <span class="n">dstack</span><span class="p">(</span> <span class="k">const</span> <span class="n">dstack</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span> <span class="c1">//dstack d2(d1) ref szerint veszi át!!, pointer adattago ne mtudja értelmesen lemásolni</span>
 <span class="c1">// ver2: másoló konstruktor </span>
           <span class="o">~</span><span class="n">dstack</span><span class="p">();</span>   <span class="c1">//élettartam végén automatikusan lefut  // ver2: destruktor         </span>
    <span class="n">dstack</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">dstack</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span> <span class="c1">// ver2: értékadó operátor  </span>


    <span class="kt">void</span>   <span class="nf">push</span><span class="p">(</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>
    <span class="kt">double</span> <span class="nf">pop</span><span class="p">();</span>

    <span class="kt">bool</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">is_full</span><span class="p">()</span>  <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span>    <span class="n">capacity</span><span class="p">;</span>
    <span class="kt">int</span>    <span class="n">sp</span><span class="p">;</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">copy</span><span class="p">(</span> <span class="k">const</span> <span class="n">dstack</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span>  <span class="c1">// ver2: inicializálás és másolás  </span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">dstack</span> <span class="n">ds</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* DSTACK_H */</span><span class="cp"></span>

<span class="n">dstack</span><span class="o">::~</span><span class="n">dstack</span><span class="p">()</span>                       <span class="cm">/* ver2 */</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//!!!</span>
<span class="n">dstack</span> <span class="n">d2</span><span class="p">(</span><span class="n">d1</span><span class="p">);</span><span class="c1">//copyctor</span>
<span class="n">d1</span><span class="o">=</span><span class="n">d2</span><span class="p">;</span><span class="c1">//értékadás</span>
<span class="n">dstack</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">d2</span><span class="p">,</span> <span class="c1">//copyctor</span>


<span class="kt">void</span> <span class="n">dstack</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span> <span class="k">const</span> <span class="n">dstack</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">];</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">sp</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sp</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">dstack</span> <span class="n">d2</span><span class="o">=</span><span class="n">d1</span><span class="p">;</span> <span class="c1">//d2-nek is legyen egy független tárhelye és oda másoljuk a megfelelő elemeket</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>

<span class="n">dstack</span><span class="o">&amp;</span> <span class="n">dstack</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">dstack</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="cm">/* ver2 */</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="c1">//címképzés)   // x = x önallokálást nehogy elkövessünk, figyeljünk oda arra</span>
    <span class="p">{</span>
        <span class="c1">// nem igazán kivétel-biztos</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">v</span><span class="p">;</span> <span class="n">bal</span> <span class="n">oldalit</span> <span class="n">felszabad</span><span class="err">í</span><span class="n">tjuk</span> <span class="err">é</span><span class="n">s</span> <span class="n">a</span> <span class="n">jobb</span> <span class="n">oldalit</span> 
        <span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="c1">// láncba köthető legyen</span>
<span class="p">}</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="11.28-gyakorlat">11.28 gyakorlat<a class="anchor-link" href="#11.28-gyakorlat">&#182;</a></h3><p>Típussal történő paraméterezés, mire jó, mire lehet használni, cpp-ben ezek a sablonok, template-ek<br>
C-ben nem volt és ettől szenvedett látványosan, erre nézzünk példát<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">,...);</span> <span class="c1">//számukat, típusokat nem lehetett összeegyeztetni,kellene, hogy lehessen doublet, intet, pointert stb kiíratni</span>
<span class="c1">//memóriakezelés problémája</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span> <span class="c1">//heapben allokálás</span>
<span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span> <span class="c1">// void* tud bármilyen alakra mutatni</span>
<span class="c1">//meg tudták csinálni, hogy különböző típusokkal lehessen használni, de lemondtak arról, hogy milyen típusú, típusinformációvesztés</span>

<span class="c1">//makrók</span>
<span class="cp">#define MAX(a,b)((a)&lt;(b)?(b):(a))</span>
<span class="c1">//típusinformáció nincs</span>

<span class="c1">// ezek workaround kisegítő megoldások voltak</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//nézzük a cpp megoldást</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="c1">//nem tudom a típusparamétert,</span>
<span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
<span class="c1">//fogalmam nincs mi a T ezért konstans referenciával veszem át (és nem érték szerint)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="o">?</span><span class="nl">b</span><span class="p">:</span><span class="n">a</span><span class="p">;</span> <span class="c1">//T típus, de elvárjuk mégis tőle, hogy tudjon a &quot;&lt;&quot; művelettel összehasonlítani, T helyett inkább Comparable legyen a neve</span>
<span class="p">}</span>
<span class="c1">//szép kódrészlet de ez nem fordul le alacsony szintűre, amíg nem derül ki mi a T (amíg nem példányosodik)</span>
<span class="c1">// nem lesz belőle object, headerben írjuk teljes tartalommal, amíg nincs példányosítva a template addig nem generálódik belőle object</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//compiler rájön paraméter dedukcióval, hogy T azonos int, példányosítás</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="mf">6.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">);</span> <span class="c1">//compiler rájön paraméter dedukcióval, hogy T azonos double, példányosítás</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="mf">6.1</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//compiler nem akar dönteni, ezért fordítási hibát ad</span>

  <span class="n">complex</span> <span class="nf">a</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span><span class="mf">3.7</span><span class="p">)</span>
  <span class="n">complex</span> <span class="n">b</span><span class="p">(</span><span class="mf">4.1</span><span class="p">,</span><span class="mf">0.8</span><span class="p">)</span>
  <span class="n">complex</span> <span class="n">c</span> <span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span> <span class="c1">//példányosít T azonos complex, de nem találja a műveletet az implementációban, fordítási hibát ad, nem ideális ponton ad hibaüzenetet</span>


 <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">//fordítási hibát ad a sort, szabványkönyvtár is bizonyos elvárásokkal él, furcsa nagyon hosszú hibát ad, nyelvi eszközök</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="s">&quot;blabla&quot;</span><span class="p">,</span><span class="s">&quot;abcdef&quot;</span><span class="p">);</span> <span class="c1">//példányosítás lesz, pointereknél van kisebb nagyobb művelet, két string heurisztikusan elhelyezve a memóriában, kettő közül valamelyik kisebb memóriacímen lesz, tehát vagy blabla vagy abcdef adódik át</span>
<span class="c1">//string pointerré konvertálódva adódik át</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="s">&quot;blabl&quot;</span><span class="p">,</span><span class="s">&quot;abcdef&quot;</span><span class="p">);</span> <span class="c1">//fordítási hiba</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;bla&quot;</span><span class="p">,</span><span class="s">&quot;ab&quot;</span><span class="p">);</span> <span class="c1">// eredmény bla</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// nincs fordítási hiba</span>
<span class="c1">//STL template-ekkel volt megírva</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//It-t általában InputIterator-nak nevezeik</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">It</span><span class="p">,</span><span class="k">class</span> <span class="nc">Fun</span><span class="o">&gt;</span> <span class="c1">//ez egy iterátor valid implementációja</span>
    <span class="c1">//két It típusú pm</span>
<span class="n">Fun</span> <span class="n">for_each</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span><span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Fun</span> <span class="n">f</span><span class="p">)</span> <span class="c1">//It first érték szerint átvett pm (nem ref szerint) kell copy ctor</span>
<span class="p">{</span>                              <span class="c1">//új állapot hozható be</span>
  <span class="k">while</span><span class="p">(</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">);</span> <span class="c1">//f.operator()(*first++), ;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">;</span>   
<span class="p">}</span>

<span class="c1">//elvárások It-re: operator !=</span>
<span class="c1">//                 operator ++</span>
<span class="c1">//                 operator *</span>
<span class="c1">//                 (copy ctor)</span>
<span class="c1">//mik teljesítik ezeket az elvárásokat: pointerek, tömbök, STL-es konténerek iterátorai </span>

<span class="c1">//elvárások Fun-ra: copy ctor //ha megváltozott f akkor azt visszakapja a ħívó</span>
<span class="c1">//                  függvényhívás szintaktikus leírás</span>
<span class="c1">//mi teljesíti: fv re mutató pointerek(C-ből jön), funktortípusok (gömbölyű zárójel felüldefiniálása), funktorokkal hatékonyabbb a Fun</span>

<span class="c1">//múltkori implementáció nem volt tökéletes</span>
<span class="c1">// legyen általános print funktortípus, templatesítsük</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Print</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">;</span>
  <span class="c1">//std::ostream ref adattag</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span><span class="o">:</span> <span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">){}</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="c1">//void, mert erre: f(*first++); hívunk rá;</span>
    <span class="p">{</span>
      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">//használat:</span>
<span class="n">Print</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">);</span> <span class="c1">//p double-eket fog kiírni a std error-ra</span>
<span class="n">p</span><span class="p">(</span><span class="mf">1.93</span><span class="p">)</span>
<span class="n">p</span><span class="p">(</span><span class="s">&quot;xy&quot;</span><span class="p">)</span> <span class="c1">// fordítási hiba;</span>

<span class="n">Print</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">);</span> <span class="c1">//szabványkönyvtári listának nincs kiíró operátor, de legális kód? miért? üres lista</span>
<span class="c1">//nem triggerel hibát a használhatatlan példányosítás</span>
<span class="n">s</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">//ha default konstruálom akkor már dobja a hibát</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">Print</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">));</span> <span class="c1">//temporális obj esetén is &lt;double&gt; típus meg kell adni</span>

<span class="c1">//következő implementáció ugyanez lesz csak megváltoztatva</span>
<span class="c1">//technikailag megoldható</span>
<span class="k">class</span> <span class="nc">Print</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span><span class="o">:</span><span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">){}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>  <span class="c1">// template&lt;typename&gt; T nem egy valódi osztály, ezért szoktak typename-t használni, de ugyanazt jelenti</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// ez már nem template osztály</span>
<span class="n">Print</span> <span class="nf">p</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">);</span><span class="c1">//nincs template pm mert nem template osztály, () operator meghívásakor pm dedukció lép életbe és tudja, hogy jah intet akar kiíratni, egy objektum különböző típusúakat is ki tud iratni, előző eseteben minden típusúra külön objektumot hozott létre</span>
<span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">p</span><span class="p">(</span><span class="s">&quot;xy&quot;</span><span class="p">);</span>
<span class="n">p</span><span class="p">(</span><span class="mf">1.83</span><span class="p">);</span>
<span class="n">p</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">//T azonos int, más </span>
<span class="c1">// char-ral példányosított templateosztály a string</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="o">=</span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3>12.04 előadás <br></h3>
<p>témák ma:
templatek (sablonok), ide kapcsolódik <br>
STL (standard template library)<br></p>
<p>C-ben:<br>
void pointerek, lemondtam az infóról, hogy mire mutat<br>
makrók: forráskóddarabka, különböző típusukra<br></p>
<p>egyikkel sem lehetett kommutatívan dolgozni (elemeket felcserélni)<br></p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="c1">// &lt;typename T&gt; arra utal, hogy class nem egy valódi osztály</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">tmp</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//segédváltozó létrehozása templaten belül, hány bájtot foglaljon le a stacken? nem fordul le</span>
           <span class="c1">// akkor tud lefordulni, ha példányosítjuk és megmondjuk neki, hogy mi T típus</span>
 <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//lehetne a gyermekded játékkal is megcsinálni, de sokkal kevesebb típusra működne mint így</span>
 <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
 <span class="n">tmp</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span> <span class="c1">//berakta, de letörölte utána</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> <span class="c1">//paraméterdedukcióval levezeti a compiler, hogy T az int és lefordul, csinál egy olyan függvényt, ami beír mindehova intet, ha double-ekre is használom akkor csinál egy olyan függvényt double-ekre</span>
<span class="p">}</span>
</pre></div>
<p>mitvárunk el T-vel kapcsolatban:</p>
<blockquote><p>copy construktor hívás T tmp = a;
értékadás a = b;
értékadás b = tmp;</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="n">swap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">);</span> <span class="c1">// ilyenkor mi történik, ezek nem másolhatóak, nem engedi a compiler , furcsa fordítási hibát kapunk</span>
</pre></div>
<p>STL kapcsán említettük, hogy két nagy része van: konténerek és algoritmusok<br>
mit jelent a megszorítás nélküli templateség cpp szempontjából?<br></p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span> <span class="c1">//legyen egy Cont konténer template paraméterem</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">)</span> <span class="c1">//konst referencia szerint veszem át</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">//lekérdezzük a méretét, vektorral, listával, stb együtt tud működni</span>
  <span class="c1">//int i = const.siye(); ilyen művelet nincs a template pm-nek de a a compiler nem szól amíg nincs példányosítva</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">//fordítási hiba</span>
<span class="p">}</span>
</pre></div>
<p>algoritmusok valójában függvénysablonok, mindenféle elvárások megjelennek<br></p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//800 soros hibaüzenet</span>
<span class="c1">//lista egy kétirányú láncolt szerkezet, de memóriában lehet, hogy ezek a láncszemek egymástól távol vannak</span>
<span class="c1">// std::sort emiatt nem tudja rendezni a listát, random access iterátorokat vár, de a lista ez nem az</span>
</pre></div>
<p>hogyan lett kialakítva az STL, hogy milyen adatszerkezettek működnek az algók<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span> <span class="n">last</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="c1">//tömb pointerré konvertálódva adódik át, keressük meg az első előfordulását int x-nek</span>
<span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">first</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="c1">//pointer aritmetika által mutatott értékekkel dolgozunk</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">first</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// null pointer adunk vissza</span>
<span class="p">}</span>


<span class="c1">//írjuk meg template-tel</span>

<span class="n">T</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="c1">//ugye értjük, hogy miért konst referencia szerint veszem át</span>
<span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">first</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="c1">//pointer aritmetika által mutatott értékekkel dolgozunk</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">first</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>    
<span class="c1">//template pm sosem lehet elég  vizsgára jegyezzük meg</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="o">&gt;</span>
<span class="n">It</span> <span class="n">find</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">first</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="c1">//pointer aritmetika által mutatott értékekkel dolgozunk</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">first</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">last</span><span class="p">;</span>
<span class="p">}</span>    

<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">12</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="p">{</span>
  <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="s">&quot;xy&quot;</span><span class="p">);</span> <span class="c1">//van belső iterátora</span>

<span class="c1">//vizsgán majd egy meglévő kódokat kell kibővíteni, hogy bizonyos konténerre is működjön</span>
<span class="c1">//generikus programozás logikája, mindkét irányban bővíthetőség, vagy új algó vagy új osztályok??</span>
<span class="c1">//</span>
</pre></div>
<p>Konténerek:<br>
<strong>szekvenciális konténerek</strong> én mondom meg hova pakolok be egy elemet
pl: lista vektor(olyan memóriakiosztást használ mint egy C tömb, de dinamikusan allokál) deque std::string(indexelhető, vektorszerű)
<strong>asszociatív adatszerkezetek</strong> set, map, multiset, multimap, nem teszek fel rendezettséget, hanem egy hasítófüggvény dönti el</p>
<p><strong>deque</strong>: memóriatömbök valahol, fix méretűek, mutatnak rájuk pointerek, gyors indexelés
két szélső tömbbe gyors a bepakolás, a vector és deque esetén a közbenső tömbökbe lassú, nem erre vannak kitalálva<br>
listába közbenső részébe is gyors a bepakolás<br></p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vb</span><span class="p">;</span> <span class="c1">//fordítási hiba</span>
<span class="kt">bool</span><span class="o">*</span> <span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vi</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// fordul, nem ugyanaz a reprezentációs vector int és vector bool mögött!</span>

<span class="c1">//koncepció:</span>
<span class="c1">//headerben kell, hogy legyen??</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vec</span>
<span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="c1">//parciális specializáció</span>
<span class="p">{</span>
  <span class="c1">//...</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vec</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="c1">//teljes specializáció</span>
<span class="p">{</span>
  <span class="c1">//...</span>
<span class="p">};</span>
<span class="c1">//compiler a template paraméter alapján dönt</span>
<span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span> <span class="c1">//általános verziót példányosítja</span>
<span class="n">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span> <span class="n">vp</span><span class="p">;</span> <span class="c1">//parciális specializációt példányosítja</span>
<span class="n">Vec</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">vp</span><span class="p">;</span> <span class="c1">//teljes specializáció példányosítja</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">8</span><span class="p">);</span> <span class="c1">//példányosítás fordítási időben megtörténik, és paraméter dedukcióval levezeti, hogy ++ first a  lista iterátorának a növelése</span>

<span class="c1">//jövő héten még az öröklődést nézzük át</span>
<span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span> 
  <span class="k">typename</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">N</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// előre nem tudjuk mi, osztálynak lehet belső statikus tagja ami egy szám</span>
             <span class="c1">//eltakarom belső pointerrel vagy a külső definiált p? nem tud dönteni ezen a ponton a compiler</span>
             <span class="c1">//hogy az ott egy pointer vagy szorzásművelet</span>
             <span class="c1">//typename-mel belső típus és pointer a csillag, typename nélkül szorzás</span>
<span class="p">}</span>
<span class="c1">// nincs lebegőpontos templateparaméterezés, csak int</span>
<span class="c1">// Array&lt;2+1&gt; == Array&lt;3&gt; =/= Array&lt;4&gt;</span>
<span class="c1">// jövő héten még az öröklődést megnézzük</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="12.05-gyakorlat">12.05 gyakorlat<a class="anchor-link" href="#12.05-gyakorlat">&#182;</a></h3><p>Öröklődés<br></p>
<blockquote><p>kód újrafelhasználás<br>
polimorfizmus<br></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//const char*, lefordul, de futási idejű hibát okoz</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">);</span> <span class="c1">//const char*</span>

<span class="k">class</span> <span class="nc">safe_string</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">safe_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">:</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">?</span><span class="nl">p</span><span class="p">:</span><span class="s">&quot; &quot;</span><span class="p">){}</span>
                              <span class="c1">//meghívjuk a konstruktorát, ha null pointer akkor \0</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="c1">//kézzel kidelegálgatjuk a string függvényeit safe_stringbe, helyette inkább öröklés</span>
    <span class="p">{</span>
      <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//kód újrafelhasználás: nem kell nekem ezt kézzel kiírni</span>
<span class="k">class</span> <span class="nc">safe_string</span><span class="o">:</span><span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="c1">//public: safe_stringen működik publikusként az std_string</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">safe_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="o">?</span><span class="nl">p</span><span class="p">:</span><span class="s">&quot; &quot;</span><span class="p">){}</span> <span class="c1">//ha igaz a pointer akkor (nem nulla), akkor mehet tovább</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">safe_string</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">);</span>
  <span class="c1">//még valami</span>
<span class="p">}</span>

<span class="c1">//polimorfizmus</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="c1">//legyen egy bázisosztály, polimorfikus bázis osztály, ha virtuális, akkor a destruktor is legyen az!!</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">const</span> <span class="c1">//ezzel most ne foglalkozz, vagy a Base-é vagy valamelyik altípusé lesz</span>
                           <span class="c1">//ha nem virtuális sem Base sem Der akkor a void g &quot;Base::f()&quot; fog kiírni</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Base::f()&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Der</span><span class="o">:</span><span class="k">public</span> <span class="n">Base</span> <span class="c1">//ha itt nincs virtual de Base-ben igen attól még virtuálisként kezeli!</span>
                      <span class="c1">// elfogadott, hogy mégis írjuk ki a virtualt az altípusban is</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Der::f()&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Der</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="n">Base</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//Base a p statikus típusa</span>
<span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Base</span><span class="p">();</span><span class="c1">//heapen allokálunk, delete-tel fel is kell szabadítani</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span> <span class="c1">// Base::f()</span>
<span class="k">delete</span> <span class="n">p</span><span class="p">;</span> 
<span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">Der</span><span class="p">();</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span> <span class="c1">// Der::f()</span>
<span class="k">delete</span> <span class="n">P</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="c1">//van egy bázisra mutató pointerünk</span>
<span class="p">{</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span> <span class="c1">//ráhív egy altípus f-jére, de még nem tudja, hogy mi</span>
          <span class="c1">//esetszétválasztás</span>
<span class="p">}</span>
<span class="c1">//lefordul</span>
<span class="kt">void</span> <span class="nf">h</span><span class="p">()</span>
<span class="p">{</span> <span class="c1">//stack objektumokként allokálunk</span>
  <span class="n">Base</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">b</span><span class="p">.</span><span class="n">f</span><span class="p">();</span>
  <span class="n">Der</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">s</span><span class="p">(</span><span class="n">Base</span> <span class="n">b</span><span class="p">)</span> <span class="c1">//érték szerint vesszük át, érték szerinti átadás, Base copy ctor meghívódik</span>
<span class="c1">// nem lesz altípusos, ha Der::</span>
<span class="p">{</span>
  <span class="n">b</span><span class="p">.</span><span class="n">f</span><span class="p">();</span> <span class="c1">//slicing</span>
<span class="p">}</span>
<span class="n">s</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">s</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">//akkor is &quot;Base::f&quot; ír ki, hiába igaz, hogy d az Der</span>


<span class="c1">//void f a Base-ben, és virtual ~Base</span>
<span class="k">class</span> <span class="nc">Der</span><span class="o">:</span><span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Der::f()&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Der</span><span class="p">();</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span> <span class="c1">//Base::f()</span>
<span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//Der dtor</span>
          <span class="c1">//Base dtor</span>
<span class="n">Der</span> <span class="n">d</span><span class="p">;</span>
<span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="p">();</span> <span class="c1">//&quot;Der::f()&quot;</span>

<span class="c1">//virtualitás ahhoz szükséges, hogy altípushelyesen fusson le</span>

<span class="k">class</span> <span class="nc">Shape</span> <span class="c1">//síkidom osztály, van pure virtual metódusa, ezért a Shape absztrakt osztály lesz</span>
            <span class="c1">// absztrakt osztályból nem lehet létrehozni objektumokat</span>

<span class="p">{</span>
  <span class="kt">int</span> <span class="n">color</span><span class="p">;</span> <span class="c1">//privát adattag</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Shape</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span><span class="o">:</span><span class="n">color</span><span class="p">(</span><span class="n">c</span><span class="p">){}</span>
          <span class="c1">//konstruktorban beállítjuk int c</span>
    <span class="kt">int</span> <span class="n">get_color</span><span class="p">()</span> <span class="k">const</span>  <span class="c1">//még véletlenül se legyen virtuális</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">get</span><span class="p">.</span><span class="n">area</span><span class="p">()</span> <span class="k">const</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//pure virtual</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">(){}</span>
<span class="p">}</span>

<span class="n">Shape</span> <span class="n">s</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">//fordítási hiba</span>
<span class="n">Shape</span><span class="o">*</span><span class="p">.....</span><span class="c1">//fordítási hiba</span>

<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Shape</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">get_color</span><span class="p">();</span> <span class="c1">//ha a get_color nem virtuális, fordítási időben el van döntve, hogy ez ez</span>
            <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">get_area</span><span class="p">();</span> <span class="c1">//itt nem tudjuk, hogy mit hívunk meg</span>
<span class="p">}</span>
<span class="c1">//--&gt; lefordul?</span>
<span class="c1">//nézzünk egy példát</span>

<span class="c1">//csinálunk egy kört:</span>
<span class="k">class</span> <span class="nc">Circle</span><span class="o">:</span><span class="k">public</span> <span class="n">Shape</span> <span class="c1">//publikusan származik Shape-ből</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">r</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Circle</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">;</span><span class="kt">double</span> <span class="n">r</span><span class="p">)</span><span class="o">:</span><span class="n">Shape</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">r</span><span class="p">(</span><span class="n">rad</span><span class="p">){}</span>
    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">get_area</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="mf">3.14</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Circle</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Sh</span><span class="o">&gt;</span> <span class="c1">//ezt nem tudjuk lefordítani előre, de működik, nem kell virtual</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">Sh</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">get_color</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">get_area</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//többszörös öröklődés</span>
<span class="c1">//Base1 és Base0 a Der mindkettőből származik, több őse van</span>


<span class="c1">//User id,name, email</span>

<span class="c1">//Student id,name,email,vizsgára jelentkezik, jegyet kap</span>
<span class="c1">//Teacher id,name,email,department, vizsgát hirdet,jegyet ad</span>

<span class="c1">//Student vizsgára jelentkezik,jegyet kap</span>
<span class="c1">//Teacher department,vizsgára jelentkezik,jegyet ad</span>

<span class="c1">//diamond chain</span>
<span class="c1">//PhD mindkettőtől örököl két id, két név két email</span>

<span class="c1">//cpp-ben van, ez teljesen legális, nyelvi eszközök ki is vannak dolgozva</span>
<span class="c1">//override cpp11 ha más a paraméterezés akkor nem lefedés stb</span>
<span class="c1">//vizsgafeladatok jövő órán!!!!</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="12.11-el&#337;ad&#225;s">12.11 el&#337;ad&#225;s<a class="anchor-link" href="#12.11-el&#337;ad&#225;s">&#182;</a></h3><p><a href="http://aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/diarymain1.cpp.html">http://aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/diarymain1.cpp.html</a></p>
<p>diary d1( "Tanfolyam kezdete", 2000, 6, 19);
 9      diary d2( "Tanfolyam vege", 2000, 6, 27);
10      diary d3( "Pihenes", 2000, 6, 28);
// fűzögetjük az adatok majd kiíratjuk őket
//ez nem a szabványkönyvtári list
for ( list *lp = &d1; lp; lp = lp-&gt;get_next() ) saját lista</p>
<p>jöjjön a lista implementáció
<a href="http://aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/list1.h.html">http://aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/list1.h.html</a>
kétirány láncolt lista
minden lista elemnek egy const int id; azonosítója</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">;</span> <span class="c1">//globális változó számol, ezen a ponton, headerben nem hozunk léter ész nélkül globális változókat</span>
                <span class="c1">// mégiscsak azt mondjuk, hogy ez globális változó, de csak deklaráció és nem definíció nem hoz létre intnyi tárhelyet a memóriában</span>
</pre></div>
<p>list( const list &amp;rhs);
30      list operator=( const list *rhs);
le akarjuk tiltani a két másoló műveletet, ütné az egyedi azonosító műveletet</p>
<p>static tagfüggvény, osztályhoz tartozik, de nem kap ezen a ponton this nevű paramétert</p>
<div class="highlight"><pre><span></span><span class="mi">12</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">remove</span><span class="p">();</span>
<span class="mi">13</span>      <span class="kt">void</span>  <span class="nf">append</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">lp</span><span class="p">);</span>
<span class="mi">14</span>      <span class="kt">void</span>  <span class="nf">insert</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">lp</span><span class="p">);</span>
<span class="mi">15</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">get_next</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">16</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">get_prev</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prev</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">17</span>
<span class="mi">18</span>      <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="mi">19</span>
<span class="mi">20</span>      <span class="k">static</span> <span class="kt">int</span> <span class="nf">get_nid</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nid</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//nem kap this-t</span>
</pre></div>
<p><a href="http://aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/list2.cpp.html">http://aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/list2.cpp.html</a></p>
<div class="highlight"><pre><span></span><span class="mi">6</span>  <span class="c1">// statikus membert deklarálni kell!!</span>
 <span class="mi">7</span>  <span class="kt">int</span> <span class="n">list</span><span class="o">::</span><span class="n">nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">8</span>
 <span class="mi">9</span>  <span class="c1">// inicializáló lista</span>
<span class="mi">10</span>  <span class="c1">// warning-ot ad, mert a mezők deklarációs sorrendje</span>
<span class="mi">11</span>  <span class="c1">// a list.h-ban mást volt. A list.h az elsődleges!</span>
<span class="mi">12</span>  <span class="n">list</span><span class="o">::</span><span class="n">list</span><span class="p">()</span> <span class="o">:</span> <span class="n">id</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="n">prev</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">//konstans id adattagot nid-del hozzuk létre inicializálás</span>
                                             <span class="c1">//prev és next nullpointerrel, konstanst és referenciát kötelező inicializálni</span>
                   <span class="c1">//fontos, hogy ugyanolyan sorrendben legyen inicializálva mint a headerben: id, prev next</span>
                     <span class="mi">22</span>      <span class="k">const</span> <span class="kt">int</span>  <span class="n">id</span><span class="p">;</span>
<span class="mi">23</span>                           <span class="n">list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="mi">24</span>                           <span class="n">list</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="mi">13</span>  <span class="p">{</span>
<span class="mi">14</span>      <span class="o">++</span><span class="n">nid</span><span class="p">;</span>
<span class="mi">15</span>  <span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="mi">46</span>  <span class="kt">void</span> <span class="n">list</span><span class="o">::</span><span class="n">print</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="mi">47</span>  <span class="p">{</span>
<span class="mi">48</span>      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ id = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ]&quot;</span><span class="p">;</span>
<span class="mi">49</span>  <span class="p">}</span>
<span class="mi">50</span>
<span class="mi">51</span>  <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">list</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span>
<span class="mi">52</span>  <span class="p">{</span>
<span class="mi">53</span>      <span class="n">l</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="mi">54</span>      <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="mi">55</span>  <span class="p">}</span>
<span class="n">mindenk</span><span class="err">é</span><span class="n">ppen</span> <span class="n">ref</span> <span class="n">szerint</span> <span class="n">kell</span> <span class="err">á</span><span class="n">tvenni</span> <span class="n">mert</span> <span class="n">ne</span> <span class="n">mm</span><span class="err">á</span><span class="n">solhat</span><span class="err">ó</span> <span class="mi">33</span>  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">list</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//http://aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/diary1.h.html</span>
<span class="c1">//származzon két típusból</span>


 <span class="mi">1</span>  <span class="c1">// Még nem polimorfikus</span>
 <span class="mi">2</span>
 <span class="mi">3</span>  <span class="err">#</span><span class="n">ifndef</span> <span class="n">DIARY_H</span>
 <span class="mi">4</span>  <span class="err">#</span><span class="n">define</span> <span class="n">DIARY_H</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">7</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
 <span class="mi">8</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;list1.h&quot;</span>
 <span class="mi">9</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;date.h&quot;</span>
<span class="mi">10</span>
<span class="mi">11</span>  <span class="k">class</span> <span class="nc">diary</span> <span class="o">:</span> <span class="k">public</span> <span class="n">list</span><span class="p">,</span> <span class="k">public</span> <span class="n">date</span> <span class="c1">//két őse lesz! két bázisa lesz</span>
<span class="mi">12</span>  <span class="c1">// lehetséges lenne örökölni az std::string-ből is</span>
    <span class="c1">//értelmezett az összes diary és list művelet rajta</span>
    <span class="c1">// diary d(&quot;Vizsga,C++&quot;, 2018, 12, 21);</span>
    <span class="c1">// d.set_day(22);</span>
    <span class="c1">//először a lista konstruktor fut majd a date, utána az std::string event fog inicializálódni</span>
<span class="mi">13</span>  <span class="p">{</span>
<span class="mi">14</span>  <span class="k">public</span><span class="o">:</span>
        <span class="c1">//konstruktor nem öröklődik</span>
        <span class="c1">//eseményt kell beállítani meg a dátumot</span>
<span class="mi">15</span>      <span class="n">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="mi">16</span>      <span class="nf">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="mi">17</span>      <span class="nf">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="n">date</span><span class="o">&amp;</span> <span class="n">dd</span><span class="p">);</span>
<span class="mi">18</span>
<span class="mi">19</span>      <span class="c1">// ebben a verzióban még nem virtuális</span>
<span class="mi">20</span>      <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="mi">21</span>  <span class="k">private</span><span class="o">:</span>
<span class="mi">22</span>      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">event</span><span class="p">;</span>
    <span class="c1">//d.next();</span>
    <span class="c1">//d.push_back(&#39;!&#39;); // ezt nem akarjuk, emiatt az esemény egy privát adattag</span>
<span class="mi">23</span>  <span class="p">};</span>
<span class="mi">24</span>
<span class="mi">25</span>  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">diary</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
<span class="mi">26</span>
<span class="mi">27</span>  <span class="err">#</span><span class="n">endif</span> <span class="cm">/* DIARY_H */</span>
<span class="mi">28</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="mi">1</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">2</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;diary1.h&quot;</span>
 <span class="mi">3</span>
 <span class="mi">4</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="n">diary</span><span class="o">::</span><span class="n">diary</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">date</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">d</span><span class="p">),</span><span class="n">event</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
 <span class="mi">7</span>
 <span class="mi">8</span>  <span class="n">diary</span><span class="o">::</span><span class="n">diary</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">date</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">event</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">//nem kell bázisnév, nincs super kulcsszó</span>
                                                                       <span class="c1">//helyette a típus nevével dolgozunk</span>
 <span class="mi">9</span>
<span class="mi">10</span>  <span class="n">diary</span><span class="o">::</span><span class="n">diary</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="n">date</span><span class="o">&amp;</span> <span class="n">dd</span> <span class="p">)</span> <span class="o">:</span> <span class="n">date</span><span class="p">(</span><span class="n">dd</span><span class="p">),</span> <span class="n">event</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="mi">11</span>
<span class="mi">12</span>  <span class="kt">void</span> <span class="n">diary</span><span class="o">::</span><span class="n">print</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="mi">13</span>  <span class="p">{</span>
<span class="mi">14</span>      <span class="n">list</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="mi">15</span>      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
<span class="mi">16</span>      <span class="n">date</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="mi">17</span>      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
<span class="mi">18</span>      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">event</span><span class="p">;</span>
<span class="mi">19</span>  <span class="p">}</span>
<span class="mi">20</span>  <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">diary</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="c1">// no cpy constr, nem másolható a diary, ezért kötelezően ref szerint vesszük át</span>
<span class="mi">21</span>  <span class="p">{</span>
<span class="mi">22</span>      <span class="n">d</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="mi">23</span>      <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="mi">24</span>  <span class="p">}</span>
<span class="mi">25</span>
<span class="mi">26</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="mi">1</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">2</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;diary1.h&quot;</span>
 <span class="mi">3</span>
 <span class="mi">4</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
 <span class="mi">7</span>  <span class="p">{</span>
 <span class="mi">8</span>      <span class="n">diary</span> <span class="n">d1</span><span class="p">(</span> <span class="s">&quot;Tanfolyam kezdete&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
 <span class="mi">9</span>      <span class="n">diary</span> <span class="n">d2</span><span class="p">(</span> <span class="s">&quot;Tanfolyam vege&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
<span class="mi">10</span>      <span class="n">diary</span> <span class="n">d3</span><span class="p">(</span> <span class="s">&quot;Pihenes&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
<span class="mi">11</span>
<span class="mi">12</span>      <span class="n">d2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
<span class="mi">13</span>      <span class="n">d3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">);</span>
<span class="mi">14</span>
<span class="mi">15</span>  <span class="c1">//  for ( diary *dp = &amp;d1; dp; dp = dp-&gt;get_next() ) // syntax error!</span>
<span class="mi">16</span>      <span class="k">for</span> <span class="p">(</span> <span class="n">list</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">;</span> <span class="n">lp</span><span class="p">;</span> <span class="n">lp</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">get_next</span><span class="p">()</span> <span class="p">)</span>
<span class="mi">17</span>      <span class="p">{</span>
<span class="mi">18</span>           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span> <span class="c1">//kiírjuk a listára mutató pointer dereferálását</span>
<span class="mi">19</span>           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="mi">20</span>      <span class="p">}</span>
<span class="mi">21</span>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">22</span>  <span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//1b</span>
 <span class="mi">1</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">2</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;diary1.h&quot;</span>
 <span class="mi">3</span>
 <span class="mi">4</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
 <span class="mi">7</span>  <span class="p">{</span>
 <span class="mi">8</span>      <span class="n">diary</span> <span class="n">d1</span><span class="p">(</span> <span class="s">&quot;Tanfolyam kezdete&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
 <span class="mi">9</span>      <span class="n">diary</span> <span class="n">d2</span><span class="p">(</span> <span class="s">&quot;Tanfolyam vege&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
<span class="mi">10</span>      <span class="n">diary</span> <span class="n">d3</span><span class="p">(</span> <span class="s">&quot;Pihenes&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
<span class="mi">11</span>
<span class="mi">12</span>      <span class="n">d2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
<span class="mi">13</span>      <span class="n">d3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">);</span>
<span class="mi">14</span>
<span class="mi">15</span>      <span class="k">for</span> <span class="p">(</span> <span class="n">diary</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">;</span> <span class="n">dp</span><span class="p">;</span> <span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">diary</span><span class="o">*</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">get_next</span><span class="p">()</span> <span class="p">)</span>
<span class="mi">16</span>  <span class="c1">//    for ( list *lp = &amp;d1; lp; lp = lp-&gt;get_next() ) </span>
<span class="mi">17</span>      <span class="p">{</span>
<span class="mi">18</span>           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>   <span class="c1">// most már jó! ...vagy mégsem?</span>
<span class="mi">19</span>           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="mi">20</span>      <span class="p">}</span>
<span class="mi">21</span>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">22</span>  <span class="p">}</span>

 <span class="mi">1</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">2</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;diary1.h&quot;</span>
 <span class="mi">3</span>
 <span class="mi">4</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
 <span class="mi">7</span>  <span class="p">{</span>
 <span class="mi">8</span>      <span class="n">diary</span> <span class="n">d1</span><span class="p">(</span> <span class="s">&quot;Tanfolyam kezdete&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
 <span class="mi">9</span>      <span class="n">diary</span> <span class="n">d2</span><span class="p">(</span> <span class="s">&quot;Tanfolyam vege&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
<span class="mi">10</span>      <span class="n">diary</span> <span class="n">d3</span><span class="p">(</span> <span class="s">&quot;Pihenes&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
<span class="mi">11</span>
<span class="mi">12</span>      <span class="c1">// orvul közbelép a felhasználó:</span>
<span class="mi">13</span>      <span class="n">list</span> <span class="n">l</span><span class="p">;</span>
<span class="mi">14</span>
<span class="mi">15</span>      <span class="n">d2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
<span class="mi">16</span>      <span class="n">d3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">);</span>
<span class="mi">17</span>      <span class="n">l</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">);</span> <span class="c1">//megpróbálunk esemény nélküli lista elemet appendálni</span>
<span class="mi">18</span>
<span class="mi">19</span>
<span class="mi">20</span>      <span class="k">for</span> <span class="p">(</span> <span class="n">diary</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">;</span> <span class="n">dp</span><span class="p">;</span> <span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">diary</span><span class="o">*</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">get_next</span><span class="p">()</span> <span class="p">)</span>
<span class="mi">21</span>  <span class="c1">//    for ( list *lp = &amp;d1; lp; lp = lp-&gt;get_next() ) </span>
<span class="mi">22</span>      <span class="p">{</span>
<span class="mi">23</span>           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>   <span class="c1">// runtime error! //illegális tárterületet próbálunk elérni</span>
<span class="mi">24</span>           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="mi">25</span>      <span class="p">}</span>
<span class="mi">26</span>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">27</span>  <span class="p">}</span>


<span class="nl">http</span><span class="p">:</span><span class="c1">//aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/diarymain2.cpp.html</span>
 <span class="mi">1</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">2</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;diary2.h&quot;</span>
 <span class="mi">3</span>
 <span class="mi">4</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
 <span class="mi">7</span>  <span class="p">{</span>
 <span class="mi">8</span>      <span class="n">diary</span> <span class="n">d1</span><span class="p">(</span> <span class="s">&quot;Tanfolyam kezdete&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
 <span class="mi">9</span>      <span class="n">diary</span> <span class="n">d2</span><span class="p">(</span> <span class="s">&quot;Tanfolyam vege&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
<span class="mi">10</span>      <span class="n">diary</span> <span class="n">d3</span><span class="p">(</span> <span class="s">&quot;Pihenes&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
<span class="mi">11</span>
<span class="mi">12</span>      <span class="n">d2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
<span class="mi">13</span>      <span class="n">d3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">);</span>
<span class="mi">14</span>
<span class="mi">15</span>      <span class="n">list</span> <span class="n">l</span><span class="p">;</span>
<span class="mi">16</span>      <span class="n">l</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">);</span>
<span class="mi">17</span>
<span class="mi">18</span>      <span class="k">for</span> <span class="p">(</span> <span class="n">list</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">;</span> <span class="n">lp</span><span class="p">;</span> <span class="n">lp</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">get_next</span><span class="p">()</span> <span class="p">)</span>
<span class="mi">19</span>      <span class="p">{</span>
<span class="mi">20</span>          <span class="k">if</span> <span class="p">(</span> <span class="n">diary</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">diary</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">)</span> <span class="c1">//eldönti a list* bázisra mutató pointerről, hogy futási időben az diary vagy lista ha lista, akkor belép az else ágba, futás idejű validálás</span>
<span class="mi">21</span>          <span class="p">{</span>
<span class="mi">22</span>              <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
<span class="mi">23</span>          <span class="p">}</span>
<span class="mi">24</span>          <span class="k">else</span>
<span class="mi">25</span>          <span class="p">{</span>
<span class="mi">26</span>              <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span> <span class="c1">//egész jónak tűnik, de a diary2-t includeoltuk</span>
<span class="mi">27</span>          <span class="p">}</span>
<span class="mi">28</span>          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="mi">29</span>      <span class="p">}</span>
<span class="mi">30</span>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">31</span>  <span class="p">}</span>
<span class="mi">32</span>
     <span class="mi">1</span>  <span class="c1">// polimorfikus: mert egyik őse polimorfikus</span>
 <span class="mi">2</span>
 <span class="mi">3</span>  <span class="err">#</span><span class="n">ifndef</span> <span class="n">DIARY_H</span>
 <span class="mi">4</span>  <span class="err">#</span><span class="n">define</span> <span class="n">DIARY_H</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">7</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
 <span class="mi">8</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;list2.h&quot;</span>
 <span class="mi">9</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;date.h&quot;</span>
<span class="mi">10</span>
<span class="mi">11</span>  <span class="k">class</span> <span class="nc">diary</span> <span class="o">:</span> <span class="k">public</span> <span class="n">list</span><span class="p">,</span> <span class="k">public</span> <span class="n">date</span>
<span class="mi">12</span>  <span class="p">{</span>
<span class="mi">13</span>  <span class="k">public</span><span class="o">:</span>
<span class="mi">14</span>      <span class="n">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="mi">15</span>      <span class="nf">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="mi">16</span>      <span class="nf">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="n">date</span><span class="o">&amp;</span> <span class="n">dd</span><span class="p">);</span>
<span class="mi">17</span>
<span class="mi">18</span>      <span class="cm">/* virtual */</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="mi">19</span>  <span class="k">private</span><span class="o">:</span>
<span class="mi">20</span>      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">event</span><span class="p">;</span>
<span class="mi">21</span>  <span class="p">};</span>
<span class="mi">22</span>
<span class="mi">23</span>  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">diary</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
<span class="mi">24</span>
<span class="mi">25</span>  <span class="err">#</span><span class="n">endif</span> <span class="cm">/* DIARY_H */</span>
<span class="mi">26</span>

<span class="nl">http</span><span class="p">:</span><span class="c1">//aszt.inf.elte.hu/~gsd/pny2/html/ea9_oroklodes/list2.h.html</span>
 <span class="mi">1</span>  <span class="err">#</span><span class="n">ifndef</span> <span class="n">LIST_H</span>
 <span class="mi">2</span>  <span class="err">#</span><span class="n">define</span> <span class="n">LIST_H</span>
 <span class="mi">3</span>
 <span class="mi">4</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="k">class</span> <span class="nc">list</span> <span class="c1">//polimorfikus osztály, van egy virtual voidja</span>
 <span class="mi">7</span>  <span class="p">{</span>
 <span class="mi">8</span>  <span class="k">public</span><span class="o">:</span>
 <span class="mi">9</span>           <span class="n">list</span><span class="p">();</span>
<span class="mi">10</span>      <span class="c1">// ökölszabály: polimorfikus osztálynak legyen </span>
<span class="mi">11</span>      <span class="c1">// virtuális destruktora!</span>
<span class="mi">12</span>      <span class="k">virtual</span>  <span class="o">~</span><span class="n">list</span><span class="p">();</span>
<span class="mi">13</span>
<span class="mi">14</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">remove</span><span class="p">();</span>
<span class="mi">15</span>      <span class="kt">void</span>  <span class="nf">append</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">lp</span><span class="p">);</span>
<span class="mi">16</span>      <span class="kt">void</span>  <span class="nf">insert</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">lp</span><span class="p">);</span>
<span class="mi">17</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">get_next</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">18</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">get_prev</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prev</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">19</span>
<span class="mi">20</span>      <span class="c1">// virtuális függvény</span>
<span class="mi">21</span>      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//felüldefiniálhatjuk, virtual adunk egy alapértelmezett implementációt, de polimorficitás azt mondja, hogy nem biztos, hogy ez lesz</span>
<span class="mi">22</span>
<span class="mi">23</span>      <span class="k">static</span> <span class="kt">int</span> <span class="nf">get_nid</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nid</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">24</span>  <span class="k">private</span><span class="o">:</span>
<span class="mi">25</span>      <span class="k">const</span> <span class="kt">int</span>  <span class="n">id</span><span class="p">;</span>
<span class="mi">26</span>            <span class="n">list</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="mi">27</span>            <span class="n">list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="mi">28</span>
<span class="mi">29</span>      <span class="k">static</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
<span class="mi">30</span>
<span class="mi">31</span>      <span class="nf">list</span><span class="p">(</span> <span class="k">const</span> <span class="n">list</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="mi">32</span>      <span class="n">list</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">list</span> <span class="o">*</span><span class="n">rhs</span><span class="p">);</span>
<span class="mi">33</span>  <span class="p">};</span>
<span class="mi">34</span>
<span class="mi">35</span>  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">list</span><span class="o">&amp;</span><span class="p">);</span>
<span class="mi">36</span>
<span class="mi">37</span>  <span class="err">#</span><span class="n">endif</span> <span class="cm">/* LIST_H */</span>
<span class="mi">38</span>
<span class="mi">39</span>
<span class="c1">//list2.cpp</span>
    <span class="kt">void</span> <span class="n">list</span><span class="o">::</span><span class="n">print</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[ id = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ]&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">list</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">l</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span> <span class="c1">//virtualitás, el kell engedje a compiler, hogy melyik print fog lefutni!!!</span>
                 <span class="c1">//ez a virtualitás, itt a compiler már nem tudja, hogy mi fog lefutni</span>
                 <span class="c1">//felüldefiniálható a print metódus, tud olyan típusokkal együttműködni, amelyek nem állnak rendelkezésre adott esetben</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="mi">1</span>  <span class="c1">// polimorfikus: mert egyik őse polimorfikus</span>
 <span class="mi">2</span>
 <span class="mi">3</span>  <span class="err">#</span><span class="n">ifndef</span> <span class="n">DIARY_H</span>
 <span class="mi">4</span>  <span class="err">#</span><span class="n">define</span> <span class="n">DIARY_H</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">7</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
 <span class="mi">8</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;list2.h&quot;</span>
 <span class="mi">9</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;date.h&quot;</span>
<span class="mi">10</span>
<span class="mi">11</span>  <span class="k">class</span> <span class="nc">diary</span> <span class="o">:</span> <span class="k">public</span> <span class="n">list</span><span class="p">,</span> <span class="k">public</span> <span class="n">date</span>
<span class="mi">12</span>  <span class="p">{</span>
<span class="mi">13</span>  <span class="k">public</span><span class="o">:</span>
<span class="mi">14</span>      <span class="n">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="mi">15</span>      <span class="nf">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="mi">16</span>      <span class="nf">diary</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="n">date</span><span class="o">&amp;</span> <span class="n">dd</span><span class="p">);</span>
<span class="mi">17</span>
<span class="mi">18</span>      <span class="cm">/* virtual */</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//szeretjük kiírni a virtualt</span>
<span class="mi">19</span>  <span class="k">private</span><span class="o">:</span>
<span class="mi">20</span>      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">event</span><span class="p">;</span>
<span class="mi">21</span>  <span class="p">};</span>
<span class="mi">22</span>
<span class="mi">23</span>  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">diary</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
<span class="mi">24</span>
<span class="mi">25</span>  <span class="err">#</span><span class="n">endif</span> <span class="cm">/* DIARY_H */</span>

    <span class="c1">//list2h html ha diary akkor diaryként ha nem akkor lista, futásidőben </span>
 <span class="mi">1</span>  <span class="err">#</span><span class="n">ifndef</span> <span class="n">LIST_H</span>
 <span class="mi">2</span>  <span class="err">#</span><span class="n">define</span> <span class="n">LIST_H</span>
 <span class="mi">3</span>
 <span class="mi">4</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="k">class</span> <span class="nc">list</span>
 <span class="mi">7</span>  <span class="p">{</span>
 <span class="mi">8</span>  <span class="k">public</span><span class="o">:</span>
 <span class="mi">9</span>           <span class="n">list</span><span class="p">();</span>
<span class="mi">10</span>      <span class="c1">// ökölszabály: polimorfikus osztálynak legyen </span>
<span class="mi">11</span>      <span class="c1">// virtuális destruktora!</span>
<span class="mi">12</span>      <span class="k">virtual</span>  <span class="o">~</span><span class="n">list</span><span class="p">();</span>
<span class="mi">13</span>
<span class="mi">14</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">remove</span><span class="p">();</span>
<span class="mi">15</span>      <span class="kt">void</span>  <span class="nf">append</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">lp</span><span class="p">);</span>
<span class="mi">16</span>      <span class="kt">void</span>  <span class="nf">insert</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">lp</span><span class="p">);</span>
<span class="mi">17</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">get_next</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">18</span>      <span class="n">list</span> <span class="o">*</span><span class="nf">get_prev</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prev</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">19</span>
<span class="mi">20</span>      <span class="c1">// virtuális függvény</span>
<span class="mi">21</span>      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="mi">22</span>
<span class="mi">23</span>      <span class="k">static</span> <span class="kt">int</span> <span class="nf">get_nid</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nid</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">24</span>  <span class="k">private</span><span class="o">:</span>
<span class="mi">25</span>      <span class="k">const</span> <span class="kt">int</span>  <span class="n">id</span><span class="p">;</span>
<span class="mi">26</span>            <span class="n">list</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="mi">27</span>            <span class="n">list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="mi">28</span>
<span class="mi">29</span>      <span class="k">static</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
<span class="mi">30</span>
<span class="mi">31</span>      <span class="nf">list</span><span class="p">(</span> <span class="k">const</span> <span class="n">list</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="mi">32</span>      <span class="n">list</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">list</span> <span class="o">*</span><span class="n">rhs</span><span class="p">);</span>
<span class="mi">33</span>  <span class="p">};</span>
<span class="mi">34</span>
<span class="mi">35</span>  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">list</span><span class="o">&amp;</span><span class="p">);</span>
<span class="mi">36</span>
<span class="mi">37</span>  <span class="err">#</span><span class="n">endif</span> <span class="cm">/* LIST_H */</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">//diarymain3.cpp</span>
 <span class="mi">1</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
 <span class="mi">2</span>  <span class="err">#</span><span class="n">include</span> <span class="s">&quot;diary2.h&quot;</span>
 <span class="mi">3</span>
 <span class="mi">4</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 <span class="mi">5</span>
 <span class="mi">6</span>  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
 <span class="mi">7</span>  <span class="p">{</span>
 <span class="mi">8</span>      <span class="n">diary</span> <span class="n">d1</span><span class="p">(</span> <span class="s">&quot;Tanfolyam kezdete&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
 <span class="mi">9</span>      <span class="n">diary</span> <span class="n">d2</span><span class="p">(</span> <span class="s">&quot;Tanfolyam vege&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
<span class="mi">10</span>      <span class="n">diary</span> <span class="n">d3</span><span class="p">(</span> <span class="s">&quot;Pihenes&quot;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
<span class="mi">11</span>
<span class="mi">12</span>      <span class="n">d2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d1</span><span class="p">);</span>
<span class="mi">13</span>      <span class="n">d3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">);</span>
<span class="mi">14</span>
<span class="mi">15</span>      <span class="n">list</span> <span class="n">l</span><span class="p">;</span>
<span class="mi">16</span>      <span class="n">l</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">);</span>
<span class="mi">17</span>
<span class="mi">18</span>      <span class="k">for</span> <span class="p">(</span> <span class="n">list</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">;</span> <span class="n">lp</span><span class="p">;</span> <span class="n">lp</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">get_next</span><span class="p">()</span> <span class="p">)</span>
<span class="mi">19</span>      <span class="p">{</span>
<span class="mi">20</span>          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">lp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="mi">21</span>      <span class="p">}</span>
<span class="mi">22</span>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">23</span>  <span class="p">}</span>
</pre></div>
<p>pillanatra térjünk vissza template-ekhez és az STL-hez</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span><span class="c1">//asszociatív adatszerkezet, rendezetlenül tárol adatokat</span>
                <span class="c1">// template -&gt; szükséges megadni mit fog tárolni</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="c1">//felüldefiniálható a rendezetlenség</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Comp</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&gt;</span> <span class="c1">//második template paraméter, definiálja mi a rendezés a paraméterek között</span>
<span class="c1">//a less olyan STL osztály amely rendezést tesz lehetővé</span>
<span class="c1">// Key megadása kötelező, Comp megadása opcionális</span>

<span class="k">class</span> <span class="nc">set</span>

<span class="nl">http</span><span class="p">:</span><span class="c1">//aszt.inf.elte.hu/~gsd/pny2/html/eaB_polimorf/vehicle.h.html</span>
<span class="cp">#ifndef VEHICLE_H</span>
<span class="cp">#define VEHICLE_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>


<span class="c1">// polimorfikus osztály, mert van virtuális függvénye,</span>
<span class="c1">// és absztrakt osztály, mert van legalább egy </span>
<span class="c1">// pure virtual függvénye</span>
<span class="k">class</span> <span class="nc">vehicle</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vehicle</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">reg</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//nem default konstruáltható, nincs vehicle, majd a konkrét járműveknél fogjuk meghívni a default konstruktor, ez egy abstract osztály</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">vehicle</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>  <span class="c1">// virtuális destruktor! //annál jobban tud optimalizálni minél inkább tudja, hogy mi fog elindulni, a virtuális, pont ennek az ellentéte, semmit nem tud optimalizálni, mert nem tudja mi fut le, virtualitás az altípusokban nem megszűntethető, azt kell tisztán látni, hogy mi pure virtual és mit akarok és mit nem, nem a végleges implementáció, vehicle v(&quot;ABCD123&quot;) ilyet nem akarink engedni</span>

<span class="c1">//örökölődés praktikus, virtuális metódusok, adunk egy default implementációt ,muszáj kikényszeríteni a virtual???</span>
<span class="c1">//template-eknél fordítási időben, lefordírjuk és futási időben deríjtük, template-ek jobban tudnak alkalmazkodni</span>
<span class="c1">//cpp masszívan támogatja az oop-t, de azért a template-ekhez közel áll</span>



    <span class="c1">// ez nem virtual</span>
    <span class="kt">bool</span> <span class="n">print</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; with reg = &quot;</span>
                  <span class="o">&lt;&lt;</span> <span class="n">get_reg</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">mv</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//ezen a ponton nem tudjuk mi az mv, absztrakt osztály</span>
        <span class="k">return</span> <span class="nf">mv</span><span class="p">();</span>
    <span class="p">}</span> <span class="c1">//nem virtuális tagfüggvény typeid</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_reg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">reg</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//lekérdező nem virtuális metódus, senki ne hamisítsa meg</span>

    <span class="c1">// pure virtual</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">mv</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//=0 azt jelenti, hogy nem tudok alapértelmezett implementációt adni, mv itt a műszaki vizsga</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">reg</span><span class="p">;</span> <span class="c1">//mindegyiknek van rendszáma</span>
<span class="p">};</span>

<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">vehicle</span><span class="o">::</span><span class="n">mv</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">reg</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* VEHICLE_H */</span><span class="cp"></span>

<span class="c1">//vehicle cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;vehicle.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;car.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bus.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;truck.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">global_print</span><span class="p">(</span><span class="n">vehicle</span> <span class="o">*</span><span class="n">vp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vp</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="n">vehicle</span><span class="o">*&gt;</span> <span class="n">vl</span><span class="p">;</span>
    <span class="n">vl</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">car</span><span class="p">(</span><span class="s">&quot;abc123&quot;</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">vl</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">bus</span><span class="p">(</span><span class="s">&quot;bbb123&quot;</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">vl</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">truck</span><span class="p">(</span><span class="s">&quot;eee765&quot;</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">vl</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">truck</span><span class="p">(</span><span class="s">&quot;fff098&quot;</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">vl</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">bus</span><span class="p">(</span><span class="s">&quot;ccc456&quot;</span><span class="p">,</span> <span class="mi">55</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">vl</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">car</span><span class="p">(</span><span class="s">&quot;bcd2&quot;</span><span class="p">)</span> <span class="p">);</span>

<span class="cm">/*  for ( list&lt;vehicle*&gt;::iterator vi = vl.begin(); vi != vl.end(); ++vi)</span>
<span class="cm">    {</span>
<span class="cm">        global_print(*vi);</span>
<span class="cm">    }</span>
<span class="cm"> */</span>
    <span class="n">for_each</span><span class="p">(</span> <span class="n">vl</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vl</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">global_print</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//truck</span>
<span class="cp">#ifndef TRUCK_H</span>
<span class="cp">#define TRUCK_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;vehicle.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">truck</span> <span class="o">:</span> <span class="k">public</span> <span class="n">vehicle</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">truck</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">w</span><span class="p">)</span> <span class="o">:</span> <span class="n">vehicle</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">weight</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="p">{}</span>

    <span class="cm">/* virtual */</span> <span class="kt">bool</span> <span class="n">mv</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vehicle</span><span class="o">::</span><span class="n">mv</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="mf">4.0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//bázis pure virtualét akarom használni, most épp implementálva van</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">weight</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* TRUCK_H */</span><span class="cp"></span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="12.12-gyakorlat">12.12 gyakorlat<a class="anchor-link" href="#12.12-gyakorlat">&#182;</a></h3><p>+/- pót</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span> <span class="c1">//legalább 1 eleme van</span>
<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">Max</span><span class="p">()).</span><span class="n">get</span><span class="p">();</span> <span class="c1">//harmadik pm egy max üreszárójel valami</span>
<span class="c1">//feladat megcsinálni a valamit</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">sl</span><span class="p">.</span><span class="n">h</span> <span class="n">l</span><span class="err">é</span><span class="n">trehoz</span><span class="err">á</span><span class="n">sa</span> <span class="err">é</span><span class="n">s</span> <span class="n">megkaptuk</span> <span class="n">az</span> <span class="n">egyest</span><span class="p">.</span> <span class="n">v</span><span class="err">é</span><span class="n">gig</span> <span class="n">a</span> <span class="n">headerben</span> <span class="n">dolgozunk</span>
<span class="cp">#ifndef SL__H headerguard-dal levédjük</span>
<span class="cp">#define SL__H</span>
<span class="cp">#include</span><span class="cpf">&lt;list&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;functional&gt; //itt vannak a funktor típusok</span><span class="cp"></span>
<span class="c1">//kétirányú láncolt lista kellene, ráadásul rendezett</span>
<span class="c1">//vannak műveletei ennek az osztály templatenek, insertje, frontja -&gt; örökléssel vagy vegyük fel privát adattagnak</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Comp</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="c1">//rendezés-&gt; második template paraméter class Comp, nem kötelező megadni, de lehetne valami teljesen más rendezést kérni a növekvő helyett, lesz egy alapértelmezett std::less értéke, less egy template osztály</span>
<span class="k">class</span> <span class="nc">SortedList</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//van egy privát adattag</span>
<span class="c1">//jó ötlet-e std::listből leszármaztatni, logikus, hasonló műveleteket tartalmaz, de van push_backje, nem lesz rendezett, felüldefiniáljuk az altípus műveletét? annyira nem jó ez, ne legyen öröklés </span>
  <span class="k">public</span><span class="o">:</span>
    <span class="c1">//írjunk publikus műveleteket, egyelőre nem logikus, hogy kellene default ctor, copy ctor sem kell, mert alapértelmezettként úgyis létrejönnek</span>
    <span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span> <span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">);</span>
    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="c1">//hatékonyabb mint érték szerint átvenni, ezért használjuk az konst ref szerinti átadást  </span>
    <span class="p">{</span><span class="c1">//kihasználjuk, hogy ez már rendezett</span>
      <span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="c1">//hova kellene beszúrni, multisetnél volt: upper_bound, lower_bound</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">t</span><span class="p">,</span><span class="n">Comp</span><span class="p">()),</span><span class="n">t</span><span class="p">);</span> <span class="c1">//használjuk a konténerfüggetlen lower_bound-ot, x-hez viszonyított alsó határt visszaadja, keressük a t helyét, nem tudjuk igazából mi a rendezés, de Comp template pm-t át kell adni, 4 paraméteres lower_bound, a három pm-es feltételezi, hogy növekvő a sorrend, megkerestük a Comp rendezés szerinti t helyét és ha az megvan akkor insertáljuk t-t</span>
    <span class="c1">//nem a findot hívtuk meg mert az lassú</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="c1">//sufnituning műveletek, ezt lett volna jó kikerülni örökléssel, de ki tuja milyen műveletek használnának</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">//std::list&lt;int&gt; s;</span>
    <span class="c1">//s.push_back(3);</span>
    <span class="c1">//s.front() = 7;</span>
    <span class="c1">//const std::list&lt;int&gt; c = s;</span>
    <span class="c1">//std::cout &lt;&lt; c.front();</span>
    <span class="c1">//c.front() = 6; //fordítási hiba, emiatt sem akartunk volna öröklést alkalmazni</span>

    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span>         <span class="c1">//második const: akár const akár nem hívjuk meg, ezt jelenti</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">cont</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="c1">//</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">c</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">//látszólag működik, de mégsem szép a megoldás -&gt; házifeladat, ahol egyenlő elemet talál ott törli</span>
      <span class="n">std</span><span class="o">::</span><span class="n">equal_range</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">t</span><span class="p">,</span><span class="n">Comp</span><span class="p">()),</span><span class="n">t</span><span class="p">)</span> <span class="c1">//mit ad vissza az equal range (interv?) és ez megy c.erase(intervallumot töröl), c.erase(,) // főprogram a szép megoldást is elfogadja</span>
    <span class="p">}</span> <span class="c1">//itt operator== hasonlítunk, de Employeenál?</span>

    <span class="c1">//ennyi kellett a hármashoz</span>
    <span class="c1">// szeretnénk, ha már STL kompatibilisek vagyunk, akkor</span>
    <span class="c1">//SortedList&lt;int&gt; s;</span>
    <span class="c1">//SortedList&lt;int&gt;::iterator i=s.begin(); //belső típust nem várja el a főprogram, de legyen most jól megcsinálva</span>
    <span class="c1">//*i = 43; //ilyet nem akarunk engedélyeztetni</span>
    <span class="c1">//std::list&lt;int&gt; a;</span>
    <span class="c1">//a.push_back(3);</span>
    <span class="c1">//*(a.begin()) = 8;</span>
    <span class="c1">//int v[] = {3,8,7};</span>
    <span class="c1">//int *p = v;</span>
    <span class="c1">//*p = 11;</span>
    <span class="c1">//const in *cp = v;</span>
    <span class="c1">//*cp = 5; //fordítási hiba, emiatt</span>
    <span class="c1">//std::list&lt;int&gt;::const_iterator //megint jó, hogy nem örököltünk, különben megörököltük volna a módosítható iterátort, *gal ki tudom olvasni, de nem módosítható</span>
    <span class="c1">//typedef, típusszinonímák létrehozása</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">iterator</span><span class="p">;</span> <span class="c1">//typename lesz a const_iterator álneve</span>
    <span class="n">iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//négyes megvan jöhet az ötös</span>
    <span class="c1">//intervallumkonstruktorok istream, intervallumot adunk meg, írjunk egy olyan konstruktor a sorted listhez, ami intervallumból hozza létre a ?</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIt</span><span class="o">&gt;</span>
    <span class="n">SortedList</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">)</span><span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">)</span> <span class="c1">//balról zárt jobbról nyílt</span>
                                            <span class="c1">//c adattagot megkonstruáljuk a first last-tal</span>
    <span class="c1">//írtunk egy konstruktor</span>
    <span class="c1">//még nem rendezett a lista</span>
    <span class="p">{</span>
      <span class="n">c</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Comp</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">//mivel írtunk egyk onstruktort ezért</span>
    <span class="n">SortedList</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">//hogy az előző részek működjenek</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="c1">//STL használható, internet is, három óra van</span>
</pre></div>
<p>következő feladat<br></p>
<div class="highlight"><pre><span></span><span class="c1">//pstack.h //priority stack, mi a nagyobb prioritás, nem kell beégetni a kódba</span>
<span class="c1">//include guarddal levédjük, meg tudjuk csinálni</span>
<span class="c1">//teljes tartalom a headerbe</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pr</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span><span class="k">class</span> <span class="nc">Comp</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">Pr</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="c1">//ha más nem akkor integert adunk prioritásnak</span>
<span class="k">class</span> <span class="nc">priority_stack</span>
<span class="p">{</span><span class="c1">//prioritás szerinti elemeket elérjük, </span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Pr</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Comp</span><span class="o">&gt;</span> <span class="n">prs</span><span class="p">;</span><span class="c1">//minden prioritáshoz egy stacket tárol, kulcs, tárol érték,map kulcsainak rendezése</span>
  <span class="c1">//tudok hivatkozni prs-sel a hosszú típusnévre, tehát prs egy rövid típusnév</span>
  <span class="n">prs</span> <span class="n">ps</span><span class="p">;</span> <span class="c1">//ps a privát adattagom neve</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">Pr</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">//p prioritáshoz tartozó stack és az ott lévő szerkezetbe pusholom a t-t</span>
      <span class="n">ps</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">//ha nem volt ilyen prioritás akkor pusholom a t-t egy üresbe és változik a méret</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="k">const</span> <span class="n">Pr</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="c1">//const művelet nem rontja el az adatszerkezetet</span>
    <span class="p">{</span>         
      <span class="c1">//return ps[p] //nem mondhatom, mert nem tudja a compiler, hogy van-e i lyen p, indexelés hatására elromolhat a map</span>
      <span class="k">return</span> <span class="n">ps</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
      <span class="c1">//visszaad egy iterátort és ennek a második értékét vesszük, és ennek már lekérdezhetjük az értékét</span>
    <span class="p">}</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">ps</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="c1">//rbegin az utolsó valid elem, ezzel elérem rögtön a map legutolsó elemét és adjuk vissza a topját</span>

    <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">()</span> <span class="k">const</span> <span class="c1">//egyik engedi felülírni a verem tetján lévő elemet a másik nek</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">ps</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">top</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">//csináljunk egy size-ot ami az összes elemszámot határozza meg</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span><span class="p">(</span><span class="k">typename</span> <span class="n">prs</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">i</span><span class="o">=</span><span class="n">ps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="o">!=</span><span class="n">ps</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">i</span><span class="o">-&gt;</span> <span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">();}</span> <span class="c1">//prs a baromi hosszú typename, map tartalma nem változhat emg ezért const iteratorral megyünk végig</span>
      <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>
</pre></div>
<p>stl átnézése vizsgára, megoldható nem ilyen stl-esen is</p>

</div>
</div>
</div>
    </div>
  </div>
</body>

 


</html>
